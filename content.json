{"meta":{"title":"洪创煌的博客","subtitle":"生命是一场练习！","description":"趁阳光正好，趁微风不噪。趁繁花还未开至荼蘼，趁现在还年轻。还可以走很长很长的路，还能诉说很深很深的思念。去寻找那些曾出现在梦境中的路径、山峦与田野吧。人无再少年，努力趁现在！","author":"洪创煌(hongchh_sysu@qq.com)","url":"https://hongchh.github.io"},"pages":[{"title":"about","date":"2017-11-10T03:08:10.000Z","updated":"2017-11-10T03:08:10.923Z","comments":true,"path":"about/index.html","permalink":"https://hongchh.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"微信小程序入坑: 写一个简化版知乎日报","slug":"微信小程序入坑-写一个简化版知乎日报","date":"2018-07-06T02:25:52.000Z","updated":"2018-07-08T08:54:34.694Z","comments":true,"path":"2018/微信小程序入坑-写一个简化版知乎日报/","link":"","permalink":"https://hongchh.github.io/2018/微信小程序入坑-写一个简化版知乎日报/","excerpt":"","text":"最近开始入坑微信小程序，发现想要练手也不容易，找免费的基于HTTPS的API就要花点时间。在看了网上一些介绍后，决定采用知乎日报的API，写一个简单版的知乎日报作为入坑练习。本文尝试使用微信小程序写一个小demo，实现知乎日报的3个主要页面以及部分功能。3个页面分别为“首页”、“详情页”和“评论页”。index: 首页，展示热闻轮播和热闻列表。点击某条热闻时跳转到详情页面。detail: 详情页，展示某条热闻的内容，可从该页面跳转至相应的评论页面。discussion: 评论页，展示某条热闻对应的长评和短评。备注：项目地址为https://github.com/hongchh/simplified-zhihu-daily/tree/master/wxmp一、项目结构和成果展示入坑练习比较简单，暂时按照微信小程序开发者工具所创建的模板项目结构来。项目的文件结构和相关描述如下。123456789101112131415161718├─pages: 各个页面的代码│ ├─detail: 详情页面│ │ ├─detail.js: 详情页面逻辑层代码│ │ ├─detail.wxml: 详情页面结构│ │ └─detail.wxss: 详情页面样式表│ ├─discussion: 评论页面│ │ ├─discussion.js: 评论页面逻辑层代码│ │ ├─discussion.wxml: 评论页面结构│ │ └─discussion.wxss: 评论页面样式表│ └─index: 首页│ ├─index.js: 首页逻辑层代码│ ├─index.wxml: 首页页面结构│ └─index.wxss: 首页样式表├─utils: 工具函数│ └─util.js: 工具函数├─app.js: 应用逻辑├─app.json: 应用公共配置└─app.wxss: 应用公共样式为了方便大家对这个入坑练习demo有个初步的了解，这里先放出最终的成果截图展示。二、开发首页首页分为两个部分，顶部有一个轮播，接着是一个热闻列表。轮播可以使用小程序提供的&lt;swiper&gt;组件来实现，比较简单。点击轮播项的时候需要跳转到相应的热闻详情页面，此处给最外层的&lt;swiper&gt;容器添加一个事件处理器，通过事件委托处理子元素的点击事件。子元素通过data-id来标记，当点击事件冒泡到外层父元素上时便可知道用户点击的是哪一条热闻。123456789&lt;swiper indicator-dots autoplay bindtap=\"goToStoryDetail\"&gt; &lt;swiper-item wx:for=\"&#123;&#123; topStories &#125;&#125;\" wx:key=\"&#123;&#123; item.id &#125;&#125;\" data-id=\"&#123;&#123; item.id &#125;&#125;\"&gt; &lt;view class=\"top-stories-item\" style=\"background-image: url(&#123;&#123; item.image &#125;&#125;)\" data-id=\"&#123;&#123; item.id &#125;&#125;\"&gt; &lt;view class=\"top-stories-item-text\" data-id=\"&#123;&#123; item.id &#125;&#125;\"&gt; &lt;text data-id=\"&#123;&#123; item.id &#125;&#125;\"&gt;&#123;&#123; item.title &#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/swiper-item&gt;&lt;/swiper&gt;热闻列表是一个分组的列表，显示热闻的时候按天显示。每组热闻的前面都会显示所属的时间，例如下图中的“今日热闻”、“7月5日 星期四”。因此这里的列表渲染是一个两重循环。逻辑层先将数据格式化好，视图层利用两层wx:for即可完成列表的渲染。最后，点击任一条热闻都需要跳转到相应的详情页，这里的处理方式与轮播那里一样，使用事件委托在最外层父元素上挂一个事件处理器即可。123456789&lt;view id=\"stories-list\" bindtap=\"goToStoryDetail\"&gt; &lt;block wx:for=\"&#123;&#123; storiesByDay &#125;&#125;\" wx:key=\"&#123;&#123; index &#125;&#125;\" wx:for-item=\"stories\"&gt; &lt;text id=\"stories-time\"&gt;&#123;&#123; stories.date &#125;&#125;&lt;/text&gt; &lt;view class=\"stories-list-item\" wx:for=\"&#123;&#123; stories.stories &#125;&#125;\" wx:key=\"&#123;&#123; item.id &#125;&#125;\" data-id=\"&#123;&#123; item.id &#125;&#125;\"&gt; &lt;text data-id=\"&#123;&#123; item.id &#125;&#125;\"&gt;&#123;&#123; item.title &#125;&#125;&lt;/text&gt; &lt;image src=\"&#123;&#123; item.images[0] &#125;&#125;\" data-id=\"&#123;&#123; item.id &#125;&#125;\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/block&gt;&lt;/view&gt;逻辑层中使用wx.request来获取数据，进入页面会触发onShow钩子，在onShow钩子中调用加载最近热闻的方法把首屏数据加载即可。12345678910111213141516171819202122232425262728293031323334Page(&#123; data: &#123; topStories: [], storiesByDay: [], beforeDay: '' &#125;, /** * 进入页面加载今日热闻 */ onShow () &#123; this.getStories() &#125;, /** * 获取首页数据 */ getStories () &#123; wx.request(&#123; url: 'https://news-at.zhihu.com/api/4/news/latest', success: (res) =&gt; &#123; this.setData(&#123; topStories: res.data.top_stories, storiesByDay: [&#123; stories: res.data.stories, date: '今日热闻' &#125;], beforeDay: res.data.date &#125;) &#125; &#125;) &#125; // ...&#125;)首屏数据只包含了今天的热闻，过往的热闻需要在页面上拉触底的时候进行加载。小程序页面上拉触底的时候会触发onReachBottom钩子，在onReachBottom钩子中调用加载过往热闻的接口即可，加载完成后通过setData把数据变化反映到视图层。过往热闻的时间按照“XX月XX日 星期X”的格式进行展示，在处理响应数据的时候通过工具函数对日期进行格式化即可。12345678910111213141516171819202122232425262728293031323334353637const utils = require('../../utils/util.js')Page(&#123; data: &#123; topStories: [], storiesByDay: [], beforeDay: '' &#125;, // ... /** * 上拉触底，加载更多热闻 */ onReachBottom () &#123; this.getMoreStories() &#125;, /** * 加载过往热闻 */ getMoreStories () &#123; wx.request(&#123; url: 'https://news-at.zhihu.com/api/4/news/before/' + this.data.beforeDay, success: (res) =&gt; &#123; this.data.storiesByDay.push(&#123; stories: res.data.stories, date: utils.formatDate(res.data.date) &#125;) this.setData(&#123; storiesByDay: this.data.storiesByDay, beforeDay: res.data.date &#125;) &#125; &#125;) &#125;&#125;)最后，点击首页热闻跳转至详情页，可以通过wx.navigateTo来实现。跳转的时候通过url将热闻的id传递给详情页的逻辑层。123456789101112Page(&#123; // ... /** * 点击某条热闻，跳转到热闻详情 */ goToStoryDetail (e) &#123; wx.navigateTo(&#123; url: '/pages/detail/detail?id=' + e.target.dataset.id &#125;) &#125;&#125;)页面样式参考了知乎日报APP中的样式，部分数值以及交互方式可能不一致，由于没有设计稿，样式都是根据感觉大致调一下。微信小程序的样式表跟传统的CSS几乎一样，除了部分需要说明的地方之外，本文对样式部分将不进行过多阐述。三、开发详情页详情页的内容是HTML富文本，调用详情接口会返回一段HTML和一个CSS样式表链接。由于微信小程序不能直接渲染HTML，因此这里还需要做一次富文本解析，将HTML转化为WXML。（下图中的body字段即为热闻的详细内容）这里我选择了wxParse来进行富文本解析，用法参照github上的描述，比较简单。请求接口获取数据后将HTML解析成WXML，渲染到页面上显示出来。123&lt;view id=\"story-content\"&gt; &lt;template is=\"wxParse\" data=\"&#123;&#123; wxParseData:story.nodes &#125;&#125;\"/&gt;&lt;/view&gt;1234567wx.request(&#123; url: 'https://news-at.zhihu.com/api/4/news/' + this.data.storyId, success: (res) =&gt; &#123; WxParse.wxParse('story', 'html', res.data.body, this, 5) // ... &#125;&#125;)接口返回的CSS样式表链接中包含有HTML标签名，在小程序这边不适用，因此接口返回的样式表可以直接舍弃。自己根据需要调整样式。wxParse本身有自己的样式表，显示出来也还可以。我这里对几个地方补充点样式作调整。通过开发者工具的Wxml面板查看解析后的标签类名，在wxss中对相应的类添加样式。例如作者信息，下面是调整样式前后的对比图。在这个demo中，详情页还实现了分享和跳转功能。由于小程序顶部的状态栏空间不太够，这里没有像知乎日报APP一样把操作按钮放在顶栏，而是固定在屏幕右下角。另外，由于没有引入图标库，微信小程序提供的icon又太少，这里暂时用字符图标代替。实现页面分享只需要设置按钮的open-type字段为share，然后在逻辑层的onShareAppMessage钩子中设置相关参数即可。1234&lt;view id=\"action\"&gt; &lt;button plain id=\"share\" open-type=\"share\"&gt;☍&lt;/button&gt; &lt;button plain id=\"discuss\" bindtap=\"goToDiscussion\"&gt;☷&lt;/button&gt;&lt;/view&gt;1234567891011Page(&#123; // ... onShareAppMessage () &#123; return &#123; title: this.data.title, imageUrl: this.data.image, path: '/pages/detail/detail?id=' + this.data.storyId &#125; &#125; // ...&#125;)跳转至评论页的实现与之前的从首页跳转到详情页的操作相同，使用wx.navigateTo实现页面跳转，通过url的查询字符串传递参数。12345678Page(&#123; // ... goToDiscussion () &#123; wx.navigateTo(&#123; url: '/pages/discussion/discussion?id=' + this.data.storyId &#125;) &#125;&#125;)四、开发评论页评论页比较简单，没有多余的操作，只需要在页面展示的时候调用接口获取长评以及短评数据即可。长评和短评的展示格式一样，下面是长评列表的WXML结构，使用wx:for进行列表渲染。跟详情页一样，由于没有合适的icon，这里点赞的icon使用字符❤代替。12345678910&lt;text id=\"long-comments-bar\"&gt;&#123;&#123; longComments.length &#125;&#125;条长评&lt;/text&gt;&lt;view class=\"comments\" wx:for=\"&#123;&#123; longComments &#125;&#125;\" wx:key=\"&#123;&#123; index &#125;&#125;\"&gt; &lt;view class=\"info\"&gt; &lt;image class=\"avatar\" src=\"&#123;&#123; item.avatar &#125;&#125;\" /&gt; &lt;text class=\"author\"&gt;&#123;&#123; item.author &#125;&#125;&lt;/text&gt; &lt;text class=\"likes\"&gt;❤ &#123;&#123; item.likes &#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;text class=\"content\"&gt;&#123;&#123; item.content &#125;&#125;&lt;/text&gt; &lt;text class=\"time\"&gt;&#123;&#123; item.time &#125;&#125;&lt;/text&gt;&lt;/view&gt;数据使用wx.request调用接口获取，长评和短评的接口数据格式都一样，因此写到同一个函数里。获取数据后都需要对数据中每条评论的时间进行格式化，转化为我们想要展示的格式，最后再交给视图层渲染展示。1234567891011121314151617181920212223242526Page(&#123; // ... /** * 加载长评或短评 * @param &#123; Number &#125; type 评论类型，0-长评，1-短评 */ getComments (type) &#123; const postfix = ['/long-comments', '/short-comments'] wx.request(&#123; url: 'https://news-at.zhihu.com/api/4/story/' + this.data.storyId + postfix[type], success: (res) =&gt; &#123; // 格式化评论发表时间 for (let i = 0; i &lt; res.data.comments.length; ++i) &#123; res.data.comments[i].time = utils.formatTime(res.data.comments[i].time) &#125; // 设置数据 if (type === 0) &#123; this.setData(&#123; longComments: res.data.comments &#125;) &#125; else &#123; this.setData(&#123; shortComments: res.data.comments &#125;) &#125; &#125; &#125;) &#125;&#125;)五、总结至此，简化版知乎日报的3个页面已经开发完成。由于demo比较简单，写起来比较快没什么难度，算是一次简易的入坑练习。虽然简单，但写的过程中也有发现点“不便之处”。无法在js中直接动态修改样式，尤其是内联样式。切换样式只能通过现在wxss中写好，然后通过数据绑定切换类名或id来实现。在详情页中，使用wxParse解析富文本后，它会给作者头像这个image元素添加一个内联样式，设置了图像高度，这个高度应该是wxParse根据某种规则计算出来的。在从详情页跳转到评论页再返回的时候，这里的计算会出现问题，导致高度变得很大，如下图所示。这里如果在wxss中相关的类名里面指明图像的width/height，会由于优先级低于内联样式而失效，无法解决这个问题。如果能在js中修改内联样式，便可以消除这个影响，可惜查了文档后发现并没有这种操作。最后是采取了下面这种做法，设置最大宽高度max-width/max-height，避开了与内联样式的冲突，又限制了图像的宽高，消除了这个影响。1234.answer .meta .avatar &#123; max-width: 34px; max-height: 34px;&#125;刚入坑，了解不多，后续再继续踩坑继续了解~","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://hongchh.github.io/tags/前端/"}]},{"title":"NodeJS C++ Addons之C++类实例包装与异步操作","slug":"NodeJS-Cpp-Addons之C-类实例包装与异步操作","date":"2018-04-19T09:20:27.000Z","updated":"2018-04-19T09:25:03.030Z","comments":true,"path":"2018/NodeJS-Cpp-Addons之C-类实例包装与异步操作/","link":"","permalink":"https://hongchh.github.io/2018/NodeJS-Cpp-Addons之C-类实例包装与异步操作/","excerpt":"","text":"本文是对NodeJS C++ Addons原生写法的进一步探索，介绍了利用原生的Node和V8提供的API实现类包装和异步调用的具体做法。在阅读本文之前，如果对NodeJS C++ Addons的基础不熟悉的话，建议先阅读上一篇博客【NodeJS C++ Addons基础】进行了解之后再回来阅读本文。本文所使用的代码示例可以从该仓库中找到–【cpp-addons】备注： 本文旨在探究NodeJS C++ Addons的原生写法，了解部分底层知识，所使用的NodeJS版本为8.11.1，由于V8原生的API会发生变动，不同版本的NodeJS的支持情况可能不同。因此不保证代码能兼容所有版本的NodeJS。一、C++类和对象实例的包装NodeJS C++插件除了可以向JavaScript提供函数接口之外，还可以将一些C++类或者C++对象实例包装后直接提供给JavaScript使用。举个例子，假设有个用C++实现的类，类名为SomeClass，现在想要在JavaScript中直接使用该类，通过new SomeClass(...)直接创建该类的实例并进行使用。接下来将使用一个简单的例子来说明如何进行C++类和对象的包装。在这个例子中，将实现一个C++类Accumulator，该类是一个累加器，提供add()和getAddTimes()两个方法，add()方法用于将参数累加并返回当前的累加值，getAddTimes()则是返回当前的累加次数。在创建Accumulator实例的时候，可以指定累加开始的初始值。最后，我们期望实现的效果如下，可以在JavaScript中使用这个C++类并创建该类的实例，并且可以调用该类上定义的方法。123456// cpp-object-wrap democonst AccumulatorModule = require('./build/Release/Accumulator')let acc = new AccumulatorModule.Accumulator(2)console.log('[ObjectWrapDemo] 2 + 12 = ' + acc.add(12))console.log('[ObjectWrapDemo] 2 + 12 + 5 = ' + acc.add(5))console.log('[ObjectWrapDemo] add times: ' + acc.getAddTimes())在C++中，Accumulator是一个通过class关键字定义的普通类，而在JavaScript中，一个类即为一个JS函数。在C++中，Accumulator的实例是一个普通的C++类实例，在JavaScript中，一个实例即为一个JS对象。JS函数在V8中对应的是一个v8::Function实例，JS对象在V8中对应的是一个v8::Object实例，因此，包装要做的事情，便是将一个C++类包装成一个v8::Function实例，将一个C++实例对象包装成一个v8::Object实例，然后提供给JavaScript使用。下面是该C++插件的实现源码，注释包含了对包装过程的介绍。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;node.h&gt;#include &lt;node_object_wrap.h&gt;namespace CppObjectWrapDemo &#123; using v8::Context; using v8::Function; using v8::FunctionCallbackInfo; using v8::FunctionTemplate; using v8::Isolate; using v8::Local; using v8::Number; using v8::Object; using v8::Persistent; using v8::String; using v8::Value; using v8::Exception; /* 将C++类封装给JS使用，需要继承node::ObjectWrap */ class Accumulator : public node::ObjectWrap &#123; public: /* 初始化该类的JS构造函数，并返回JS构造函数 */ static Local&lt;Function&gt; init (Isolate* isolate) &#123; /* 利用函数模板，将一个C++函数包装成JS函数 */ Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(isolate, AccumulatorJS); tpl-&gt;SetClassName(String::NewFromUtf8(isolate, \"Accumulator\")); tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1); /* 类方法定义在构造函数的prototype上 */ NODE_SET_PROTOTYPE_METHOD(tpl, \"add\", add); NODE_SET_PROTOTYPE_METHOD(tpl, \"getAddTimes\", getAddTimes); /* 获取Accumulator类的JS构造函数 */ Local&lt;Function&gt; fn = tpl-&gt;GetFunction(); /* JS构造函数句柄存储于constructor上，后续还会使用到 */ constructor.Reset(isolate, fn); return fn; &#125; private: /* 成员变量 */ static Persistent&lt;Function&gt; constructor; double value; int addTimes; /* 该类的C++构造函数，设置成员变量初始值 */ explicit Accumulator (double initValue = 0) &#123; this-&gt;value = initValue; this-&gt;addTimes = 0; &#125; /* 该类的JS构造函数，创建该类的对象，并包装成JS对象然后进行返回 */ static void AccumulatorJS (const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); if (args.IsConstructCall()) &#123;/* 通过 new Accumulator() 创建对象 */ /* 提取参数数值 */ double val = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue(); /* 创建该类的实例对象 */ Accumulator* obj = new Accumulator(val); /* 包装该对象 */ obj-&gt;Wrap(args.This()); /* 返回该对象 */ args.GetReturnValue().Set(args.This()); &#125; else &#123;/* 通过直接调用函数 Accumulator() 创建对象，抛出异常 */ isolate-&gt;ThrowException(Exception::TypeError( String::NewFromUtf8(isolate, \"Should use the new operator to create an instance.\") )); &#125; &#125; /* 该类的成员方法，增加value的值 */ static void add (const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); /* 将被包装的JS对象还原为C++对象 */ Accumulator* obj = node::ObjectWrap::Unwrap&lt;Accumulator&gt;(args.Holder()); /* 访问C++对象上的成员变量进行操作 */ obj-&gt;value += args[0]-&gt;NumberValue(); obj-&gt;addTimes += 1; args.GetReturnValue().Set(Number::New(isolate, obj-&gt;value)); &#125; /* 该类的成员方法，获取累加次数 */ static void getAddTimes (const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); /* 将被包装的JS对象还原为C++对象 */ Accumulator* obj = node::ObjectWrap::Unwrap&lt;Accumulator&gt;(args.Holder()); args.GetReturnValue().Set(Number::New(isolate, obj-&gt;addTimes)); &#125; &#125;; Persistent&lt;Function&gt; Accumulator::constructor; void init (Local&lt;Object&gt; exports) &#123; Isolate* isolate = exports-&gt;GetIsolate(); /* 初始化Accumulator类的JS构造函数 */ Local&lt;Function&gt; _Accumulator = Accumulator::init(isolate); /* 将Accumulator类的JS构造函数暴露给JS使用 */ /* 这里不能使用NODE_SET_METHOD，因为NODE_SET_METHOD是暴露一个C++函数给JS使用 */ /* NODE_SET_METHOD(exports, \"Accumulator\", _Accumulator); */ /* 此处是暴露一个JS函数，它在C++里面表示为一个Function对象，不是一个C++函数 */ /* 要通过设置属性的方法将其挂到exports上 */ exports-&gt;Set(String::NewFromUtf8(isolate, \"Accumulator\"), _Accumulator); &#125; NODE_MODULE(NODE_GYP_MODULE_NAME, init)&#125;进行C++类包装，需要引入头文件&lt;node_object_wrap.h&gt;，被包装的类需要继承node::ObjectWrap类。被包装的C++类除了拥有自己的C++构造函数之外，还需要有一个JS构造函数，C++构造函数在创建该类的C++实例的时候会被调用，而JS构造函数则是在JavaScript中创建该类的对象的时候会被调用。在JS构造函数中写好当JS创建C++类实例的时候要进行的操作，然后将该JS构造函数包装成一个v8::Function提供给JavaScript使用。以上面代码为例，AccumulatorJS是该类的JS构造函数，在AccumulatorJS执行的时候，会创建一个C++类实例，然后将该实例包装变成一个v8::Object之后返回。AccumulatorJS本身是一个C++函数，为了能在JS中调用到它，需要先在Accumulator::init方法利用FunctionTemplate根据AccumulatorJS定制出一个JS函数。在JS中，使用函数来实现类，类的成员方法一般定义在构造函数的原型（prototype）上。在Accumulator::init方法中，使用NODE_SET_PROTOTYPE_METHOD来将C++类的成员方法挂到JS构造函数的原型上。这样做以后，在JS中创建出该类的实例后，便可以调用到这些成员方法了。该类的成员方法add()和getAddTimes()会在JS中被调用，所以在调用时也会得到const FunctionCallbackInfo&lt;Value&gt;&amp; args参数。可以通过args参数来进行获取JS传递过来的参数信息以及设置返回值等操作。由于在这两个成员方法中，需要访问到类实例上成员变量，因此需要先将发起调用的JS对象解包装，还原成C++实例。解包装时候会用到node::ObjectWrap::Unwrap&lt;Accumulator&gt;(args.Holder())，args.Holder()可以获取到发起调用的JS对象实例。实现了类和对象实例的包装以后，便可以将相关接口暴露给JS使用了。跟其他C++插件模块一样，也是通过module.exports属性来暴露相关接口。这里需要注意的点在代码注释中也有说明，由于我们暴露给JS使用的东西是一个JS构造函数，而不是普通的C++函数，所以不能使用NODE_SET_METHOD来设置暴露的内容，而是直接通过exports对象的Set()方法来进行设置。完成之后将下面内容写入binding.gyp，进行编译构建，得到.node文件后便可以利用前面展示的JS代码去进行测试了。JS代码运行后的输出结果如图所示，可以验证通过类和对象实例的包装，JS能够直接使用C++的类和实例。123456&#123; \"targets\": [&#123; \"target_name\": \"accumulator\", \"sources\": [\"accumulator.cc\"] &#125;]&#125;二、C++类实例工厂前面展示了如何将一个C++类进行包装然后暴露给JavaScript使用。在使用过程中，JavaScript能够直接通过new操作符来创建该类的实例。现在，我们希望C++模块能够提供一个工厂函数，JavaScript调用该工厂函数之后也可以获取到该C++类的实例，而不需要通过new操作符来创建实例。继续在前面的Accumulator例子上进行改进，以探索实现C++向JavaScript提供类实例工厂函数的方法。给Accumulator增加getInstance()方法，通过Accumulator::getInstance()方法，可以在C++代码里面主动调用Accumulator类的JS构造函数，从而创建一个类实例并将类实例包装成JS对象，达到与在JS中使用new操作符时同样的目的。下面是代码展示，部分操作在注释中有进行说明。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;node.h&gt;#include &lt;node_object_wrap.h&gt;namespace CppObjectWrapDemo &#123; using v8::Context; using v8::Function; using v8::FunctionCallbackInfo; using v8::FunctionTemplate; using v8::Isolate; using v8::Local; using v8::Number; using v8::Object; using v8::Persistent; using v8::String; using v8::Value; using v8::Exception; /* 将C++类封装给JS使用，需要继承node::ObjectWrap */ class Accumulator : public node::ObjectWrap &#123; public: /* 初始化该类的JS构造函数，并返回JS构造函数 */ static Local&lt;Function&gt; init (Isolate* isolate) &#123; /* 利用函数模板，将一个C++函数包装成JS函数 */ Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(isolate, AccumulatorJS); tpl-&gt;SetClassName(String::NewFromUtf8(isolate, \"Accumulator\")); tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1); /* 类方法定义在构造函数的prototype上 */ NODE_SET_PROTOTYPE_METHOD(tpl, \"add\", add); NODE_SET_PROTOTYPE_METHOD(tpl, \"getAddTimes\", getAddTimes); /* 获取Accumulator类的JS构造函数 */ Local&lt;Function&gt; fn = tpl-&gt;GetFunction(); /* JS构造函数句柄存储于constructor上，后续还会使用到 */ constructor.Reset(isolate, fn); return fn; &#125; /* 获取该类实例的工厂函数 */ static void getInstance (const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); Local&lt;Value&gt; argv[1] = &#123; args[0] &#125;; /* 获取当前上下文 */ Local&lt;Context&gt; context = isolate-&gt;GetCurrentContext(); /* 生成JS构造函数 */ Local&lt;Function&gt; _constructor = Local&lt;Function&gt;::New(isolate, constructor); /* 创建实例 */ Local&lt;Object&gt; obj = _constructor-&gt;NewInstance(context, 1, argv).ToLocalChecked(); /* 返回实例 */ args.GetReturnValue().Set(obj); &#125; private: /* 成员变量 */ static Persistent&lt;Function&gt; constructor; double value; int addTimes; /* 该类的C++构造函数，设置成员变量初始值 */ explicit Accumulator (double initValue = 0) &#123; this-&gt;value = initValue; this-&gt;addTimes = 0; &#125; /* 该类的JS构造函数，创建该类的对象，并包装成JS对象然后进行返回 */ static void AccumulatorJS (const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); if (args.IsConstructCall()) &#123;/* 通过 new Accumulator() 创建对象 */ /* 提取参数数值 */ double val = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue(); /* 创建该类的实例对象 */ Accumulator* obj = new Accumulator(val); /* 包装该对象 */ obj-&gt;Wrap(args.This()); /* 返回该对象 */ args.GetReturnValue().Set(args.This()); &#125; else &#123;/* 通过直接调用函数 Accumulator() 创建对象，抛出异常 */ isolate-&gt;ThrowException(Exception::TypeError( String::NewFromUtf8(isolate, \"Should use the new operator to create an instance.\") )); &#125; &#125; /* 该类的成员方法，增加value的值 */ static void add (const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); /* 将被包装的JS对象还原为C++对象 */ Accumulator* obj = node::ObjectWrap::Unwrap&lt;Accumulator&gt;(args.Holder()); /* 访问C++对象上的成员变量进行操作 */ obj-&gt;value += args[0]-&gt;NumberValue(); obj-&gt;addTimes += 1; args.GetReturnValue().Set(Number::New(isolate, obj-&gt;value)); &#125; /* 该类的成员方法，获取累加次数 */ static void getAddTimes (const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); /* 将被包装的JS对象还原为C++对象 */ Accumulator* obj = node::ObjectWrap::Unwrap&lt;Accumulator&gt;(args.Holder()); args.GetReturnValue().Set(Number::New(isolate, obj-&gt;addTimes)); &#125; &#125;; Persistent&lt;Function&gt; Accumulator::constructor; void getAccumulatorInstance(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Accumulator::getInstance(args); &#125; void init (Local&lt;Object&gt; exports) &#123; Isolate* isolate = exports-&gt;GetIsolate(); /* 初始化Accumulator类的JS构造函数 */ Local&lt;Function&gt; _Accumulator = Accumulator::init(isolate); /* 将Accumulator类的JS构造函数暴露给JS使用 */ /* 这里不能使用NODE_SET_METHOD，因为NODE_SET_METHOD是暴露一个C++函数给JS使用 */ /* NODE_SET_METHOD(exports, \"Accumulator\", _Accumulator); */ /* 此处是暴露一个JS函数，它在C++里面表示为一个Function对象，不是一个C++函数 */ /* 要通过设置属性的方法将其挂到exports上 */ exports-&gt;Set(String::NewFromUtf8(isolate, \"Accumulator\"), _Accumulator); /* 将获取实例的工厂方法暴露给JS */ NODE_SET_METHOD(exports, \"getAccumulatorInstance\", getAccumulatorInstance); &#125; NODE_MODULE(NODE_GYP_MODULE_NAME, init)&#125;Accumulator::getInstance()方法中，利用_constructor的NewInstance()方法可以创建一个实例，执行该方法的作用相当于JS中使用new操作符时候的作用，也会调用对应的JS构造函数，从而创建出该类的实例并包装成一个JS对象进行返回。Accumulator::getInstance()方法在C++中调用，为了将其暴露给JavaScript使用，在最后还需要创建一个getAccumulatorInstance()函数，在这个函数里面完成对Accumulator::getInstance()的调用。将getAccumulatorInstance()挂到exports属性上后便可提供给JavaScript使用了。可使用下面的JS代码对C++模块进行检验，代码输出如图所示。JavaScript能够调用C++模块提供的工厂函数，从而获得一个C++类的实例并且可以对该实例进行使用，调用该类所定义的成员方法。1234567// cpp-object-wrap-factory democonst AccumulatorModule = require('./build/Release/Accumulator')let acc2 = AccumulatorModule.getAccumulatorInstance(3)console.log('[ObjectWrapFactoryDemo] 3 + 16 = ' + acc2.add(16))console.log('[ObjectWrapFactoryDemo] 3 + 16 + 7 = ' + acc2.add(7))console.log('[ObjectWrapFactoryDemo] 3 + 16 + 7 + 4 = ' + acc2.add(4))console.log('[ObjectWrapFactoryDemo] add times: ' + acc2.getAddTimes())三、异步操作NodeJS C++插件可以提供接口给JavaScript使用，在上一篇博客【NodeJS C++ Addons基础】也已经给出不少示例。不过，在之前的示例中，实现的都是同步调用。按照之前的做法，JavaScript调用C++插件模块提供的接口后，会阻塞JavaScript代码的执行。同步调用带来的阻塞不符合JavaScript异步的特点，在遇到复杂耗时的任务时，这种阻塞更是严重影响应用的性能。为了解决这个问题，就需要实现异步调用，使得C++插件模块的接口在被调用后不会阻塞JavaScript的执行。实现异步操作需要用到libuv这个库，libuv是一个跨平台的抽象库，它实现了Node.js的事件循环、工作线程、以及平台所有的的异步操作。利用libuv可以很方便地让C++插件模块的接口异步化。接下来将对上一篇博客【NodeJS C++ Addons基础】中的使用的累加求和的例子进行改进，实现异步调用。下面是改进后的代码，在注释中会对部分操作进行阐述。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;uv.h&gt;#include &lt;node.h&gt;#include &lt;vector&gt;namespace AsyncDemo &#123; using v8::Function; using v8::FunctionCallbackInfo; using v8::Isolate; using v8::Local; using v8::Number; using v8::Object; using v8::Value; using v8::Null; using v8::Exception; using v8::String; using v8::Undefined; using v8::Persistent; using v8::HandleScope; /* 存放数据供子线程使用的结构体 */ struct Data &#123; /* 回调函数 */ Persistent&lt;Function&gt; callback; /* 求和参数 */ std::vector&lt;double&gt; args; /* 求和结果 */ double result; &#125;; /* 子线程执行的代码 */ void calculate (uv_work_t* req) &#123; Data* data = static_cast&lt;Data*&gt;(req-&gt;data); /* 遍历参数进行求和 */ data-&gt;result = 0.0; for (int i = 0; i &lt; data-&gt;args.size(); ++i) &#123; data-&gt;result += data-&gt;args[i]; &#125; &#125; /* 子线程结束后执行的代码 */ void calculateComplete (uv_work_t* req) &#123; Data* data = static_cast&lt;Data*&gt;(req-&gt;data); Isolate* isolate = Isolate::GetCurrent(); /* 必须创建一个HandleScope，否则后面无法创建句柄 */ HandleScope handleScope(isolate); /* 将求和结果转换为一个JS Number */ Local&lt;Value&gt; argv[1] = &#123; Number::New(isolate, data-&gt;result) &#125;; /* 通过回调函数返回求和结果 */ Local&lt;Function&gt; cb = Local&lt;Function&gt;::New(isolate, data-&gt;callback); cb-&gt;Call(Null(isolate), 1, argv); /* 回调完成后清除资源 */ data-&gt;callback.Reset(); delete data; delete req; &#125; void accumulateAsync (const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); /* 参数不合理异常 */ if (args.Length() &lt; 1) &#123; isolate-&gt;ThrowException(Exception::TypeError( String::NewFromUtf8(isolate, \"Arguments Number Error.\") )); return; &#125; /* 没有回调函数 */ if (!args[args.Length() - 1]-&gt;IsFunction()) &#123; isolate-&gt;ThrowException(Exception::TypeError( String::NewFromUtf8(isolate, \"No Callback Error.\") )); return; &#125; /* 提取通过参数传递的回调函数 */ Local&lt;Function&gt; callback = Local&lt;Function&gt;::Cast(args[args.Length() - 1]); /* 创建Data结构体存储数据 */ Data* data = new Data(); /* 存储回调函数 */ data-&gt;callback.Reset(isolate, callback); /* 提取参数并存储到data */ for (int i = 0; i &lt; args.Length() - 1; ++i) &#123; /* 如果参数不是数字，向js抛出异常 */ if (!args[i]-&gt;IsNumber()) &#123; isolate-&gt;ThrowException(Exception::TypeError( String::NewFromUtf8(isolate, \"Arguments Type Error.\") )); return; &#125; else &#123; data-&gt;args.push_back(args[i]-&gt;NumberValue()); &#125; &#125; /* 启动工作线程进行求和计算 */ uv_work_t *req = new uv_work_t(); req-&gt;data = data; uv_queue_work( uv_default_loop(), req, (uv_work_cb)calculate, (uv_after_work_cb)calculateComplete ); /* 本函数直接返回，无需等待线程计算完成 */ args.GetReturnValue().Set(Undefined(isolate)); &#125; void init (Local&lt;Object&gt; exports) &#123; NODE_SET_METHOD(exports, \"accumulateAsync\", accumulateAsync); &#125; NODE_MODULE(NODE_GYP_MODULE_NAME, init)&#125;使用libuv这个库，需要包含头文件&lt;uv.h&gt;。利用uv_queue_work(uv_loop_t* loop, uv_work_t* req, uv_work_cb work_cb, uv_after_work_cb after_work_cb)这个方法将任务发送到线程池，指明子线程的执行函数work_cb和回调函数after_work_cb后，子线程会执行work_cb，并且在线程执行完毕后回调after_work_cb。uv_work_t* req用来存放发起线程调用的请求信息，在执行函数work_cb和回调函数after_work_cb中可以通过req来获取主线程想要子线程处理的数据。在内存上，线程不共享栈，但是共享堆，因此，主线程可以通过一个结构体来包装数据然后在堆上创建该结构体的实例，子线程通过指针去堆上获取该结构体实例便可以获取到主线程想要传递的数据，也可以通过这个实例将数据返回给主线程。以上面代码为例，在accumulateAsync()方法中，完成参数检查和提取以后，便可以开启一个子线程去对数据进行操作计算，不必等待子线程结束直接返回。JavaScript调用accumulateAsync()方法之后，实际上是开启了一个子线程去完成求和过程，accumulateAsync()方法调用后马上返回，因此不会阻塞到后续的JavaScript代码的执行。子线程的执行函数calculate会完成求和计算过程，并将求和结果存放到Data结构体的一个实例中，子线程执行完毕后会唤醒主线程，运行回调函数calculateComplete，在calculateComplete中完成对JavaScript回调函数的调用，将求和结果通过回调函数回传给JavaScript。结构体Data中，存储JS回调函数的句柄时需要使用Persistent句柄，Persistent句柄需要主动执行代码进行释放，与之相对的Local句柄会在函数调用结束后句柄作用域消失时被释放，失去句柄引用的变量会被V8的垃圾清理机制自动清除。由于子线程执行时主线程的accumulateAsync()方法已经结束返回了，为了让回调函数不会清理，在子线程结束后能够顺利完成回调JavaScript，这里必须使用Persistent句柄。将以下内容写入文件binding.gyp，完成编译构建得到.node文件。123456&#123; \"targets\": [&#123; \"target_name\": \"accumulate_async\", \"sources\": [\"accumulate_async.cc\"] &#125;]&#125;使用以下JS代码进行测试，输出结果如图所示，可以看到先输出的语句是Hi~，由于实现了异步调用，求和过程不会阻塞JavaScript代码的执行，因此在调用accumulateAsync()之后，跟在后面的console.log(&#39;[AsyncDemo] Hi~&#39;)不会被阻塞，正常执行。123456// async-democonst AccumulateAsync = require('./build/Release/accumulate_async')AccumulateAsync.accumulateAsync(1, 3, 4, 7, (sum) =&gt; &#123; console.log('[AsyncDemo] 1 + 3 + 4 + 7 = ' + sum)&#125;)console.log('[AsyncDemo] Hi~')四、小结实现C++类和实例的包装，让JavaScript能够直接使用到C++类和实例，这个过程的操作虽然繁琐了一点，但也不是太难，&lt;node_object_wrap.h&gt;中提供的API已经可以很方便地实现这个功能。实现C++插件接口的异步化，让JavaScript能够进行异步调用而不被阻塞，需要用到多线程的知识。在NodeJS官方文档中对如何使用libuv进行异步操作并没有相关例子展示，所以在写前面的例子的时候也比较折腾。libuv的API文档比较晦涩，幸好网上还有另一份介绍文档【An Introduction to libuv】，这份文档中除了对一些概念和API进行介绍之外，也会有给出代码示例，对初学者来说比较友好。","categories":[],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://hongchh.github.io/tags/NodeJS/"}]},{"title":"NodeJS C++ Addons基础","slug":"NodeJS-Cpp-Addons基础","date":"2018-04-16T07:45:57.000Z","updated":"2018-04-19T09:20:51.310Z","comments":true,"path":"2018/NodeJS-Cpp-Addons基础/","link":"","permalink":"https://hongchh.github.io/2018/NodeJS-Cpp-Addons基础/","excerpt":"","text":"NodeJS C++插件是一种动态链接库，采用C/C++语言编写，可以通过require()将插件加载进NodeJS中进行使用。利用V8提供的API，可以实现JavaScript和C++的互相调用，打通JavaScript和C++之间的接口。在做一些高性能或者底层模块的时候，需要用到一些C++库，NodeJS C++插件可以帮助我们封装这些C++库的接口，使得JavaScript具备调用C++库的能力。本文将记录利用基础的V8 API编写NodeJS C++插件的过程，实现C++和JavaScript之间的参数传递、函数调用以及回调、异常处理以及对象函数传递等功能。记录过程中也会对部分概念和API进行阐述。本文所使用的代码示例可以从该仓库中找到–【cpp-addons】一、基本概念1.1、hello world示例首先通过一个简单的HelloWorld示例来了解编写C++插件的基本写法和一些API的基本概念。在示例中，C++模块向JavaScript暴露了一个hello接口，在JavaScript中调用该接口后会得到返回值hello world。123456789101112131415161718192021222324#include &lt;node.h&gt;namespace HelloWorldDemo &#123; using v8::FunctionCallbackInfo; using v8::Isolate; using v8::Local; using v8::Object; using v8::String; using v8::Value; void hello (const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); /* 通过 FunctionCallbackInfo&lt;Value&gt;&amp; args 可以设置返回值 */ args.GetReturnValue().Set(String::NewFromUtf8(isolate, \"hello world.\")); &#125; void init (Local&lt;Object&gt; exports) &#123; /* 设置模块的导出方法 hello */ /* 等价于 js 模块中的 module.exports.hello = hello */ NODE_SET_METHOD(exports, \"hello\", hello); &#125; NODE_MODULE(NODE_GYP_MODULE_NAME, init)&#125;JavaScript调用C++模块的方法时，会传递一个V8对象，类型为FunctionCallbackInfo&lt;Value&gt;。通过这个V8对象，JavaScript可以向C++接口传递参数，C++函数也可以通过这个对象来向JavaScript回传信息，即设置返回值。在C++接口中，通过参数const FunctionCallbackInfo&lt;Value&gt;&amp; args可以拿到一个Isolate对象，Isolate代表一个V8虚拟机实例。通过args.GetIsolate()可以获取到运行JavaScript调用者的V8虚拟机实例。这个V8实例包含了内存堆，在C++接口中创建V8提供的JavaScript对象类型实例的时候会使用到。例如前面的hello world例子中，在创建一个JS字符串的时候需要传递isolate对象，表示在该V8虚拟机上创建了一个JS字符串对象，之后该字符串便可以被V8虚拟机上运行的JS调用者所使用。Local是一个模板句柄类，Local&lt;SomeType&gt;代表指向某种类型的句柄。例如模块的exports属性是一个JavaScript对象，句柄类型为Local&lt;Object&gt;。传递给init函数的参数其实是指向相应对象的句柄。NODE_MODULE是一个宏，设置模块初始化函数为init。init函数中执行模块的初始化，当模块第一次被加载进NodeJS应用中的时候就会执行init函数，init函数中可以设置exports属性将C++接口暴露出去给JavaScript使用。NODE_SET_METHOD用于设置属性或方法，第二个参数为属性名，第三个参数为方法对应的属性值。如果需要给exports对象设置多个属性或方法，可以调用多次NODE_SET_METHOD。exports对象上设置的属性方法将会作为接口暴露给外部使用。编写NodeJS C++插件必须遵循以下这种模式：必须有一个初始化函数对模块进行初始化（设置方法属性等），然后加上NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)设置模块名和初始化函数。初始化函数可以有两种写法，第一种写法常用于设置模块的exports对象上的某个属性或方法，第二种写法可用于直接重写整个exports对象。1234567891011121314151617// 写法1void Initialize_1(Local&lt;Object&gt; exports) &#123; // 进行初始化... // example // 等价于js模块中的 module.exports.hello = hello NODE_SET_METHOD(exports, \"hello\", hello);&#125;NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize_1)// 写法2void Initialize_2(Local&lt;Object&gt; exports, Local&lt;Object&gt; module) &#123; // 进行初始化... // example // 等价于js模块中的 module.exports = hello NODE_SET_METHOD(module, \"exports\", hello);&#125;NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize_2)1.2、构建方法编写完C++代码后需要将其编译构建成node文件才能够被NodeJS使用。利用node-gyp可以很方便地进行构建。首先在C++代码文件的根目录下创建一个binding.gyp文件，在文件中写入类似下面的JSON格式的内容。如果有多个插件，可以在targets数组上继续添加。数组的元素为一个对象，对象的target_name属性指明构建后的插件名称，sources属性则是C++源码路径。sources属性是一个数组，如果插件对应的源码文件有多个，只需在数组中列举出对应的多个路径即可。例如下面的示例，C++源码hello.cc经过构建之后，会生成名为addon.node的插件。123456&#123; \"targets\": [&#123; \"target_name\": \"addon\", \"sources\": [\"hello.cc\"] &#125;]&#125;写好binding.gyp以后，只需要执行以下2个命令即可完成构建，两句命令可以分开执行，也可以合并成一句。configure指令执行后会在当前目录下生成build文件夹，并在build文件夹中生成相应平台的构建文件（例如Linux下的Makefile）。build执行后则是编译源码生成拓展名为node的NodeJS插件，插件会输出到./build/Release/或./build/Debug/文件夹下。1234node-gyp configurenode-gyp build# 合并成一句node-gyp configure build构建完成后，在JS中直接通过require便可引用到该插件，然后便可在JS中直接调用插件上设置的接口。.node文件实际上是一个动态链接库，使用require时可以省略掉拓展名.node，NodeJS会自动去加载这个动态链接库。不过这里有个要点需要注意，使用require引用模块的时候，会优先寻找拓展名为.js的模块，所以，如果相同路径下同时存在.node和.js文件，require引用到的其实是.js文件。例如：如果./build/Release/文件夹下同时存在addon.js和addon.node，这时下面这行代码执行后将加载到addon.js。1const addon = require('./build/Release/addon')1.3、运行结果通过下面的binding.gyp将前面的hello world示例代码进行编译构建，生成hello_world.node文件。123456&#123; \"targets\": [&#123; \"target_name\": \"hello_world\", \"sources\": [\"hello_world.cc\"] &#125;]&#125;接下来用以下代码对C++插件进行使用。可以看到成功实现了在JavaScript中调用C++接口，接口执行后返回字符串hello world。123// hello-world democonst HelloWorld = require('./build/Release/hello_world')console.log('[HelloWorldDemo] ' + HelloWorld.hello())二、函数传参与回调在调用C++接口的时候，经常需要向接口传递参数。前面提到，JavaScript调用C++接口的时候会向其传递一个类型为FunctionCallbackInfo&lt;Value&gt;对象，通过这个对象可以实现向C++接口传递参数，参数可以是普通的JS对象，也可以是函数。传递函数参数时，还可以实现回调，即JavaScript在调用C++接口时向其传递回调函数，C++接口执行后回调JavaScript。接下来通过实现一个累加函数探索函数传参和回调的实现。累加函数accumulate的作用是对参数进行累加求和，然后返回求和结果。例如调用accumulate(1, 2, 3)将得到1+2+3的结果，即6。为了同时展示传参和回调，accumulate函数的求和结果不能像前面hello world例子中一样直接通过设置返回值进行返回，而是要通过回调函数进行返回。假设调用accumulate函数时通过最后一个参数传递回调函数，则调用时的写法将变为accumulate(1, 2, 3, callback)。下面是C++模块的代码。1234567891011121314151617181920212223242526272829303132333435#include &lt;node.h&gt;namespace FunctionArgumentsAndCallbackDemo &#123; using v8::Function; using v8::FunctionCallbackInfo; using v8::Isolate; using v8::Local; using v8::Number; using v8::Object; using v8::Value; using v8::Null; void accumulate (const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); /* 提取通过参数传递的回调函数 */ Local&lt;Function&gt; callback = Local&lt;Function&gt;::Cast(args[args.Length() - 1]); /* 遍历参数进行求和 */ double sum = 0.0; for (int i = 0; i &lt; args.Length() - 1; ++i) &#123; sum += args[i]-&gt;NumberValue(); &#125; /* 将求和结果转成一个js Number, 通过回调函数进行返回 */ Local&lt;Number&gt; num = Number::New(isolate, sum); Local&lt;Value&gt; argv[1] = &#123; num &#125;; callback-&gt;Call(Null(isolate), 1, argv); &#125; void init (Local&lt;Object&gt; exports) &#123; NODE_SET_METHOD(exports, \"accumulate\", accumulate); &#125; NODE_MODULE(NODE_GYP_MODULE_NAME, init)&#125;上述代码中通过args可以获得从JavaScript传递过来的参数，这些参数都是JavaScript对象实例，使用时需要根据情况调用相关方法，例如求和的参数是多个数字，在JavaScript中数字都是Number对象实例，需要调用NumberValue()方法后才能获取到对应的double类型数值。通过Local&lt;Function&gt;::Cast()获取到回调函数的句柄，获取句柄后可以通过Call()方法对回调函数进行调用，调用时需要传递参数个数和参数实例（参数实例需要以数组形式进行传递）。通过这种方式实现的函数回调为同步回调，不是异步回调，异步回调的实现需要用到其他技巧，不在本文的讨论范围之内。给binding.gyp中的targets数组添加以下元素，然后继续使用node-gyp configure build进行编译构建生成.node文件。1234&#123; \"target_name\": \"accumulate\", \"sources\": [\"accumulate.cc\"]&#125;通过以下JavaScript代码即可使用C++插件，并验证接口是否调用成功。代码输出如果所示，accumulate接口成功对参数进行求和并通过回调函数返回了求和结果。12345// function-arguments-and-callbacks democonst Accumulate = require('./build/Release/accumulate')Accumulate.accumulate(1, 3, 4, 7, (sum) =&gt; &#123; console.log('[FunctionArgumentsAndCallbacksDemo] 1 + 3 + 4 + 7 = ' + sum)&#125;)三、异常处理C++插件提供的接口函数如果在运行后遇到异常，JavaScript调用者是否可以知道异常并进行处理呢？答案是可以的，V8提供的API使得C++可以直接向JavaScript抛出异常。前面提到，Isolate对象代表一个V8虚拟机实例。我们可以通过这个实例直接向该V8虚拟机抛出异常，该虚拟机实例上运行的JavaScript代码只要对异常进行捕获就可以知道异常的发生并进行相应的处理了。上面的累加求和例子中，没有考虑传递的参数类型就直接进行求和，在某些情况下可能发生异常。接下来，对上面的例子进行改进，增加异常处理机制，探索C++插件如何向JavaScript报告异常。代码如下所示。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;node.h&gt;namespace FunctionArgumentsAndCallbackDemo &#123; using v8::Function; using v8::FunctionCallbackInfo; using v8::Isolate; using v8::Local; using v8::Number; using v8::Object; using v8::Value; using v8::Null; using v8::Exception; using v8::String; void accumulate (const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); /* 参数不合理异常 */ if (args.Length() &lt; 1) &#123; isolate-&gt;ThrowException(Exception::TypeError( String::NewFromUtf8(isolate, \"Arguments Number Error.\") )); return; &#125; /* 没有回调函数 */ if (!args[args.Length() - 1]-&gt;IsFunction()) &#123; isolate-&gt;ThrowException(Exception::TypeError( String::NewFromUtf8(isolate, \"No Callback Error.\") )); return; &#125; /* 提取通过参数传递的回调函数 */ Local&lt;Function&gt; callback = Local&lt;Function&gt;::Cast(args[args.Length() - 1]); /* 遍历参数进行求和 */ double sum = 0.0; for (int i = 0; i &lt; args.Length() - 1; ++i) &#123; /* 如果参数不是数字，向js抛出异常 */ if (!args[i]-&gt;IsNumber()) &#123; isolate-&gt;ThrowException(Exception::TypeError( String::NewFromUtf8(isolate, \"Arguments Type Error.\") )); return; &#125; else &#123; sum += args[i]-&gt;NumberValue(); &#125; &#125; /* 将求和结果转成一个js Number, 通过回调函数进行返回 */ Local&lt;Number&gt; num = Number::New(isolate, sum); Local&lt;Value&gt; argv[1] = &#123; num &#125;; callback-&gt;Call(Null(isolate), 1, argv); &#125; void init (Local&lt;Object&gt; exports) &#123; NODE_SET_METHOD(exports, \"accumulate\", accumulate); &#125; NODE_MODULE(NODE_GYP_MODULE_NAME, init)&#125;通过Isolate对象的ThrowException方法，可以直接向JavaScript抛出异常。在JavaScript中，通过try/catch机制便可以捕获和处理异常。下面是代码示例，调用C++接口的时候故意引发异常，捕获到异常后将异常信息进行输出。如果图所示，可以成功实现C++模块向JavaScript抛出异常以及JavaScript捕获处理异常。1234567891011121314151617181920// exception demotry &#123; Accumulate.accumulate()&#125; catch (err) &#123; console.log('[ExceptionDemo] ' + err)&#125;try &#123; Accumulate.accumulate(1, 2, 3)&#125; catch (err) &#123; console.log('[ExceptionDemo] ' + err)&#125;try &#123; Accumulate.accumulate(1, 2, 'a', (sum) =&gt; &#123; console.log(sum) &#125;)&#125; catch (err) &#123; console.log('[ExceptionDemo] ' + err)&#125;四、返回对象和函数前面的例子中，JavaScript可以通过args向C++传递JS对象和函数给C++模块使用，如果反过来让C++传递对象和函数给JavaScript使用，是否可以实现呢？答案是可以的。前面的例子展示了C++模块可以通过args.GetReturnValue().Set(xxx)来向JavaScript返回内容，这里返回的内容除了向前面例子中的普通String、Number等对象之外，也可以返回Object或者Function。C++模块中，可以将需要的信息封装成Object然后返回给JavaScript使用，可以将部分C++函数包装成Function给JavaScript调用。接下来通过一个简单例子来探索传递对象和函数的做法。在这个例子中，C++模块向JavaScript提供了getPerson()和getFunction()两个方法，getPerson()方法会返回一个Object给JavaScript，在JavaScript中调用此方法获得对象后可以直接使用该对象，访问对象属性获取信息（信息包括firstname和lastname）。getFunction()方法会将一个C++函数sayHiTo()包装成一个JS函数，返回一个Function给JavaScript，在JavaScript中调用此方法获取函数对象后，可以直接对返回的函数进行调用。sayHiTo()是一个C++函数，接收参数为一个Object，返回一句打招呼的信息（”Hi, xxxx”）。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;node.h&gt;namespace ReturnObjectAndFuntionDemo &#123; using v8::Function; using v8::FunctionTemplate; using v8::FunctionCallbackInfo; using v8::Isolate; using v8::Object; using v8::String; using v8::Value; using v8::Local; void getPerson (const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); /* 创建对象 */ Local&lt;Object&gt; obj = Object::New(isolate); /* 设置对象属性，Set(key, value) */ obj-&gt;Set( String::NewFromUtf8(isolate, \"firstname\"), String::NewFromUtf8(isolate, \"Java\") ); obj-&gt;Set( String::NewFromUtf8(isolate, \"lastname\"), String::NewFromUtf8(isolate, \"Script\") ); /* 将对象返回给JavaScript */ args.GetReturnValue().Set(obj); &#125; void sayHiTo (const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); /* 提取通过参数传递的JS对象 */ Local&lt;Object&gt; person = Local&lt;Object&gt;::Cast(args[0]); /* 提取对象属性值并拼接字符串 */ Local&lt;String&gt; fullname = String::Concat( person-&gt;Get(String::NewFromUtf8(isolate, \"firstname\"))-&gt;ToString(), person-&gt;Get(String::NewFromUtf8(isolate, \"lastname\"))-&gt;ToString() ); /* 将结果返回给JavaScript */ args.GetReturnValue().Set(String::Concat( String::NewFromUtf8(isolate, \"Hi, \"), fullname )); &#125; void getFunction (const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); /* 利用函数模板构造一个JavaScript函数 */ Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(isolate, sayHiTo); Local&lt;Function&gt; fn = tpl-&gt;GetFunction(); fn-&gt;SetName(String::NewFromUtf8(isolate, \"sayHiTo\")); /* 将函数返回给JavaScript */ args.GetReturnValue().Set(fn); &#125; void init (Local&lt;Object&gt; exports) &#123; NODE_SET_METHOD(exports, \"getPerson\", getPerson); NODE_SET_METHOD(exports, \"getFunction\", getFunction); &#125; NODE_MODULE(NODE_GYP_MODULE_NAME, init)&#125;返回对象的做法比较简单，直接创建一个Object，然后通过Set()方法设置属性和属性值，把需要返回的信息进行包装，最后通过args.GetReturnValue().Set()方法便可以直接将包装好的对象返回给JavaScript。返回函数的做法也是类似，创建一个Function，然后通过args.GetReturnValue().Set()方法将函数返回给JavaScript。创建函数的时候，需要用到FunctionTemplate，首先根据要包装的C++函数（sayHiTo）创建函数模板，然后调用模板的GetFunction()方法便可获得一个函数句柄，设置完函数名后便可将其返回给JavaScript使用。这里需要注意，sayHiTo是一个C++函数，而且没有通过module.exports属性来提供给外部使用，而是通过返回函数的方式来给外部使用。sayHiTo()是一个C++函数，通过函数返回给JavaScript之后将被JavaScript调用，所以它在调用时也会收到参数const FunctionCallbackInfo&lt;Value&gt;&amp; args，跟之前通过module.exports暴露给JavaScript调用的方法一样，可以通过参数args来完成跟JavaScript的交互（参数传递、返回等）。完成以上代码后，给binding.gyp的targets数组增加以下元素，然后进行编译构建生成.node文件。1234&#123; \"target_name\": \"person\", \"sources\": [\"person.cc\"]&#125;完成编译构建之后就可以使用以下JavaScript代码进行实验，输出结果如图所示。12345678// return-object democonst Person = require('./build/Release/person')let someone = Person.getPerson()console.log('[ReturnObjectDemo] ' + someone.firstname + someone.lastname)// return-function demolet sayHiTo = Person.getFunction()console.log('[ReturnFunctionDemo] ' + sayHiTo(someone))五、小结通过几个例子，大概了解如何编写NodeJS C++插件，也学会了如何处理一些常用场景，例如函数传参、回调、异常处理等。总体感觉编写C++插件实现C++和JavaScript的互相调用并不困难。主要的难点还是对V8的一些概念以及它所提供的API不熟悉，V8提供的很多API可以让我们方便地实现C++和JavaScript的互相调用，但由于对V8 API不够熟悉，编写过程中还是需要不断地查阅NodeJS和V8的官方文档。","categories":[],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://hongchh.github.io/tags/NodeJS/"}]},{"title":"试玩NodeJS多进程","slug":"试玩NodeJS多进程","date":"2018-04-11T07:47:22.000Z","updated":"2018-04-16T03:36:22.553Z","comments":true,"path":"2018/试玩NodeJS多进程/","link":"","permalink":"https://hongchh.github.io/2018/试玩NodeJS多进程/","excerpt":"","text":"NodeJS的JavaScript运行在单个进程的单个线程上，一个JavaScript执行进程只能利用一个CPU核心，而如今大多数CPU均为多核CPU，为了充分利用CPU资源，Node提供了child_process和cluster模块来实现多进程以及进程管理。本文将根据Master-Worker模式，搭建一个简单的服务器集群来充分利用多核CPU资源，探索进程间通信、负载均衡、进程重启等知识。下图是Master-Worker模式，进程分为master进程和worker进程，master进程负责调度或管理worker进程，worker进程则负责具体的业务处理。在服务器层面，worker可以是一个服务进程，负责处理来自客户端的请求，多个worker便相当于多个服务器，从而构成一个服务器集群。master则是负责创建worker，将来自客户端的请求分配到各个服务器上去处理，并监控worker的运行状态以及进行管理等操作。本文将从child_process模块开始，熟悉该模块的基本用法。后面再继续进入cluster模块的学习。本文所用的代码示例可以从该仓库中找到–【multi-process】。一、child_process1.1、Hello worldchild_process模块提供了spawn()、exec()、execFile()、fork()这4个方法用于创建子进程，本文将使用fork()方法来创建子进程，fork()方法只需指定要执行的JavaScript文件模块，即可创建Node的子进程。下面是简单的HelloWorld示例，master进程根据CPU数量创建出相应数量的worker进程，worker进程中利用进程ID来标记自己。以下是master进程代码，文件名为master.js。12345678const childProcess = require('child_process')const cpuNum = require('os').cpus().lengthfor (let i = 0; i &lt; cpuNum; ++i) &#123; childProcess.fork('./worker.js')&#125;console.log('Master: Hello world.')以下是worker进程的代码，文件名为worker.js。1console.log('Worker-' + process.pid + ': Hello world.')执行node master.js，得到如下结果，master创建4个worker后输出HelloWorld信息，每个worker也分别输出自己的HelloWorld信息。1.2、父子进程间的通信创建worker之后，接下来实现master和worker之间的通信。Node父子进程之间可以通过on(&#39;message&#39;)和send()来实现通信，on(&#39;message&#39;)其实是监听message事件，当该进程收到其他进程发送的消息时，便会触发message事件。send()方法则是用于向其他进程发送信息。master进程中调用child_process的fork()方法后会得到一个子进程的实例，通过这个实例可以监听来自子进程的消息或者向子进程发送消息。worker进程则通过process对象接口监听来自父进程的消息或者向父进程发送消息。下面是简单示例，master创建worker之后，向worker发送信息，worker在收到master的信息后将信息输出，并回复master。master收到回复后输出信息。master.js12345678const childProcess = require('child_process')const worker = childProcess.fork('./worker.js')worker.send('Hello world.')worker.on('message', (msg) =&gt; &#123; console.log('[Master] Received message from worker: ' + msg)&#125;)worker.js1234process.on('message', (msg) =&gt; &#123; console.log('[Worker] Received message from master: ' + msg) process.send('Hi master.')&#125;)执行node master.js，结果如下，master和worker可以正常通信。1.3、Master分发请求给Worker处理进程通信时使用到的send()方法，除了发送普通的对象之外，还可以用于发送句柄。句柄是一种引用，可以用来标识资源，例如通过句柄可以标识一个socket对象、一个server对象等。利用句柄传递，可以实现请求的分发。master进程创建一个TCP服务器监听特定端口，收到客户端的请求后，会得到一个socket对象，通过这个socket对象可以跟客户端进行通信从而处理客户端的请求。master进程可以通过句柄传递将该socket对象发送给worker进程，让worker进程去处理请求。该模式的结构图如下，在master上还可以通过特定的算法实现负载均衡，将客户端的请求均衡地分发给worker去处理。下面是一个简单示例。master创建TCP服务器并监听8080端口，收到请求后将请求分发给worker处理。worker收到master发来的socket以后，通过socket对客户端进行响应。为方便看到请求的处理情况，worker给出的响应内容会说明该请求是被哪个worker处理。master.js12345678910111213141516171819202122232425const childProcess = require('child_process')const net = require('net')const cpuNum = require('os').cpus().length// 创建工作进程let workers = []let cur = 0for (let i = 0; i &lt; cpuNum; ++i) &#123; workers.push(childProcess.fork('./worker.js')) console.log('Create worker-' + workers[i].pid)&#125;// 创建TCP服务器const server = net.createServer()// 服务器收到请求后分发给工作进程去处理// 通过轮转方式实现工作进程的负载均衡server.on('connection', (socket) =&gt; &#123; workers[cur].send('socket', socket) cur = Number.parseInt((cur + 1) % cpuNum)&#125;)server.listen(8080, () =&gt; &#123; console.log('TCP server: 127.0.0.1:8080')&#125;)worker.js12345678process.on('message', (msg, socket) =&gt; &#123; if (msg === 'socket' &amp;&amp; socket) &#123; // 利用setTimeout模拟处理请求时的操作耗时 setTimeout(() =&gt; &#123; socket.end('Request handled by worker-' + process.pid) &#125;, 10) &#125;&#125;)为了访问TCP服务器进行实验，这里需要写一个简单的TCP客户端，代码如下。该客户端会创建10个TCP连接，得到服务器响应之后将响应的内容进行输出。tcp_client.js1234567891011const net = require('net')const maxConnectCount = 10for (let i = 0; i &lt; maxConnectCount; ++i) &#123; net.createConnection(&#123; port: 8080, host: '127.0.0.1' &#125;).on('data', (data) =&gt; &#123; console.log(data.toString()) &#125;)&#125;先执行node master.js启动服务器，然后执行node tcp_client.js启动客户端。得到的结果如下，10个请求被分发到不同服务器上进行处理，并且可以看到master中的轮转分发请求起到了作用，实现了简单的负载均衡。1.4、Worker监听同一个端口前面说过，sned()方法可以传递句柄，通过传递句柄，我们除了发送socket对象之外，还可以直接发送一个server对象。我们可以在master进程中创建一个TCP服务器，将服务器对象直接发送给worker进程，让worker去监听端口并处理请求。这样的话，master和worker进程都会监听相同端口，当客户端发起请求时，请求可能被master接收，也可能被worker接收。而master不负责处理业务，如果请求被master接收到，由于master上没有处理业务的逻辑，请求将无法得到处理。因此可以实现为如下图所示的模式，master将TCP服务器发送给worker使得所有worker监听同一个端口以后，master关闭对端口的监听。这样便只有worker在监听同一端口，请求将会都被worker进行处理，与master无关。这种模式下，多个进程监听相同端口，当网络请求到来时，会进行抢占式调度，只有一个进程会抢到连接然后进行服务。因此，可以确保每个请求都会被特定的worker处理，而不是一个请求同时被多个worker处理。但由于是抢占式的调度，不能够保证每个worker的负载均衡。可能由于处理不同业务时CPU和IO繁忙度的不同导致进程抢到的请求数量不同，形成负载不均衡的情况。下面是简单示例。master.js123456789101112131415161718192021222324const childProcess = require('child_process')const net = require('net')const cpuNum = require('os').cpus().length// 创建工作进程let workers = []let cur = 0for (let i = 0; i &lt; cpuNum; ++i) &#123; workers.push(childProcess.fork('./worker.js')) console.log('Create worker-' + workers[i].pid)&#125;// 创建TCP服务器const server = net.createServer()server.listen(8080, () =&gt; &#123; console.log('TCP server: 127.0.0.1:8080') // 监听端口后将服务器句柄发送给工作进程 for (let i = 0; i &lt; cpuNum; ++i) &#123; workers[i].send('server', server) &#125; // 关闭主线程服务器的端口监听 server.close()&#125;)worker.js12345678910process.on('message', (msg, server) =&gt; &#123; if (msg === 'server' &amp;&amp; server) &#123; server.on('connection', (socket) =&gt; &#123; // 利用setTimeout模拟处理请求时的操作耗时 setTimeout(() =&gt; &#123; socket.end('Request handled by worker-' + process.pid) &#125;, 10) &#125;) &#125;&#125;)继续使用之前的tcp_client来进行实验，先执行node master.js启动服务器，然后执行node tcp_client.js启动客户端。得到结果如下，请求可以被不同的worker进程处理，但由于worker进程是抢占式地为请求进行服务，所以不一定能实现每个worker的负载均衡。1.5、进程重启worker进程可能因为某些异常情况而退出，为了提高集群的稳定性，master进程需要监听子进程的存活状态，当子进程退出之后，master进程要及时重启新的子进程。在Node中，子进程退出时，会在父进程中触发exit事件。父进程只需通过监听该事件便可知道子进程是否退出，并在退出的时候做出相应的处理。下面是在之前的监听同一端口模式下，增加了进程重启功能。进程重启时，master进程需要重新传递server对象给新的worker进程，因此不能关闭master进程上的server，否则在进程重启时server被关闭，得到的句柄将为空，无法正常传递。master进程的server不关闭，会导致master进程也监听端口，会有部分请求被master进程接收，为了让着部分请求能够得到处理，可以在master进程添加处理业务的代码。由于master也参与了业务处理，业务处理进程的数量增加1个，所以worker进程可以少创建1个。这也就是下面简单示例中的做法。这种实现方式使得master即进行进程管理又参与了业务处理，若果要保持master只负责进程管理而不涉及业务处理，可以采取另外一种实现方式：master接收到请求后，按照前面1.3节的做法将请求转发给worker进行处理，这样master将继续只负责对worker进程的管理。master.js1234567891011121314151617181920212223242526272829303132333435363738394041const childProcess = require('child_process')const net = require('net')const cpuNum = require('os').cpus().length - 1// 创建工作进程let workers = []let cur = 0for (let i = 0; i &lt; cpuNum; ++i) &#123; workers.push(childProcess.fork('./worker.js')) console.log('Create worker-' + workers[i].pid)&#125;// 创建TCP服务器const server = net.createServer()// 由于master进程也会监听端口。因此需要对请求做出处理server.on('connection', (socket) =&gt; &#123; // 利用setTimeout模拟处理请求时的操作耗时 setTimeout(() =&gt; &#123; socket.end('Request handled by master') &#125;, 10)&#125;)server.listen(8080, () =&gt; &#123; console.log('TCP server: 127.0.0.1:8080') // 监听端口后将服务器句柄发送给工作进程 for (let i = 0; i &lt; cpuNum; ++i) &#123; workers[i].send('server', server) // 工作进程退出后重启 workers[i].on('exit', ((i) =&gt; &#123; return () =&gt; &#123; console.log('Worker-' + workers[i].pid + ' exited') workers[i] = childProcess.fork('./worker.js') console.log('Create worker-' + workers[i].pid) workers[i].send('server', server) &#125; &#125;)(i)) &#125; // 关闭主线程服务器的端口监听 // server.close()&#125;)worker.js12345678910process.on('message', (msg, server) =&gt; &#123; if (msg === 'server' &amp;&amp; server) &#123; server.on('connection', (socket) =&gt; &#123; // 利用setTimeout模拟处理请求时的操作耗时 setTimeout(() =&gt; &#123; socket.end('Request handled by worker-' + process.pid) &#125;, 10) &#125;) &#125;&#125;)执行node master.js启动服务器后，可以通过任务管理器直接杀掉进程来模拟进程异常退出。可以看到worker进程退出后，master能够发现并及时创建新的worker进程。任务管理器中的Node进程数量恢复原样。执行node tcp_client.js启动客户端，客户端发出的连接请求被处理的情况如下，同样地，由于监听同一端口，进程之间采取抢占式服务，不一定保障负载均衡。1.6、处理HTTP服务前面的示例所使用的是TCP服务器，如果要处理HTTP请求，需要使用HTTP服务器。而HTTP其实是基于TCP的，发送HTTP请求的时候同样也会发起TCP连接。只需要对前面的TCP服务器进行一点小改动便可以支持HTTP了。在进程中新增HTTP服务器，当TCP服务器收到请求时，把请求提交给HTTP服务器处理即可。下面是worker进程的改动示例。worker.js1234567891011121314151617const http = require('http')const httpServer = http.createServer((req, res) =&gt; &#123; // 利用setTimeout模拟处理请求时的操作耗时 setTimeout(() =&gt; &#123; res.writeHead(200, &#123; 'Content-Type': 'text/plain' &#125;) res.end('Request handled by worker-' + process.pid) &#125;, 10)&#125;)process.on('message', (msg, server) =&gt; &#123; if (msg === 'server' &amp;&amp; server) &#123; server.on('connection', (socket) =&gt; &#123; // 提交给HTTP服务器处理 httpServer.emit('connection', socket) &#125;) &#125;&#125;)二、cluster前面简单描述了使用child_process实现单机Node集群的做法，需要处理挺多的细节。Node提供了cluster模块，该模块提供了更完善的API，除了能够实现多进程充分利用CPU资源以外，还能够帮助我们更好地进行进程管理和处理进程的健壮性问题。下面是简单示例，if条件语句判断当前进程是master还是worker，master进程会执行if语句块包含的代码，而worker进程则执行else语句块包含的代码。master进程中，利用cluster模块创建了与CPU数量相应的worker进程，并通过监听cluster的online事件来判断worker的创建成功。在worker进程退出后，会触发master进程中cluster模块上的exit事件，通过监听该事件可以了解worker进程的退出情况并及时fork新的worker。最后，worker进程中只需创建服务器监听端口，对客户端请求做出处理即可。（这里设置相同端口8080之后，所有worker都将监听同一个端口）server.js12345678910111213141516171819202122232425262728const cluster = require('cluster')if (cluster.isMaster) &#123; const cpuNum = require('os').cpus().length for (let i = 0; i &lt; cpuNum; ++i) &#123; cluster.fork() &#125; // 创建进程完成后输出提示信息 cluster.on('online', (worker) =&gt; &#123; console.log('Create worker-' + worker.process.pid) &#125;) // 子进程退出后重启 cluster.on('exit', (worker, code, signal) =&gt; &#123; console.log('[Master] worker ' + worker.process.pid + ' died with code: ' + code + ', and signal: ' + signal) cluster.fork() &#125;)&#125; else &#123; const net = require('net') net.createServer().on('connection', (socket) =&gt; &#123; // 利用setTimeout模拟处理请求时的操作耗时 setTimeout(() =&gt; &#123; socket.end('Request handled by worker-' + process.pid) &#125;, 10) &#125;).listen(8080)&#125;执行node server.js启动服务器，继续按照之前的做法，利用任务管理器杀死进程，可以看到在进程被杀后master能够及时启动新的worker。继续运行tcp_client，可以看到服务器能够正常处理请求。三、小结利用child_process和cluster模块能够很好地实现Master-Worker模式多进程架构，实现单机服务器集群，充分利用了多核CPU资源。通过进程通信能够实现进程管理、重启以及负载均衡，从而提高集群的稳定性和健壮性。","categories":[],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://hongchh.github.io/tags/NodeJS/"}]},{"title":"MonkeyEye电影售票系统-性能优化总结","slug":"MonkeyEye电影售票系统-性能优化总结","date":"2017-06-09T07:43:09.000Z","updated":"2017-11-11T13:01:11.611Z","comments":true,"path":"2017/MonkeyEye电影售票系统-性能优化总结/","link":"","permalink":"https://hongchh.github.io/2017/MonkeyEye电影售票系统-性能优化总结/","excerpt":"","text":"案例来源：SYSU SE305 课程大作业。互联网售票软件是比较常见的软件系统。通常由多个零售系统和多个供给系统系统。 机票、酒店房间、电影票似乎是风马牛大相关的系统，但它们之间存在极其相似的业务模型。 以电影票为例，格瓦拉、蜘蛛网、腾讯等等都做类似的电影票分销、推广业务，但票是由各大院线排期提供的。 分销-院线-影院形成了一个完整的生态体系。 本课程以大家熟悉的订票为例，学习分析、设计、开发的方法。我所在的小组做的是一个叫做MonkeyEye的项目，实现一个简单的电影购票系统，并在项目完成过程中学习系统分析与设计，学习UML建模等技能。本系列文章将会以此项目为案例，总结整个项目的设计、建模与开发过程。前端项目地址：https://github.com/SYSUMonkeyEye/MonkeyEye-FE关于项目的介绍和技术要点请查看项目结构和技术要点。由于我在项目中主要负责前端开发，因此本文将会较多地讲解本项目中使用到的前端性能优化技巧，后面再简单涉及一些服务器部署方面的优化技巧。一、主要问题服务器带宽较小，库文件体积较大。还没做优化的时候，构建之后的产品文件里面，库文件vendor.js的大小大概有400+KB。加载这个文件的时延大概是3-4s。图片体积较大，数量较多。应用中有比较多电影海报图片，大小大概也是几百KB，由于服务器带宽很小，加载一张图片的时延也是需要几秒。应用没有计算性能方面的问题，另外我们也没有更高配置的服务器，所以优化方向主要朝着减小资源文件体积进行。二、前端优化1、按需引入webpack打包的时候会根据代码中import的内容，将相关文件打包到产品文件中。本项目使用的UI框架是vue-material，之前引入这个库的方式如下。这种方式会将整个vue-material库引进来，也就可以随意使用它里面的UI组件了，但这也造成了引入部分无用组件从而增加了产品文件的体积。查看官方文档后，发现这个库是支持按需引入的，因此，我们将代码改成只引入我们用到的组件，如下。引入完成之后还要再一个一个挂到Vue上面才能使用。完成按需引入之后，webpack打包就只会将import到的组件加到产品文件里面，最大的js文件vendor.js从400+KB减少到了376KB，css样式文件也减少了大概30KB。加载时延较少了一些。2、迁移至webpack 2项目一开始用到脚手架是基于webpack 1的，根据官方介绍，webpack 2优化算法，能够有效减少构建后的产品文件体积。因此，我们将项目迁移到webpack 2上去进行构建打包。最大的vendor.js从376KB减少到了299KB，其他js、css文件也有所减少。整体加载时延减少了1-2s。3、开启gzip我们使用了一个nodejs服务器app-server来提供网页服务，打开应用的时候从这个服务器上加载网页资源。在浏览器发起请求加载js/css等资源的时候，服务器不要给出原始的文件资源，而是做一个gzip压缩。做法如下，使用compression中间件即可实现gzip压缩，并且会自动帮你填充HTTP报文头部需要的字段，浏览器拿到响应报文之后就会去完成解压。gzip的效果非常明显。体积最大的vendor.js从299KB压缩到了80.8KB，其他文件的体积也压缩到了很小。加载时延直接降低到了100毫秒以内。4、H5缓存现在的加载速度已经非常快了，基本算是秒加载，但还可以继续优化，使用H5缓存。把应用的html/js/css缓存在前端，首次打开应用的时候会有100ms左右从服务器加载资源，但后面再次打开应用的时候便是直接从本地缓存读取，速度更快。先上一下效果图。现在时延降低到10毫秒以内，可以说是一打开应用就可以开始渲染呈现界面了，用户体验提升了很多。下面说说怎么实现。H5缓存需要在HTML标签里面引入一个manifest文件，manifest文件中写好要缓存的资源。manifest的写法也有一些简单的规则，这里不一一介绍。然后，配置服务器让服务器可以提供manifest这个文件即可。前端解析HTML之后发现标签里面有manifest文件，就会向服务器请求manifest文件，然后根据该文件的描述去缓存相关的资源。H5缓存到这里已经实现好了，很简单。不过仔细观察就会发现，有一个比较烦人的事情要处理。那就是这些静态资源文件名，webpack构建后的产品文件名会加上一串哈希码，使得每次构建的产品文件名都不同。这种机制可以避开缓存问题，使得新构建的产品文件能够及时更新到生产环境上去。如果不加这串哈希码，新旧产品文件都是同名，那么可能因为缓存导致生产环境中的代码没有及时更新。既然每次构建产品文件名的哈希码都会有所不同，那不就意味着manifest文件必须每次构建完成后都重新写一次。如果是人为自己去写就很烦了。所以，下面需要写一些代码让这个过程自动化。通过分析代码，发现在build/build.js中，webpack构建完成之后会有个回调函数，我们可以在这个回调函数里面做些手脚。构建完成之后产品文件会放到产品文件夹，我们只需要对产品文件夹做一次深度优先搜索（DFS），即可得到所有产品文件的路径和名称，然后把路径和名称写入到manifest文件即可，写入的时候顺便将manifest的版本设置为当前的时间戳，使得每次构建产生的manifest文件版本都有有更新。5、webp图片格式优化现在剩下图片问题了。首先可以修改一下图片格式，将图片从原来的jpg、png等格式转成体积更小的webp格式，一次请求的大小从原来的几百KB降低到了几十KB，少量比较大的图片会到140+KB，最小的可以到30KB左右。时延降低到了几十毫秒的级别，比较大的图片也只有500+毫秒。加载快了很多，主界面很快就可以渲染出来。6、图片懒加载由于主界面图片较多，一次性把全部图片加载出来的做法很不好。可以做成懒加载，当图片出现在屏幕可视区域之后才加载图片。做法就是在img元素进入到可视区域的时候，才设置它的src属性，src属性设置之后才会开始向服务器请求响应的图片。自定义一个directive给img元素使用，在directive里面通过监听屏幕滚动判断元素是否进入了可视区域，进入可视区域之后再设置相应img元素的src属性。此部分代码由我另一位组员实现，我不保证能完全讲清楚，所以这里我不做过多阐述，感兴趣可以查看本项目代码里面的/src/common/utils/LazyLoad.js。1img(v-lazyload=&quot;movie.poster&quot;)三、部署优化项目使用了Python服务器作为API服务器和图片服务器，搭配MySQL数据库。使用NodeJS服务器作为网页服务器，然后利用Nginx做负载均衡，做了些简单的分布式部署，用了4台云主机。部署图如下所示。python服务器使用的数据都是来自同一个数据库，如果服务器数量支持的话，MySQL也可以做分布式部署。然后由于部署了多台API服务器，当请求被转发到不同服务器上时会出现session丢失的尴尬情况，所以这里用了一个Redis数据库来实现共享session。网页服务器单独用nodeJS部署而没有跟静态资源服务器合并在一起，主要是方便前端可以及时更新代码，以及做一些像H5缓存之类的东西，毕竟这些内容前端会比较熟，nodeJS也比较熟。最后静态资源服务器只部署了1台，首先是服务器数量不够，其次是静态资源服务器的计算量很少，只是简单地提供文件服务，所以就没有部署多个节点。Nginx会根据请求的地址将API请求、网页资源请求和静态图片请求转发到后面响应类型的节点，并且会做负载均衡。虽然本项目只是一个简单的课程大作业，但还是尽量尝试我们力所能及的优化，多把握一些实践机会。也许还有很多缺陷，欢迎讨论。","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://hongchh.github.io/tags/Web/"}]},{"title":"MonkeyEye电影售票系统-前端技术要点总结","slug":"MonkeyEye电影售票系统-前端技术要点总结","date":"2017-06-09T05:30:02.000Z","updated":"2017-11-11T11:59:58.174Z","comments":true,"path":"2017/MonkeyEye电影售票系统-前端技术要点总结/","link":"","permalink":"https://hongchh.github.io/2017/MonkeyEye电影售票系统-前端技术要点总结/","excerpt":"","text":"案例来源：SYSU SE305 课程大作业。互联网售票软件是比较常见的软件系统。通常由多个零售系统和多个供给系统系统。 机票、酒店房间、电影票似乎是风马牛大相关的系统，但它们之间存在极其相似的业务模型。 以电影票为例，格瓦拉、蜘蛛网、腾讯等等都做类似的电影票分销、推广业务，但票是由各大院线排期提供的。 分销-院线-影院形成了一个完整的生态体系。 本课程以大家熟悉的订票为例，学习分析、设计、开发的方法。我所在的小组做的是一个叫做MonkeyEye的项目，实现一个简单的电影购票系统，并在项目完成过程中学习系统分析与设计，学习UML建模等技能。本系列文章将会以此项目为案例，总结整个项目的设计、建模与开发过程。前端项目地址：https://github.com/SYSUMonkeyEye/MonkeyEye-FE关于项目的功能和项目结构的介绍请查看上一篇博客。【前端技术框架】vuevue-routervuexvue-materialaxios【构建工具】webpack一、预编译语言(预处理语言)项目中使用pug预处理语言来编写前端的HTML，非常简洁和方便。用pug来编写HTML结构，编写完后经过处理器处理之后会变成标准的HTML，代码上少了很多闭合标签显得更加简洁，而且结构也很清晰。类名和id的写法或者其他HTML标签属性的写法也很简洁。至于编写样式的CSS，则是使用了sass。缩进嵌套选择器，不用打花括号等特性用起来都特别爽。pug和sass支持的功能还有很多，例如pug的mixin，sass的模块化样式等等，此处不作介绍，官方文档已经有了详细的描述。二、Vue 组件化Vue支持前端组件化，可以将前端界面或者界面中的某些模块划分为组件，每个组件可以使用一个Vue文件来实现，也可以将代码分散在html/css/js文件中。我们这里都是采取Vue文件的方式，每个Vue文件实现一个组件。Vue文件通过template、script、style三种标签将HTML、js、css三种类型的代码进行划分，三种放在同一个文件里，根据组件定位到代码，很方便进行代码管理。通过在标签中指定lang属性，可以指定预编译语言。项目将每个界面抽象为一个Vue组件来进行开发和管理，虽然每个界面上可以根据界面内容继续细分组件，例如顶栏组件、表单组件、标签页组件。但是由于本应用的界面并不是非常复杂，而且每个页面的业务逻辑都是连贯的，我们认为一个组件包含一个界面这种把握刚刚好，一个界面组件的HTML结构、js逻辑和css样式全部代码加起来一般在100到200+行之间，加上有template、script、style三个标签进一步将代码分块，每一个Vue文件里面的每一大块代码(html/js/css)的代码量基本都在100行以内，可读性还是很强的，很有利于进行开发和维护。三、前端路由由于本应用是一个单页应用，所以需要配置前端的路由。利用vue-router库来实现前端路由控制。下面是部分代码截图，主要配置URL路径和与之绑定的组件，当浏览器地址栏中的路由变成相应的路径时候，就跟渲染与之绑定的组件，然后更新界面内容。由于部分界面需要权限才能进入，例如，需要登录后才能查看和修改用户信息、需要登录后才能下单购票。这里可以利用vue-router提供的钩子(hook)进行权限控制，实现方式如下。首先在配置路由的时候，给需要权限的界面加一个meta字段，即元数据，里面的requireAuth设置为true，表示这个界面需要权限才能进入（这里的权限指的是已登录用户才具备的权限）。vue-router提供了一个beforeEach钩子，如果给这个钩子绑定一个处理函数，那么在进入任何一个路由之前，都会先调用这个钩子所绑定的处理函数。在处理函数中，参数to表示要进入的路由，通过检查要进入的路由的元数据便可以知道该路由是否需要权限。如果需要权限则检查store里面的用户状态（后面将介绍store，用户的登录状态会保存在store中）。如果用户未登录则将它重定向到登录界面。四、异步通信前端界面经常需要跟服务器进行通信，发送GET、POST等HTTP请求获取数据或者提交数据。为了提高用户体验，不阻塞页面流程，一般都是采取ajax方式来异步发送请求。本项目使用了axios这个库来发送HTTP请求。如官方文档介绍，“Promise based HTTP client for the browser and node.js”，这个库有一个很大的优点，基于Promise。其次，他还封装好了多种HTTP方法，直接通过get、post、delete等API即可发送一个对应HTTP方法的请求。promise的写法使得代码可以通过.then和.catch的方式来处理异步请求得到的结果或者处理异常，相对于嵌套回调函数的方式，代码更加简洁优雅。五、数据状态管理应用的数据状态管理使用的是vuex这个库。下面先简单总结一下vuex的思想。Vue使用Vuex实现状态管理，从概念上来看Vuex遵从Flux，即将应用的数据视为状态，放在一个全局的store里面进行管理，所有组件共享同一个store的数据，组件无法直接对数据进行修改，要更新store里面的数据需要发起一个action才能对store里面的数据进行更新，当store里面的数据更新之后会反馈所有使用到store里面的数据的组件，使得其他组件也进行更新。Vuex基本按照Flux的概念来，唯一不同之处就是Vuex除了action之外还有mutation。mutation对store里面的数据进行同步更新，所有操作都必须是同步的。当需要异步操作的时候就才会用到action，在action里面进行异步操作之后再通过mutation来对store里面的数据进行更新。使用vuex可以更好地管理应用的数据和接口，下面以电影数据为例子进行说明。电影的数据包括正在热映和即将上映的电影列表以及对应的推荐列表，将这些数据存放在store的state里面，电影列表界面和电影详情界面都会共享这一份数据，这份数据改变的时候，两个界面的内容都会更新。除了数据是存在全局的单例可以节省内存之外，界面的更新同步也变得非常容易。下面则是电影模块的actions部分，可以将所有与服务端API通信的异步操作接口封装在这里，接口不会分散在各个界面的代码中，非常方便我们对接口进行管理和调整。最后则是mutations，这里面封装了对数据进行同步修改的代码，在派发action获取数据之后，如果需要对数据进行分类，例如获取全部电影列表然后分成正在热映和即将上映两类，都可以将相应的代码封装在这里。六、数据状态模块化vuex数据状态管理，可以理解为是把整个应用的数据抽象出来，形成一棵状态树。这棵状态树位于一个全局的位置并且是单例的，所有界面都引用这棵树上的某一部分的数据。但是，当应用界面较多，数据模型变得复杂的时候，这棵状态树也会变得很庞大。如果将所有代码都放在一个位置，那么将很不利于代码的管理。所以，可以根据数据模型来对这棵树进行划分，变成多棵子树，每棵子树代表一个数据模型，并且将对应的API接口和操作封装到一起。这就是vuex的modules。我们根据应用的数据模型将数据分为以下几个module，然后在顶层将所有module组装起来形成完整的数据状态树。每个module里面都有相应的state、mutations、actions，将各模块的数据变量、接口等都封装到一起。这样每个module的代码都是完整的，管理起来很方便。并且每个module的代码量都很小，可读性可维护性大大提高。七、HTTP代理与前后端分离这个项目是一个前端开发项目，因此没有服务端的代码。前端的代码和服务端的代码运行在不同的位置。例如，开发的时候，服务端可能运行在服务器上，而前端的代码是跑一个本地静态服务器(dev-server)来提供。静态服务器只能提供HTML/JS/CSS/图片等资源给浏览器使用，但是应用中还有不少地方需要访问服务器的API接口，这里可以通过HTTP代理来实现。前端发送/api请求到dev-server，通过配置HTTP代理，dev-server将这个/api请求代理到真正的API服务端，等拿到数据后再给回前端。这样，除了可以解决访问API的问题，还可以让我们不用去处理跨域的问题，非常方便。HTTP代理使用http-proxy-middleware中间件来实现，dev-server中的代码已经写好，只需要在config中配置一下代理规则即可。写好真正的API服务器和静态资源服务器的地址，然后在代理规则表中写好代理规则。例如下面图中的/api，表示所有/api开头的请求都会被代理到apiServer。这时候在应用里面请求localhost:8080/api/movies的效果就跟请求[apiServer]/api/movies的效果时一样的。dev-server在这里充当了代理的角色，前端并不知道代理的存在，响应报文里面的服务器主机依然是localhost，所以也不会造成前端的跨域问题。有了代理之后，前后端分离的实践也变得容易起来。后端和前端可以分离开发，也不用管对方写了什么代码，甚至不需要运行对方的代码。后端把代码写好部署好接口，前端只要知道服务器地址即可。前后端之间的交互通过RESTful API。","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://hongchh.github.io/tags/Web/"}]},{"title":"MonkeyEye电影售票系统-前端项目结构和协作规范","slug":"MonkeyEye电影售票系统-前端项目结构和协作规范","date":"2017-06-09T02:45:50.000Z","updated":"2017-11-11T11:36:34.835Z","comments":true,"path":"2017/MonkeyEye电影售票系统-前端项目结构和协作规范/","link":"","permalink":"https://hongchh.github.io/2017/MonkeyEye电影售票系统-前端项目结构和协作规范/","excerpt":"","text":"案例来源：SYSU SE305 课程大作业。互联网售票软件是比较常见的软件系统。通常由多个零售系统和多个供给系统系统。 机票、酒店房间、电影票似乎是风马牛大相关的系统，但它们之间存在极其相似的业务模型。 以电影票为例，格瓦拉、蜘蛛网、腾讯等等都做类似的电影票分销、推广业务，但票是由各大院线排期提供的。 分销-院线-影院形成了一个完整的生态体系。 本课程以大家熟悉的订票为例，学习分析、设计、开发的方法。我所在的小组做的是一个叫做MonkeyEye的项目，实现一个简单的电影购票系统，并在项目完成过程中学习系统分析与设计，学习UML建模等技能。本系列文章将会以此项目为案例，总结整个项目的设计、建模与开发过程。前端项目地址：https://github.com/SYSUMonkeyEye/MonkeyEye-FE一、基本功能电影资讯购票用户信息收藏评论用户使用该可以实现查看和搜索正在热映和即将上映的电影资讯，对感兴趣的电影可以进行收藏。想要观看某部电影，可以进行下单购票操作。对于已经放映的电影订单，用户可以对该订单对应的电影进行评分评价的操作。另外，用户还可以更新自己的个人信息。下面是整个应用的界面逻辑概要图，方便对应用有个直观的理解。二、项目结构1、顶层结构整个项目最顶层的包（文件夹）主要有以下4个。build：运行提供开发环境和构建项目的代码config：项目的webpack打包配置、http代理配置src：项目的源代码，主要都在src里面进行开发dist：项目构建后的产品文件无论是开发或者构建，都需要依赖到config里面的配置和src里面的源码。本项目使用webpack进行打包，build里面的代码会根据config的配置来调整webpack的打包规则，例如是否开启gzip、构建产品目标路径、HTTP代理规则等。调整好配置之后会将src里面的源码进行打包，如果是构建的话，由于config里面进行了设置，最终的产品文件都会存放到dist里面。2、src目录结构src里面主要分为components、common、assets、router和store这5个模块。本应用是一个前端单页应用，所以界面渲染、路由控制等操作都是在前端完成。每个页面抽象为一个组件，当然，界面中也可以包含它的子组件。这样，我们可以通过组件来定位每个界面的代码，方便管理。整个应用的数据都抽象到位于全局位置的store进行管理，实现界面和数据的分离，并且应用单向数据流的思想（后面介绍）。components：所有界面组件common：公共样式、组件或者工具函数assets：图标、图片等静态资源router：前端路由store：应用数据状态界面会引用到common里面的样式或工具，也可能引用assets的资源，例如引用某个图标。界面的路由配置和跳转控制需依赖router，而应用数据则是存储在store之中，因此也需要依赖到store。3、细分目录结构根据设计图确定下来的应用界面，根据业务逻辑关联性大致可以分为6个部分，即前面【一】中展示的界面关系图中用红色框框起来的6个部分。电影资讯界面和个人中心界面分为同个部分的主要原因是它们作为进入应用之后的两个依赖tab切换的主界面，从代码上还是有所关联的，将它们的代码划分在同一个包中比较方便管理。公共包common的内容主要有公用的样式和工具函数，所以需要有css、sass、utils这几个包。assets由于目前只有少量静态图片资源，其他资源多数是从服务器动态加载，所以这里只需要一个images包。router里面已经不需要继续细分了，直接对前端路由规则进行配置即可。store里面可以根据数据继续划分为模块，每个模块对应一个js文件，存放在module包中，例如可以划分为电影模块、评论模块、订单模块等等。4、项目详细结构描述最后，结合各种入口文件和项目的技术框架需要的文件，可以确定项目需要的文件结构如下所示（具体到每个文件的详细描述）。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758├─build：存放构建用到的相关文件├─config：存放配置文件├─data：存放伪数据以及数据生成器供前端开发使用；也可以存放图片等静态资源├─src：前端开发的源码│ ├─assets：图片等静态资源│ ├─common：公共样式或js文件│ │ ├─css：字体和图标文件│ │ │ ├─font.css：字体文件│ │ │ └─icon.css：图标文件│ │ ├─sass：公共样式文件│ │ └─utils：公共工具函数库│ │ ├─DateUtils.js：处理时间日期的工具函数│ │ ├─Form.js：表单工具函数│ │ └─LazyLoad.js：实现图片懒加载│ ├─components：前端组件│ │ ├─auth：登录注册相关界面│ │ │ ├─Load.vue：加载控件│ │ │ ├─Signin.vue：登录界面│ │ │ └─Signup.vue：注册界面│ │ ├─comment：电影评论评分相关界面│ │ │ └─MovieComment.vue：对电影进行评论评分界面│ │ ├─main：应用的主体界面│ │ │ ├─Main.vue：主体界面外层容器│ │ │ ├─Me.vue：个人中心界面│ │ │ └─Movies.vue：电影资讯界面│ │ ├─movie：电影相关界面│ │ │ ├─MovieDetail.vue：电影详情界面│ │ │ └─MovieSearch.vue：电影搜索界面│ │ ├─order：订单相关界面与组件│ │ │ ├─MyOrders.vue：全部/待付款/待放映/已放映订单列表界面│ │ │ ├─OrderDetail.vue：订单详情界面│ │ │ ├─OrderPay.vue：付款界面│ │ │ ├─PasswordInput.vue：支付密码输入控件│ │ │ ├─Reservation.vue：确认下单界面│ │ │ ├─SelectCoupon.vue：选优惠券界面│ │ │ ├─SelectScreen.vue：选场次界面│ │ │ └─SelectSeat.vue：选座位界面│ │ └─profile：用户中心相关界面│ │ ├─ChangeInfo.vue：修改个人信息界面│ │ ├─Coupon.vue：优惠券组件│ │ ├─Coupons.vue：优惠券列表界面│ │ ├─MovieCollection.vue：收藏/想看/已看电影列表界面│ │ └─UserInfo.vue：用户个人信息界面│ ├─router：前端路由│ │ └─index.js：前端路由信息配置文件│ ├─store：应用的全局数据状态管理│ │ ├─modules：数据状态模块│ │ │ ├─auth.js：登录注册相关接口与数据状态│ │ │ ├─comment.js：电影评价相关接口与数据状态│ │ │ ├─coupon.js：优惠券相关接口与数据状态│ │ │ ├─favorite.js：电影收藏相关接口与数据状态│ │ │ ├─movies.js：电影相关接口与数据状态│ │ │ ├─order.js：订单相关接口与数据状态│ │ │ └─screen.js：场次相关接口与数据状态│ │ └─index.js：数据状态模块配置文件│ ├─App.vue：应用的最外层结构│ └─entry.js：应用的入口文件；第三方组件和公共文件在此引入└─app-server.js：应用服务器，提供构建后的前端静态资源，并进行接口代理三、协作规范该项目使用git和GitHub进行协作开发和代码管理，GitHub上的代码仓库由我进行管理，其他成员需要fork项目然后通过在GitHub发起pull request的方式提交他们的代码。本仓库有2个分支，master和dev。主要在dev分支上进行开发和测试，功能完善之后再合并到master。GitHub上的代码量和提交次数统计只会统计master分支上的提交，所以有时候可能因为要统计成员活跃度的关系也需要合并一下dev的内容到master分支。12├─master└─dev首先需要在github上fork本仓库到他们自己的github，将fork之后的远程仓库克隆到本地，并在本地仓库上添加上游仓库，即源仓库。fork一般是fork了仓库的master分支，所以可能还需要自己去切出dev分支然后拉取源仓库dev分支上的内容。123456git clone https://github.com/&#123;你的github&#125;/MonkeyEye-FE# 上游的源仓库地址只需添加一次git remote add upstream https://github.com/SYSUMonkeyEye/MonkeyEye-FE# 切出dev分支并拉取源仓库dev分支上的内容git checkout -b devgit pull upstream dev完成之后便有了以下两种方式可以进行协作开发贡献代码。方式一要开发某个模块某个功能的时候，在你的本地仓库创建一个分支，例如mydev。1git checkout -b mydev切换之后你的本地仓库上就有3个分支了，如下所示。checkout之后会自动切换到mydev分支。123├─master├─dev└─mydev在mydev分支上进行开发和测试，完成相应的功能或者模块，完成之后再切回到dev分支将mydev的内容合并到dev。12345# mydev分支上提交你的更新git add *git commit -m \"add something\"# 切换到dev分支git checkout dev由于在你开发过程中，我也可能在开发并且更新了仓库，为了避免冲突，在合并分支之前你还需要更新你本地仓库的dev分支。先在本地仓库上添加上游仓库upstream，上游仓库即我的仓库，然后使用pull命令从上游仓库拉取更新。12# 拉取上游的源仓库dev分支上的更新git pull upstream dev更新完dev之后，将mydev分支合并到dev分支并提交到你自己的远程仓库。完成之后，mydev分支就可以删除了，你也可以继续留着。123456# 将mydev分支合并到dev，可能会有冲突需要自行解决git merge mydev# 推送到你自己的远程仓库，注意这里是push到origin dev，不是upstream devgit push origin dev# 删除mydev分支git branch -d mydev推送到自己的远程仓库后，就可以到Github上面给我发Pull Request了，然后等待我合并你的代码。方式二方式二相对更简单一些，不用多次切换分支。可以直接在fork之后的的dev分支上面进行开发，然后在发送PR之前先从源仓库拉取更新。1234567# 提交你的代码git add *git commit -m \"add something\"# 拉取上游的源仓库dev分支上的更新，可能会有冲突需要自行解决git pull upstream dev# 推送到你自己的远程仓库，注意这里是push到origin dev，不是upstream devgit push origin dev","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://hongchh.github.io/tags/Web/"}]},{"title":"axios-cookie问题和表单上传问题探究","slug":"axios-cookie问题和表单上传问题探究","date":"2017-05-24T06:02:11.000Z","updated":"2017-11-11T11:18:14.654Z","comments":true,"path":"2017/axios-cookie问题和表单上传问题探究/","link":"","permalink":"https://hongchh.github.io/2017/axios-cookie问题和表单上传问题探究/","excerpt":"","text":"自从入了 Vue 之后，一直在用 axios 这个库来做一些异步请求。最近在跨域、cookie 以及表单上传这几个方面遇到了点小问题，做个简单探究和总结。本文将涉及使用 axios 在跨域情况下成功得到响应报文中的内容以及让 cookie 成功设置的解决办法；使用 axios 上传表单数据时候遇到的小问题。一、同域 cookie 问题首先来看一个同域情况下的cookie例子清楚整个流程以便后面对跨域情况能够更好地阐述。服务端的代码如下，访问/get-cookie接口的时候，通过session随便设置字段time，使得响应报文中带有set-cookie字段，在浏览器段设置cookie，这个cookie的内容即相应的sessionId。然后访问/test-cookie可以判断浏览器端的 cookie是否设置成功，如果设置成功，那么浏览器发送的报文会自动带上cookie字段，服务器也就可以根据cookie找到对应的session。如果设置失败，那么浏览器发送的报文不会带上cookie字段，服务器也就无法找到对应的session，从而返回error。1234567891011121314151617181920212223242526272829303132333435const express = require('express')const path = require('path')const cookieParser = require('cookie-parser')const session = require('express-session')const FileStore = require('session-file-store')(session)let app = express()app.use('/static', express.static(path.join(__dirname, './static')))app.use(cookieParser())app.use(session(&#123; store: new FileStore(), secret: 'hongchh', resave: false, saveUninitialized: false&#125;))app.use('/get-cookie', (req, res) =&gt; &#123; req.session.time = Date.now() res.json(&#123; result: 'ok' &#125;)&#125;)app.use('/test-cookie', (req, res) =&gt; &#123; if (req.session.time) &#123; console.log('session.time: ' + req.session.time) console.log(req.cookies) res.json(&#123; result: 'ok' &#125;) &#125; else &#123; res.json(&#123; result: 'error' &#125;) &#125;&#125;)app.listen(8000)console.log('http://localhost:8000/static/index.html')前端的代码如下，前端只有两个按钮，触发点击事件分别可以调用两个接口。1234567891011121314151617181920212223242526272829window.onload = function () &#123; 'usr strict' document.getElementById('get-cookie').addEventListener('click', getCookie, false) document.getElementById('test-cookie').addEventListener('click', testCookie, false) var getResult = document.getElementById('get-result') var testResult = document.getElementById('test-result') function getCookie() &#123; axios.get('/get-cookie').then(function (res) &#123; if (res.status === 200) &#123; getResult.textContent = res.data.result &#125; else &#123; getResult.textContent = 'ERROR' &#125; &#125;) &#125; function testCookie() &#123; axios.get('/test-cookie').then(function (res) &#123; if (res.status === 200) &#123; testResult.textContent = res.data.result &#125; else &#123; testResult.textContent = 'ERROR' &#125; &#125;) &#125;&#125;首先点击get-cookie按钮，再点击test-cookie按钮，发送的报文信息如下，可以看到，get-cookie的响应报文中有set-cookie字段，而test-cookie的请求报文中自动带上了cookie字段。通过 Chrome 的开发者工具也可以看到设置cookie成功。服务端也输出了相应的session和cookie的信息。二、跨域 cookie 问题为了实现跨域，将服务器拆分成2个服务器，1个提供静态资源，1个提供接口。访问8002端口的服务器加载前端的界面，然后跨域访问8001端口的服务器调用get-cookie和test-cookie接口。为了满足跨域，8001服务器的响应报文里面应该有Access-Control-Allow-Origin字段，字段值设置为&#39;*&#39;表示满足所有其他域的访问。1234567891011121314151617181920212223242526272829303132333435const express = require('express')const cookieParser = require('cookie-parser')const session = require('express-session')const FileStore = require('session-file-store')(session)let app = express()app.use(cookieParser())app.use(session(&#123; store: new FileStore(), secret: 'hongchh', resave: false, saveUninitialized: false&#125;))app.use('/get-cookie', (req, res) =&gt; &#123; req.session.time = Date.now() res.header('Access-Control-Allow-Origin', '*') res.json(&#123; result: 'ok' &#125;)&#125;)app.use('/test-cookie', (req, res) =&gt; &#123; res.header('Access-Control-Allow-Origin', '*') if (req.session.time) &#123; console.log('session.time: ' + req.session.time) console.log(req.cookies) res.json(&#123; result: 'ok' &#125;) &#125; else &#123; res.json(&#123; result: 'error' &#125;) &#125;&#125;)app.listen(8001)console.log('http://localhost:8001/')123456789const express = require('express')const path = require('path')let app = express()app.use('/static', express.static(path.join(__dirname, './static')))app.listen(8002)console.log('http://localhost:8002/')前端只需要小做修改，将调用接口的 URL 改为绝对地址。下面是get-cookie的写法，test-cookie也类似。123456789function getCookie() &#123; axios.get('http://localhost:8001/get-cookie').then(function (res) &#123; if (res.status === 200) &#123; getResult.textContent = res.data.result &#125; else &#123; getResult.textContent = 'ERROR' &#125; &#125;)&#125;同样地，先get-cookie，然后test-cookie，得到的结果如下。访问没有出错，但是也没有成功设置cookie。可以看到get-cookie的响应报文里面是有set-cookie字段的，但是test-cookie的请求报文并没有带上cookie字段。通过 Chrome 的开发者工具也可以看到cookie没有设置成功。查看axios的文档之后，发现需要配置withCredentials属性，在全局配置axios的withCredentials属性为true。1axios.defaults.withCredentials = true配置完成之后再进行测试，得到的结果如下。确实成功设置了cookie，test-cookie的请求报文会自动带上cookie。但是前端除了成功设置cookie之外，还会报错，而且无法读取到响应报文的主体部分的内容。根据错误提示，应该是说不能直接将Access-Control-Allow-Origin字段的值设置为&#39;*&#39;。因此，我们直接将其值修改为确定的域名试试。对get-cookie和test-cookie作如下修改。12345678910111213141516app.use('/get-cookie', (req, res) =&gt; &#123; req.session.time = Date.now() res.header('Access-Control-Allow-Origin', 'http://localhost:8002') res.json(&#123; result: 'ok' &#125;)&#125;)app.use('/test-cookie', (req, res) =&gt; &#123; res.header('Access-Control-Allow-Origin', 'http://localhost:8002') if (req.session.time) &#123; console.log('session.time: ' + req.session.time) console.log(req.cookies) res.json(&#123; result: 'ok' &#125;) &#125; else &#123; res.json(&#123; result: 'error' &#125;) &#125;&#125;)继续进行测试，得到的结果跟之前相似，成功设置了cookie，但却无法获取响应报文的主体部分的内容，并且继续报错了。其他内容相似这里不重复截图。只有这个报错的信息是不同的，如下图所示。看样子修改为确定的域名成功解决了之前那个问题，接下来需要解决这新的问题。根据报错提示，是说除了Access-Control-Allow-Origin字段之外，我们还需要设置Access-Control-Allow-Credentials的值为true。根据提示对服务端代码进行修改，如下所示。123456789101112131415161718app.use('/get-cookie', (req, res) =&gt; &#123; req.session.time = Date.now() res.header('Access-Control-Allow-Origin', 'http://localhost:8002') res.header('Access-Control-Allow-Credentials', 'true') res.json(&#123; result: 'ok' &#125;)&#125;)app.use('/test-cookie', (req, res) =&gt; &#123; res.header('Access-Control-Allow-Origin', 'http://localhost:8002') res.header('Access-Control-Allow-Credentials', 'true') if (req.session.time) &#123; console.log('session.time: ' + req.session.time) console.log(req.cookies) res.json(&#123; result: 'ok' &#125;) &#125; else &#123; res.json(&#123; result: 'error' &#125;) &#125;&#125;)继续进行测试，得到结果如下。这次除了可以正确设置cookie之外，也可以读取到响应报文的主体部分的内容，并且没有任何报错。因此，可以得到结论，在跨域的情况下使用axios，首先需要配置axios的withCredentials属性为true。然后服务器还需要配置响应报文头部的 Access-Control-Allow-Origin和Access-Control-Allow-Credentials两个字段，Access-Control-Allow-Origin字段的值需要为确定的域名，而不能直接用&#39;*&#39;代替，Access-Control-Allow-Credentials的值需要设置为true。前端和服务端两边都配置完善之后就可以正常进行跨域访问以及携带cookie信息了。三、表单上传问题之前在使用axios上传表单数据的过程中，我通常像下面会这么做。12345678910var formData = &#123; key1: 'value1', key2: 'value2', key3: 'value3'&#125;axios.post('/upload', formData).then(function (res) &#123; if (res.status === 200) &#123; // do something &#125;&#125;)上面这种做法在NodeJS express服务端使用body-parser可以正确解析到请求报文里面body部分的数据，也就是我提交的表单数据，所以这样玩了很久也没有出现过什么问题。直到最近在课程作业中跟1个Python flask后台的同学协作过程中才开始踩到坑。用上面那种方式提交的数据，在他的后台程序里面提取不到表单数据。他的后台通过 req.form的方式获取表单数据，跟express的req.body好像有那么一点不同。于是我猜想express的body-parser中间件是把报文的主体部分的数据都提取了出来，而他的req.form只会提取标准的表单数据。通过修改axios post的数据也可以验证猜想。代码修改如下，使用 js 提供的FormData来包装需要提交的表单数据。最后服务器也成功收到了前端上传的数据。123456789var formData = new FormData()formData.append('key1', 'value1')formData.append('key2', 'value2')formData.append('key3', 'value3')axios.post('/upload', formData).then(function (res) &#123; if (res.status === 200) &#123; // do something &#125;&#125;)这时候大概可以简单理解一下两者区别，第一种方式是 post 了一个 js 对象，会被变成json 字符串的形式提交。而第二种则是提交了一个FormData对象，标准的表单数据对象。因此，如果在 Java、PHP 等其他后台遇到类似的问题时，也可以考虑尝试用FormData对象来解决。","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://hongchh.github.io/tags/Web/"}]},{"title":"Ajax文件上传","slug":"Ajax文件上传","date":"2017-03-30T14:11:23.000Z","updated":"2018-03-16T09:23:46.603Z","comments":true,"path":"2017/Ajax文件上传/","link":"","permalink":"https://hongchh.github.io/2017/Ajax文件上传/","excerpt":"","text":"为了避免在实现简单的异步文件上传功能时候引入一个第三方库文件的尴尬情形（库文件可能造成多余的开销，拉低应用加载速度，尤其是在引入库文件之后仅使用其中一两个功能的情况下，性价比极低），最近了解了一下文件异步上传的实现原理，顺带看了看进度条、图片预览等功能的实现，做一点简单的整理。本文所用的代码示例可以从github仓库 file-upload-demo 中找到。文件上传HTML结构如下，一个file input和一个button。当点击“上传”按钮的时候，将file input选中的文件上传到服务器。12&lt;input type=\"file\" name=\"file\" id=\"file\" /&gt;&lt;button id=\"upload\"&gt;上传&lt;/button&gt;以下是“上传”按钮的点击事件处理器，点击按钮之后通过一个XMLHttpRequest对象来实现发送异步请求。上传的内容为文件，因此还需要用到FormData对象，FormData可以js里面创建表单对象，将file input的文件append到FormData对象中，最后调用XHR对象的send()方法将表单数据发送出去即可。12345678910111213141516171819var file = document.querySelector('#file');var upload = document.querySelector('#upload');var xhr = new XMLHttpRequest();// 点击上传function uploadFile(event) &#123; var formData = new FormData(); formData.append('test-upload', file.files[0]); xhr.onload = uploadSuccess; xhr.open('post', '/upload', true); xhr.send(formData);&#125;// 成功上传function uploadSuccess(event) &#123; if (xhr.readyState === 4) &#123; console.log(xhr.responseText); &#125;&#125;上传进度在进行文件上传的时候，xhr对象会有一个upload属性，会提供一个progress事件，在相应的事件处理器里面通过事件对象可以知道当前的上传进度，利用这个特点可以很方便地实现进度条或者进度提示。123&lt;input type=\"file\" name=\"file\" id=\"file\" /&gt;&lt;button id=\"upload\"&gt;上传&lt;/button&gt;&lt;span id=\"progress\"&gt;0%&lt;/span&gt;12345678910111213141516171819var progress = document.querySelector('#progress');// 点击上传function uploadFile(event) &#123; var formData = new FormData(); formData.append('test-upload', file.files[0]); xhr.onload = uploadSuccess; xhr.upload.onprogress = setProgress; xhr.open('post', '/upload', true); xhr.send(formData);&#125;// 进度条function setProgress(event) &#123; if (event.lengthComputable) &#123; var complete = Number.parseInt(event.loaded / event.total * 100); progress.innerHTML = complete + '%'; &#125;&#125;图片预览上传图片的时候可以利用FileReader对象来实现图片预览。FileReader可以异步读取用户电脑上的文件，将file input选中的文件传给FileReader，读取之后取得文件的URL并设置为image元素的src即可让选中的图片文件显示出来。1234&lt;input type=\"file\" name=\"file\" id=\"file\" /&gt;&lt;button id=\"upload\"&gt;上传&lt;/button&gt;&lt;span id=\"progress\"&gt;0&lt;/span&gt;&lt;img id=\"image\" src=\"\" width=\"200\" /&gt;1234567891011var file = document.querySelector('#file');file.addEventListener('change', previewImage, false);// 图片预览function previewImage(event) &#123; var reader = new FileReader(); reader.onload = function (event) &#123; image.src = event.target.result; &#125;; reader.readAsDataURL(event.target.files[0]);&#125;服务端处理使用express搭建一个简单的NodeJS服务端，提供上传文件的接口。express要支持文件上传需要用到中间件，在express官网上有很多介绍。这里我使用的是multer中间件，下面是简单的使用示例。upload.single表示这个接口接受的上传文件数量为1个，&#39;test-upload&#39;限制了上传的表单数据的键为&#39;test-upload&#39;（formData.append(&#39;test-upload&#39;, file.files[0]);）。经过这个中间件处理之后，通过req.file可以访问到文件的相关信息，上传的文件存放在uploads文件夹中。1234567891011121314151617181920const upload = require('multer')(&#123; dest: 'uploads/' &#125;);app.post('/upload', upload.single('test-upload'), (req, res) =&gt; &#123; // 没有附带文件 if (!req.file) &#123; res.json(&#123; ok: false &#125;); return; &#125; // 输出文件信息 console.log('===================================================='); console.log('fieldname: ' + req.file.fieldname); console.log('originalname: ' + req.file.originalname); console.log('encoding: ' + req.file.encoding); console.log('mimetype: ' + req.file.mimetype); console.log('size: ' + (req.file.size / 1024).toFixed(2) + 'KB'); console.log('destination: ' + req.file.destination); console.log('filename: ' + req.file.filename); console.log('path: ' + req.file.path);&#125;);由输出可以看到，文件的命名使用一个哈希值表示，并且去除了后缀名，想要保持文件的原有的命名格式，需要再通过fs对文件进行改名。123456789101112131415161718192021222324252627282930app.post('/upload', upload.single('test-upload'), (req, res) =&gt; &#123; // 没有附带文件 if (!req.file) &#123; res.json(&#123; ok: false &#125;); return; &#125; // 输出文件信息 console.log('===================================================='); console.log('fieldname: ' + req.file.fieldname); console.log('originalname: ' + req.file.originalname); console.log('encoding: ' + req.file.encoding); console.log('mimetype: ' + req.file.mimetype); console.log('size: ' + (req.file.size / 1024).toFixed(2) + 'KB'); console.log('destination: ' + req.file.destination); console.log('filename: ' + req.file.filename); console.log('path: ' + req.file.path); // 重命名文件 let oldPath = path.join(__dirname, req.file.path); let newPath = path.join(__dirname, 'uploads/' + req.file.originalname); fs.rename(oldPath, newPath, (err) =&gt; &#123; if (err) &#123; res.json(&#123; ok: false &#125;); console.log(err); &#125; else &#123; res.json(&#123; ok: true &#125;); &#125; &#125;);&#125;);完整代码ajax异步文件上传、进度显示、图片预览1234&lt;input type=\"file\" name=\"file\" id=\"file\" /&gt;&lt;button id=\"upload\"&gt;上传&lt;/button&gt;&lt;span id=\"progress\"&gt;0&lt;/span&gt;&lt;img id=\"image\" src=\"\" width=\"200\" /&gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546(function () &#123; 'use strict'; var file = document.querySelector('#file'); var upload = document.querySelector('#upload'); var progress = document.querySelector('#progress'); var image = document.querySelector('#image'); var xhr = new XMLHttpRequest(); upload.addEventListener('click', uploadFile, false); file.addEventListener('change', previewImage, false); // 点击上传 function uploadFile(event) &#123; var formData = new FormData(); formData.append('test-upload', file.files[0]); xhr.onload = uploadSuccess; xhr.upload.onprogress = setProgress; xhr.open('post', '/upload', true); xhr.send(formData); &#125; // 成功上传 function uploadSuccess(event) &#123; if (xhr.readyState === 4) &#123; console.log(xhr.responseText); &#125; &#125; // 进度条 function setProgress(event) &#123; if (event.lengthComputable) &#123; var complete = Number.parseInt(event.loaded / event.total * 100); progress.innerHTML = complete + '%'; &#125; &#125; // 图片预览 function previewImage(event) &#123; var reader = new FileReader(); reader.onload = function (event) &#123; image.src = event.target.result; &#125;; reader.readAsDataURL(event.target.files[0]); &#125;&#125;)();express服务器提供文件上传接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const express = require('express');const upload = require('multer')(&#123; dest: 'uploads/' &#125;);const path = require('path');const fs = require('fs');const port = 8080;let app = express();app.set('port', port);// index.html, index.js放在static文件夹中app.use(express.static(path.join(__dirname, 'static')));app.get('*', (req, res) =&gt; &#123; res.redirect('index.html');&#125;);app.post('/upload', upload.single('test-upload'), (req, res) =&gt; &#123; // 没有附带文件 if (!req.file) &#123; res.json(&#123; ok: false &#125;); return; &#125; // 输出文件信息 console.log('===================================================='); console.log('fieldname: ' + req.file.fieldname); console.log('originalname: ' + req.file.originalname); console.log('encoding: ' + req.file.encoding); console.log('mimetype: ' + req.file.mimetype); console.log('size: ' + (req.file.size / 1024).toFixed(2) + 'KB'); console.log('destination: ' + req.file.destination); console.log('filename: ' + req.file.filename); console.log('path: ' + req.file.path); // 重命名文件 let oldPath = path.join(__dirname, req.file.path); let newPath = path.join(__dirname, 'uploads/' + req.file.originalname); fs.rename(oldPath, newPath, (err) =&gt; &#123; if (err) &#123; res.json(&#123; ok: false &#125;); console.log(err); &#125; else &#123; res.json(&#123; ok: true &#125;); &#125; &#125;);&#125;);app.listen(port, () =&gt; &#123; console.log(\"[Server] localhost:\" + port);&#125;);","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://hongchh.github.io/tags/JavaScript/"}]},{"title":"Ajax和Comet相关技术总结","slug":"Ajax和Comet相关技术总结","date":"2017-02-18T13:02:55.000Z","updated":"2017-11-11T10:21:12.503Z","comments":true,"path":"2017/Ajax和Comet相关技术总结/","link":"","permalink":"https://hongchh.github.io/2017/Ajax和Comet相关技术总结/","excerpt":"","text":"Ajax是一种技术，一种能够向服务器请求额外的数据而无需卸载页面的技术，能够使网页具备更优的用户体验。Ajax技术的核心是XMLHttpRequest对象（XHR）。本文从XHR开始谈起，理解Ajax技术的特点，再对跨域以及Comet等技术进行简要理解和总结。XMLHttpRequest基本用法XHR对象有两个常用的方法open和send。open方法用户启动一个HTTP请求，不过它不会真的发送HTTP请求。open方法接收3个参数，分别表示请求的HTTP方法、请求的URL、是否异步。XHR对象的第二个方法send用于发送open所启动的请求。send方法接收1个参数，表示HTTP请求的主体数据。如果发送的是GET请求这种没有附带主体数据的HTTP请求，则传入null即可。如果是POST请求，则传入需要POST的数据。下面是一个简单示例，向/api/data发起一个GET请求，并且是采取异步的方式发送请求，即该请求不会阻塞页面中其他js代码的执行。123var xhr = new XMLHttpRequest()xhr.open(\"get\", \"/api/data\", true)xhr.send(null)请求得到的响应数据会自动填充到XHR对象的属性上，主要有下面4个属性：responseText: 响应主体文本responseXML: 如果响应内容类型是&quot;text/xml&quot;或&quot;application/xml&quot;, 这个属性中将包含响应数据的XML DOM文档status: 响应的HTTP状态码，一般可以将HTTP状态码200视为成功的标识statusText: HTTP状态的说明XHR对象有1个readyState属性记录了该对象从创建到收到响应数据可能会经历的5种状态，readyState的可能取值如下：0: 还没有调用open()方法初始化请求1: 已经调用open()方法但是还没有调用send()方法2: 已经调用send()方法但是还没有收到响应3: 收到部分响应数据，还有部分数据没收到4: 收到全部响应数据，即响应结束，数据完备当readyState从一个值变到另一个值的时候会触发readystatechange事件，当这个事件触发的时候只需要在事件处理器里面检查一下readyState的值是否为4，当其值为4的时候就可以对响应的数据做后续处理了。给readystatechange事件指定处理器必须在调用open()方法之前完成才能确保跨浏览器兼容性。下面是简单示例。12345678var xhr = new XMLHttpRequest()xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; console.log(xhr.status, xhr.responseText) &#125;&#125;xhr.open(\"get\", \"/api/data\", true)xhr.send(null)XHR对象提供setRequestHeader()方法可以设置请求的自定义HTTP头部信息，该方法接收两个参数，要设置的字段和该字段的值。在调用open()启动一个请求之后并且在send()发送请求之前调用setRequestHeader()才能设置成功。请求得到响应之后，可以通过getResponseHeader()方法获取响应的HTTP头部信息，该方法接收1个参数，即要获取的字段名。而通过getAllResponseHeaders()则可以获得所有头部信息组成的长字符串。下面是简单示例。1234567891011var xhr = new XMLHttpRequest()xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; console.log(xhr.status, xhr.responseText) console.log(xhr.getResponseHeader('SomeKey')) console.log(xhr.getAllResponseHeaders()) &#125;&#125;xhr.open(\"get\", \"/api/data\", true)xhr.setRequestHeader(\"SomeKey\", \"SomeValue\")xhr.send(null)FormDataXMLHttpRequest 2级定义了FormData类型为序列化表单、创建与表单格式相同的数据、用于XHR传输提供便利。FormData提供append()方法可以直接添加数据，该方法接收两个参数键和值。FormData的构造函数可以不传参数，也可以直接传入1个表单元素。传入表单元素之后会利用该表单元素的数据来向FormData对象预先填入键值对。下面是简单示例。1234567891011var form = document.getElementById('myForm')var data = new FormData(form)data.append('someKey', 'someValue')var xhr = new XMLHttpRequest()xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; console.log(xhr.responseText) &#125;&#125;xhr.open('post', '/api/upload', true)xhr.send(data)跨域资源共享通过XHR实现Ajax通信会遇到一个限制，即跨域安全策略。跨域安全策略限制了“相同域名、相同端口、相同协议”，当XHR想要访问限制之外的资源就会引发安全错误。CORS(Cross-Origin Resource Sharing)，跨域资源共享，其思想是通过使用自定义HTTP头部让浏览器与服务器进行沟通从而决定请求或者响应的成功与失败，需要浏览器和服务器同时支持才能实现正常的访问。目前大部分浏览器已经支持了CORS，所以写起代码跟普通的同域资源访问几乎一样，就只是把URL用绝对路径表示。因此，要实现跨域的关键还是在服务器，具体如何实现本文不深入讨论。下面是前端js的简单示例。12345678var xhr = new XMLHttpRequest()xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; console.log(xhr.responseText) &#125;&#125;xhr.open('get', 'http://www.otherserver.com/api/data', true)xhr.send(null)JSONPJSONP（JSON with padding）是应用JSON实现跨域资源访问的一种方法。JSONP由两部分内容组成：回调函数和JSON数据。前面说过，XHR请求会遇到跨域安全策略的限制，但是HTML中的script标签则不会有这个限制，我们可以通过script标签引用不同域里面的js文件。JSONP便是钻了这个空子，它通过动态创建script元素，然后把src指向其他域的URL从而实现加载其他域的资源，然后通过回调函数来处理加载得到的数据。下面是一个简单示例。1234567function handler(res) &#123; console.log(res)&#125;var script = document.createElement('script')script.src = 'http://www.otherserver.com/api/data/?callback=handler'document.body.insertBefore(script, document.body.firstChild)上述代码指定了动态创建的script元素的src为另一个域名下面的/api/data，然后指明回调函数为handler。将script插入到DOM里面之后会向对应的URL加载数据，完成之后会将得到的JSON数据解析成一个对象并调用handler进行处理。JSONP是实现跨域访问的一种简单的方法，不过也存在一些安全问题，例如请求的其他域的URL响应给你一段恶意代码。JSONP还有一个问题，script标签引用的是js，json由于被js所支持所以也可以引用，因此在请求其他域的URL时需要确认它是否以json格式进行响应，而不是XML。CometAjax是一种从网页向服务器请求数据的技术，而Comet与之相反，它是从服务器向网页推送数据的技术，适用于实时性要求比较高的应用。实现Comet的方式有两种：长轮询和流。在说长轮询之前先说一下短轮询，它的思路很简单，就是客户端使用定时器，每隔一定的时间间隔就向服务器发送Ajax请求看看有没有数据更新，这个时间间隔一般很小。长轮询同样也是客户端不断向服务器发送请求，不同的是，客户端不需要按照时间间隔不断地发送请求，而是发起1个请求到服务器之后，客户端和服务器之间的HTTP连接保持打开，直到服务器有数据更新就通过这个连接向客户端响应数据，然后再关闭这个HTTP连接。关闭之后浏览器再发起一个新的连接继续重复前面的过程。相比短轮询，长轮询发起的HTTP连接次数更少了，不过如果HTTP连接长时间保持开放也是在占用服务器的资源。第二种实现Comet的方式是基于HTTP流，客户端向服务器发起1个HTTP连接，全程保持这个连接打开，客户端周期性地通过这个连接向服务器获取数据查看更新。SSESSE（Server-Send Events），服务器发送事件，是一种实现Comet交互的浏览器API，支持轮询也支持HTTP流。SSE API用于创建到服务器的单向连接，服务器通过这个连接可以发送任意数量的数据给客户端。服务器响应的MIME类型为text/event-stream。下面是SSE的JavaScript API的简单示例。1234var source = new EventSource(\"/api/events\")source.onmessage = function(event) &#123; console.log(event.data)&#125;如上面代码所示，要向服务器预定事件流获取服务器发送的数据，首先创建EventSource对象，然后在message事件触发的时候进行处理。服务器发送的数据以字符串形式保存在event.data中。EventSource对象会保持与服务器的活动连接，如果中间断开会重新连接，如果要真正地断开连接可以通过调用close()方法来实现。EventSource的message事件会在从服务器收到新事件的时候触发，除了message事件之外它还有另外2个事件open和error，open事件在建立连接的时候触发，error事件在无法建立连接的时候触发。Web SocketsWeb Sockets是一种与服务器进行全双工双向通信的通道。Web Sockets不适用HTTP协议，而前面说的Ajax和Comet都是使用HTTP协议。篇幅关系本文对Web Sockets不作讨论。总结Ajax实现在不加载页面的情况下向服务器请求数据，提升网页的用户体验。实现Ajax技术的XHR会遇到跨域安全策略的限制，通过CORS解决跨域问题需要浏览器和服务器两端的配合。JSONP是一种实现跨域访问的”小技巧“但也是存在一些问题。Comet对Ajax进行了拓展，让服务器能够实时向浏览器推送数据，但从实现来看不管是轮询还是HTTP流，都是浏览器先向服务器发起请求连接。Web Sockets的全双工双向通信也有其特色，以后有时间可以继续了解。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://hongchh.github.io/tags/JavaScript/"}]},{"title":"vue-cli的webpack模板项目配置文件分析","slug":"vue-cli的webpack模板项目配置文件分析","date":"2017-02-14T15:07:45.000Z","updated":"2017-11-11T12:31:49.737Z","comments":true,"path":"2017/vue-cli的webpack模板项目配置文件分析/","link":"","permalink":"https://hongchh.github.io/2017/vue-cli的webpack模板项目配置文件分析/","excerpt":"","text":"2017-09-11更新：更新到webpack 2.6.1所对应的配置，完善部分代码注释。由于最近在vue-cli生成的webpack模板项目的基础上写一个小东西，开发过程中需要改动到build和config里面一些相关的配置，所以刚好趁此机会将所有配置文件看一遍，理一理思路，也便于以后修改配置的时候不会“太折腾”。一、文件结构本文主要分析开发（dev）和构建（build）两个过程涉及到的文件，故下面文件结构仅列出相应的内容。123456789101112131415161718├─build│ ├─build.js│ ├─check-versions.js│ ├─dev-client.js│ ├─dev-server.js│ ├─utils.js│ ├─vue-loader.conf.js│ ├─webpack.base.conf.js│ ├─webpack.dev.conf.js│ ├─webpack.prod.conf.js│ └─webpack.test.conf.js├─config│ ├─dev.env.js│ ├─index.js│ ├─prod.env.js│ └─test.env.js├─...└─package.json二、指令分析首先看package.json里面的scripts字段，12345678\"scripts\": &#123; \"dev\": \"node build/dev-server.js\", \"build\": \"node build/build.js\", \"unit\": \"cross-env BABEL_ENV=test karma start test/unit/karma.conf.js --single-run\", \"e2e\": \"node test/e2e/runner.js\", \"test\": \"npm run unit &amp;&amp; npm run e2e\", \"lint\": \"eslint --ext .js,.vue src test/unit/specs test/e2e/specs\" &#125;测试的东西先不看，直接看&quot;dev&quot;和&quot;build&quot;。运行npm run dev的时候执行的是build/dev-server.js文件，运行npm run build的时候执行的是build/build.js文件，我们可以从这两个文件开始进行代码阅读分析。三、build文件夹分析build/dev-server.js首先来看执行npm run dev时候最先执行的build/dev-server.js文件。该文件主要完成下面几件事情：检查node和npm的版本、引入相关插件和配置webpack对源码进行编译打包并返回compiler对象创建express服务器配置开发中间件（webpack-dev-middleware）和热重载中间件（webpack-hot-middleware）挂载代理服务和中间件配置静态资源启动服务器监听特定端口（8080）自动打开浏览器并打开特定网址（localhost:8080）说明： express服务器提供静态文件服务，不过它还使用了http-proxy-middleware，一个http请求代理的中间件。前端开发过程中需要使用到后台的API的话，可以通过配置proxyTable来将相应的后台请求代理到专用的API服务器。详情请看代码注释：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// 检查NodeJS和npm的版本require('./check-versions')()// 获取基本配置var config = require('../config')// 如果Node的环境变量中没有设置当前的环境（NODE_ENV），则使用config中的dev环境配置作为当前的环境if (!process.env.NODE_ENV) &#123; process.env.NODE_ENV = JSON.parse(config.dev.env.NODE_ENV)&#125;// opn是一个可以调用默认软件打开网址、图片、文件等内容的插件// 这里用它来调用默认浏览器打开dev-server监听的端口，例如：localhost:8080var opn = require('opn')var path = require('path')var express = require('express')var webpack = require('webpack')// http-proxy-middleware是一个express中间件，用于将http请求代理到其他服务器// 例：localhost:8080/api/xxx --&gt; localhost:3000/api/xxx// 这里使用该插件可以将前端开发中涉及到的请求代理到提供服务的后台服务器上，方便与服务器对接var proxyMiddleware = require('http-proxy-middleware')// 开发环境下的webpack配置var webpackConfig = require('./webpack.dev.conf')// dev-server 监听的端口，如果没有在命令行传入端口号，则使用config.dev.port设置的端口，例如8080var port = process.env.PORT || config.dev.port// 用于判断是否要自动打开浏览器的布尔变量，当配置文件中没有设置自动打开浏览器的时候其值为 falsevar autoOpenBrowser = !!config.dev.autoOpenBrowser// HTTP代理表，指定规则，将某些API请求代理到相应的服务器var proxyTable = config.dev.proxyTable// 创建express服务器var app = express()// webpack根据配置开始编译打包源码并返回compiler对象var compiler = webpack(webpackConfig)// webpack-dev-middleware将webpack编译打包后得到的产品文件存放在内存中而没有写进磁盘// 将这个中间件挂到express上使用之后即可提供这些编译后的产品文件服务var devMiddleware = require('webpack-dev-middleware')(compiler, &#123; publicPath: webpackConfig.output.publicPath, // 设置访问路径为webpack配置中的output里面所对应的路径 quiet: true // 设置为true，使其不要在控制台输出日志&#125;)// webpack-hot-middleware，用于实现热重载功能的中间件var hotMiddleware = require('webpack-hot-middleware')(compiler, &#123; log: false, // 关闭控制台的日志输出 heartbeat: 2000 // 发送心跳包的频率&#125;)// webpack(重新)编译打包完成后并将js、css等文件inject到html文件之后，通过热重载中间件强制页面刷新compiler.plugin('compilation', function (compilation) &#123; compilation.plugin('html-webpack-plugin-after-emit', function (data, cb) &#123; hotMiddleware.publish(&#123; action: 'reload' &#125;) cb() &#125;)&#125;)// 根据 proxyTable 中的代理请求配置来设置express服务器的http代理规则Object.keys(proxyTable).forEach(function (context) &#123; var options = proxyTable[context] // 格式化options，例如将'www.example.com'变成&#123; target: 'www.example.com' &#125; if (typeof options === 'string') &#123; options = &#123; target: options &#125; &#125; app.use(proxyMiddleware(options.filter || context, options))&#125;)// handle fallback for HTML5 history API// 重定向不存在的URL，用于支持SPA（单页应用）// 例如使用vue-router并开启了history模式app.use(require('connect-history-api-fallback')())// serve webpack bundle output// 挂载webpack-dev-middleware中间件，提供webpack编译打包后的产品文件服务app.use(devMiddleware)// enable hot-reload and state-preserving// compilation error display// 挂载热重载中间件app.use(hotMiddleware)// serve pure static assets// 提供static文件夹上的静态文件服务var staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)app.use(staticPath, express.static('./static'))// 访问链接var uri = 'http://localhost:' + port// 创建promise，在应用服务启动之后resolve// 便于外部文件require了这个dev-server之后的代码编写var _resolvevar readyPromise = new Promise(resolve =&gt; &#123; _resolve = resolve&#125;)console.log('&gt; Starting dev server...')// webpack-dev-middleware等待webpack完成所有编译打包之后输出提示语到控制台，表明服务正式启动// 服务正式启动才自动打开浏览器进入页面devMiddleware.waitUntilValid(() =&gt; &#123; console.log('&gt; Listening at ' + uri + '\\n') // when env is testing, don't need open it if (autoOpenBrowser &amp;&amp; process.env.NODE_ENV !== 'testing') &#123; opn(uri) &#125; _resolve()&#125;)// 启动express服务器并监听相应的端口var server = app.listen(port)// 暴露本模块的功能给外部使用，例如下面这种用法// var devServer = require('./build/dev-server')// devServer.ready.then(() =&gt; &#123;...&#125;)// if (...) &#123; devServer.close() &#125;module.exports = &#123; ready: readyPromise, close: () =&gt; &#123; server.close() &#125;&#125;build/webpack.base.conf.js从代码中看到，dev-server使用的webpack配置来自build/webpack.dev.conf.js文件（测试环境下使用的是build/webpack.prod.conf.js，这里暂时不考虑测试环境）。而build/webpack.dev.conf.js中又引用了webpack.base.conf.js，所以这里我先分析webpack.base.conf.js。webpack.base.conf.js主要完成了下面这些事情：配置webpack编译入口配置webpack输出路径和命名规则配置模块resolve规则配置不同类型模块的处理规则说明： 这个配置里面只配置了.js、.vue、图片、字体等几类文件的处理规则，如果需要处理其他文件可以在module.rules里面另行配置。具体请看代码注释：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293var path = require('path')var fs = require('fs')var utils = require('./utils')var config = require('../config')var vueLoaderConfig = require('./vue-loader.conf')// 获取绝对路径function resolve (dir) &#123; return path.join(__dirname, '..', dir)&#125;module.exports = &#123; // webpack入口文件 entry: &#123; app: './src/main.js' &#125;, // webpack输出路径和命名规则 output: &#123; // webpack输出的目标文件夹路径（例如：/dist） path: config.build.assetsRoot, // webpack输出bundle文件命名格式 filename: '[name].js', // webpack编译输出的发布路径（例如'//cdn.xxx.com/app/'） publicPath: process.env.NODE_ENV === 'production' ? config.build.assetsPublicPath : config.dev.assetsPublicPath &#125;, // 模块resolve的规则 resolve: &#123; extensions: ['.js', '.vue', '.json'], // 别名，方便引用模块，例如有了别名之后， // import Vue from 'vue/dist/vue.common.js'可以写成 import Vue from 'vue' alias: &#123; 'vue$': 'vue/dist/vue.esm.js', '@': resolve('src'), &#125;, symlinks: false &#125;, // 不同类型模块的处理规则 module: &#123; rules: [ &#123;// 对src和test文件夹下的.js和.vue文件使用eslint-loader进行代码规范检查 test: /\\.(js|vue)$/, loader: 'eslint-loader', enforce: 'pre', include: [resolve('src'), resolve('test')], options: &#123; formatter: require('eslint-friendly-formatter') &#125; &#125;, &#123;// 对所有.vue文件使用vue-loader进行编译 test: /\\.vue$/, loader: 'vue-loader', options: vueLoaderConfig &#125;, &#123;// 对src和test文件夹下的.js文件使用babel-loader将es6+的代码转成es5 test: /\\.js$/, loader: 'babel-loader', include: [resolve('src'), resolve('test')] &#125;, &#123;// 对图片资源文件使用url-loader test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: 'url-loader', options: &#123; // 小于10K的图片转成base64编码的dataURL字符串写到代码中 limit: 10000, // 其他的图片转移到静态资源文件夹 name: utils.assetsPath('img/[name].[hash:7].[ext]') &#125; &#125;, &#123;// 对多媒体资源文件使用url-loader test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/, loader: 'url-loader', options: &#123; // 小于10K的资源转成base64编码的dataURL字符串写到代码中 limit: 10000, // 其他的资源转移到静态资源文件夹 name: utils.assetsPath('media/[name].[hash:7].[ext]') &#125; &#125;, &#123;// 对字体资源文件使用url-loader test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/, loader: 'url-loader', options: &#123; // 小于10K的资源转成base64编码的dataURL字符串写到代码中 limit: 10000, // 其他的资源转移到静态资源文件夹 name: utils.assetsPath('fonts/[name].[hash:7].[ext]') &#125; &#125; ] &#125;&#125;build/webpack.dev.conf.js接下来看webpack.dev.conf.js，这里面在webpack.base.conf的基础上增加完善了开发环境下面的配置，主要包括下面几件事情：将webpack的热重载客户端代码添加到每个entry对应的应用合并基础的webpack配置配置样式文件的处理规则，styleLoaders配置Source Maps配置webpack插件详情请看代码注释：123456789101112131415161718192021222324252627282930313233343536373839404142434445var utils = require('./utils')var webpack = require('webpack')var config = require('../config')// webpack-merge是一个可以合并数组和对象的插件var merge = require('webpack-merge')var baseWebpackConfig = require('./webpack.base.conf')// html-webpack-plugin用于将webpack编译打包后的产品文件注入到html模板中// 即自动在index.html里面加上&lt;link&gt;和&lt;script&gt;标签引用webpack打包后的文件var HtmlWebpackPlugin = require('html-webpack-plugin')// friendly-errors-webpack-plugin用于更友好地输出webpack的警告、错误等信息var FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin')// add hot-reload related code to entry chunks// 给每个入口页面(应用)加上dev-client，用于跟dev-server的热重载插件通信，实现热更新Object.keys(baseWebpackConfig.entry).forEach(function (name) &#123; baseWebpackConfig.entry[name] = ['./build/dev-client'].concat(baseWebpackConfig.entry[name])&#125;)module.exports = merge(baseWebpackConfig, &#123; module: &#123; // 样式文件的处理规则，对css/sass/scss等不同内容使用相应的styleLoaders // 由utils配置出各种类型的预处理语言所需要使用的loader，例如sass需要使用sass-loader rules: utils.styleLoaders(&#123; sourceMap: config.dev.cssSourceMap &#125;) &#125;, // cheap-module-eval-source-map is faster for development // 使用这种source-map更快 devtool: '#cheap-module-eval-source-map', // webpack插件 plugins: [ new webpack.DefinePlugin(&#123; 'process.env': config.dev.env &#125;), // 开启webpack热更新功能 new webpack.HotModuleReplacementPlugin(), // webpack编译过程中出错的时候跳过报错阶段，不会阻塞编译，在编译结束后报错 new webpack.NoEmitOnErrorsPlugin(), // 自动将依赖注入html模板，并输出最终的html文件到目标文件夹 new HtmlWebpackPlugin(&#123; filename: 'index.html', template: 'index.html', inject: true &#125;), new FriendlyErrorsPlugin() ]&#125;)build/utils.jsutils提供工具函数，包括生成处理各种样式语言的loader，获取资源文件存放路径的工具函数。计算资源文件存放路径生成cssLoaders用于加载.vue文件中的样式生成styleLoaders用于加载不在.vue文件中的单独存在的样式文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687var path = require('path')var config = require('../config')// extract-text-webpack-plugin可以提取bundle中的特定文本，将提取后的文本单独存放到另外的文件// 这里用来提取css样式var ExtractTextPlugin = require('extract-text-webpack-plugin')// 资源文件的存放路径exports.assetsPath = function (_path) &#123; var assetsSubDirectory = process.env.NODE_ENV === 'production' ? config.build.assetsSubDirectory : config.dev.assetsSubDirectory return path.posix.join(assetsSubDirectory, _path)&#125;// 生成css、sass、scss等各种用来编写样式的语言所对应的loader配置exports.cssLoaders = function (options) &#123; options = options || &#123;&#125; // css-loader配置 var cssLoader = &#123; loader: 'css-loader', options: &#123; // 是否最小化 minimize: process.env.NODE_ENV === 'production', // 是否使用source-map sourceMap: options.sourceMap &#125; &#125; // generate loader string to be used with extract text plugin // 生成各种loader配置，并且配置了extract-text-pulgin function generateLoaders (loader, loaderOptions) &#123; // 默认是css-loader var loaders = [cssLoader] // 如果非css，则增加一个处理预编译语言的loader并设好相关配置属性 // 例如generateLoaders('less')，这里就会push一个less-loader // less-loader先将less编译成css，然后再由css-loader去处理css // 其他sass、scss等语言也是一样的过程 if (loader) &#123; loaders.push(&#123; loader: loader + '-loader', options: Object.assign(&#123;&#125;, loaderOptions, &#123; sourceMap: options.sourceMap &#125;) &#125;) &#125; // Extract CSS when that option is specified // (which is the case during production build) if (options.extract) &#123; // 配置extract-text-plugin提取样式 return ExtractTextPlugin.extract(&#123; use: loaders, fallback: 'vue-style-loader' &#125;) &#125; else &#123; // 无需提取样式则简单使用vue-style-loader配合各种样式loader去处理&lt;style&gt;里面的样式 return ['vue-style-loader'].concat(loaders) &#125; &#125; // https://vue-loader.vuejs.org/en/configurations/extract-css.html // 得到各种不同处理样式的语言所对应的loader return &#123; css: generateLoaders(), postcss: generateLoaders(), less: generateLoaders('less'), sass: generateLoaders('sass', &#123; indentedSyntax: true &#125;), scss: generateLoaders('sass'), stylus: generateLoaders('stylus'), styl: generateLoaders('stylus') &#125;&#125;// Generate loaders for standalone style files (outside of .vue)// 生成处理单独的.css、.sass、.scss等样式文件的规则exports.styleLoaders = function (options) &#123; var output = [] var loaders = exports.cssLoaders(options) for (var extension in loaders) &#123; var loader = loaders[extension] output.push(&#123; test: new RegExp('\\\\.' + extension + '$'), use: loader &#125;) &#125; return output&#125;build/vue-loader.conf.jsvue-loader.conf的配置比较简单，详情请看代码注释：123456789101112131415161718192021var utils = require('./utils')var config = require('../config')var isProduction = process.env.NODE_ENV === 'production'module.exports = &#123; // 处理.vue文件中的样式 loaders: utils.cssLoaders(&#123; // 是否打开source-map sourceMap: isProduction ? config.build.productionSourceMap : config.dev.cssSourceMap, // 是否提取样式到单独的文件 extract: isProduction &#125;), transformToRequire: &#123; video: 'src', source: 'src', img: 'src', image: 'xlink:href' &#125;&#125;build/dev-client.jsdev-client.js里面主要写了浏览器端代码，用于实现webpack的热更新。1234567891011121314/* eslint-disable */// 实现浏览器端的EventSource，用于跟服务器双向通信// webpack热重载客户端跟dev-server上的热重载插件之间需要进行双向通信// 服务端webpack重新编译后，会向客户端推送信息，告诉客户端进行更新require('eventsource-polyfill')// webpack热重载客户端var hotClient = require('webpack-hot-middleware/client?noInfo=true&amp;reload=true')// 客户端收到更新动作，执行页面刷新hotClient.subscribe(function (event) &#123; if (event.action === 'reload') &#123; window.location.reload() &#125;&#125;)build/build.js讲完了开发环境下的配置，下面开始来看构建环境下的配置。执行npm run build的时候首先执行的是build/build.js文件，build.js主要完成下面几件事：loading动画删除目标文件夹执行webpack构建输出信息说明： webpack编译之后会输出到配置里面指定的目标文件夹；删除目标文件夹之后再创建是为了去除旧的内容，以免产生不可预测的影响。详情请看代码注释：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 检查NodeJS和npm的版本require('./check-versions')()process.env.NODE_ENV = 'production'// ora，一个可以在终端显示spinner的插件var ora = require('ora')// rm，用于删除文件或文件夹的插件var rm = require('rimraf')var path = require('path')// chalk，用于在控制台输出带颜色字体的插件var chalk = require('chalk')var webpack = require('webpack')var config = require('../config')var webpackConfig = require('./webpack.prod.conf')var spinner = ora('building for production...')spinner.start() // 开启loading动画// 首先将整个dist文件夹以及里面的内容删除，以免遗留旧的没用的文件// 删除完成后才开始webpack构建打包rm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err =&gt; &#123; if (err) throw err // 执行webpack构建打包，完成之后在终端输出构建完成的相关信息或者输出报错信息并退出程序 webpack(webpackConfig, function (err, stats) &#123; spinner.stop() if (err) throw err process.stdout.write(stats.toString(&#123; colors: true, modules: false, children: false, chunks: false, chunkModules: false &#125;) + '\\n\\n') if (stats.hasErrors()) &#123; console.log(chalk.red(' Build failed with errors.\\n')) process.exit(1) &#125; console.log(chalk.cyan(' Build complete.\\n')) console.log(chalk.yellow( ' Tip: built files are meant to be served over an HTTP server.\\n' + ' Opening index.html over file:// won\\'t work.\\n' )) &#125;)&#125;)build/webpack.prod.conf.js构建的时候用到的webpack配置来自webpack.prod.conf.js，该配置同样是在webpack.base.conf基础上的进一步完善。主要完成下面几件事情：合并基础的webpack配置配置样式文件的处理规则，styleLoaders配置webpack的输出配置webpack插件gzip模式下的webpack插件配置webpack-bundle分析说明： webpack插件里面多了丑化压缩代码以及抽离css文件等插件。详情请看代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145var path = require('path')var utils = require('./utils')var webpack = require('webpack')var config = require('../config')var merge = require('webpack-merge')var baseWebpackConfig = require('./webpack.base.conf')// copy-webpack-plugin，用于将static中的静态文件复制到产品文件夹distvar CopyWebpackPlugin = require('copy-webpack-plugin')var HtmlWebpackPlugin = require('html-webpack-plugin')var ExtractTextPlugin = require('extract-text-webpack-plugin')// optimize-css-assets-webpack-plugin，用于优化和最小化css资源var OptimizeCSSPlugin = require('optimize-css-assets-webpack-plugin')var env = config.build.envvar webpackConfig = merge(baseWebpackConfig, &#123; module: &#123; // 样式文件的处理规则，对css/sass/scss等不同内容使用相应的styleLoaders // 由utils配置出各种类型的预处理语言所需要使用的loader，例如sass需要使用sass-loader rules: utils.styleLoaders(&#123; sourceMap: config.build.productionSourceMap, extract: true &#125;) &#125;, // 是否使用source-map devtool: config.build.productionSourceMap ? '#source-map' : false, // webpack输出路径和命名规则 output: &#123; path: config.build.assetsRoot, filename: utils.assetsPath('js/[name].[chunkhash].js'), chunkFilename: utils.assetsPath('js/[id].[chunkhash].js') &#125;, // webpack插件 plugins: [ // http://vuejs.github.io/vue-loader/en/workflow/production.html new webpack.DefinePlugin(&#123; 'process.env': env &#125;), // 丑化压缩JS代码 new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125;, sourceMap: true &#125;), // extract css into its own file // 将css提取到单独的文件 new ExtractTextPlugin(&#123; filename: utils.assetsPath('css/[name].[contenthash].css') &#125;), // Compress extracted CSS. We are using this plugin so that possible // duplicated CSS from different components can be deduped. // 优化、最小化css代码，如果只简单使用extract-text-plugin可能会造成css重复 // 具体原因可以看npm上面optimize-css-assets-webpack-plugin的介绍 new OptimizeCSSPlugin(&#123; cssProcessorOptions: &#123; safe: true &#125; &#125;), // generate dist index.html with correct asset hash for caching. // you can customize output by editing /index.html // see https://github.com/ampedandwired/html-webpack-plugin // 将产品文件的引用注入到index.html new HtmlWebpackPlugin(&#123; filename: config.build.index, template: 'index.html', inject: true, minify: &#123; // 删除index.html中的注释 removeComments: true, // 删除index.html中的空格 collapseWhitespace: true, // 删除各种html标签属性值的双引号 removeAttributeQuotes: true // more options: // https://github.com/kangax/html-minifier#options-quick-reference &#125;, // necessary to consistently work with multiple chunks via CommonsChunkPlugin // 注入依赖的时候按照依赖先后顺序进行注入，比如，需要先注入vendor.js，再注入app.js chunksSortMode: 'dependency' &#125;), // keep module.id stable when vender modules does not change new webpack.HashedModuleIdsPlugin(), // split vendor js into its own file // 将所有从node_modules中引入的js提取到vendor.js，即抽取库文件 new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', minChunks: function (module, count) &#123; // any required modules inside node_modules are extracted to vendor return ( module.resource &amp;&amp; /\\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf( path.join(__dirname, '../node_modules') ) === 0 ) &#125; &#125;), // extract webpack runtime and module manifest to its own file in order to // prevent vendor hash from being updated whenever app bundle is updated // 从vendor中提取出manifest，原因如上 new webpack.optimize.CommonsChunkPlugin(&#123; name: 'manifest', chunks: ['vendor'] &#125;), // copy custom static assets // 将static文件夹里面的静态资源复制到dist/static new CopyWebpackPlugin([ &#123; from: path.resolve(__dirname, '../static'), to: config.build.assetsSubDirectory, ignore: ['.*'] &#125; ]) ]&#125;)// 如果开启了产品gzip压缩，则利用插件将构建后的产品文件进行压缩if (config.build.productionGzip) &#123; // 一个用于压缩的webpack插件 var CompressionWebpackPlugin = require('compression-webpack-plugin') webpackConfig.plugins.push( new CompressionWebpackPlugin(&#123; asset: '[path].gz[query]', // 压缩算法 algorithm: 'gzip', test: new RegExp( '\\\\.(' + config.build.productionGzipExtensions.join('|') + ')$' ), threshold: 10240, minRatio: 0.8 &#125;) )&#125;// 如果启动了report，则通过插件给出webpack构建打包后的产品文件分析报告if (config.build.bundleAnalyzerReport) &#123; var BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin webpackConfig.plugins.push(new BundleAnalyzerPlugin())&#125;module.exports = webpackConfigbuild/check-versions.js最后是build文件夹下的check-version.js，它完成对node和npm的版本检测，下面是其代码注释：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// chalk, 用于在控制台输出带颜色字体的插件var chalk = require('chalk')// semver, 语义化版本检查插件（The semantic version parser used by npm）var semver = require('semver')var packageConfig = require('../package.json')// shelljs, 执行Unix命令行的插件var shell = require('shelljs')// 开辟子进程执行指令cmd并返回结果function exec (cmd) &#123; return require('child_process').execSync(cmd).toString().trim()&#125;// node和npm版本需求var versionRequirements = [ &#123; name: 'node', currentVersion: semver.clean(process.version), versionRequirement: packageConfig.engines.node &#125;]if (shell.which('npm')) &#123; versionRequirements.push(&#123; name: 'npm', currentVersion: exec('npm --version'), versionRequirement: packageConfig.engines.npm &#125;)&#125;module.exports = function () &#123; var warnings = [] // 依次判断版本是否符合要求 for (var i = 0; i &lt; versionRequirements.length; i++) &#123; var mod = versionRequirements[i] if (!semver.satisfies(mod.currentVersion, mod.versionRequirement)) &#123; warnings.push(mod.name + ': ' + chalk.red(mod.currentVersion) + ' should be ' + chalk.green(mod.versionRequirement) ) &#125; &#125; // 如果有警告则将其输出到控制台 if (warnings.length) &#123; console.log('') console.log(chalk.yellow('To use this template, you must update following to modules:')) console.log() for (var i = 0; i &lt; warnings.length; i++) &#123; var warning = warnings[i] console.log(' ' + warning) &#125; console.log() process.exit(1) &#125;&#125;四、config文件夹分析config/index.jsconfig文件夹下最主要的文件就是index.js了，在这里面描述了开发和构建两种环境下的配置，前面的build文件夹下也有不少文件引用了index.js里面的配置。下面是代码注释：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// see http://vuejs-templates.github.io/webpack for documentation.var path = require('path')module.exports = &#123; // 构建产品时使用的配置 build: &#123; // 环境变量 env: require('./prod.env'), // html入口文件 index: path.resolve(__dirname, '../dist/index.html'), // 产品文件的存放路径 assetsRoot: path.resolve(__dirname, '../dist'), // 二级目录，存放静态资源文件的目录，位于dist文件夹下 assetsSubDirectory: 'static', // 发布路径，如果构建后的产品文件有用于发布CDN或者放到其他域名的服务器，可以在这里进行设置 // 设置之后构建的产品文件在注入到index.html中的时候就会带上这里的发布路径 assetsPublicPath: '/', // 是否使用source-map productionSourceMap: true, // Gzip off by default as many popular static hosts such as // Surge or Netlify already gzip all static assets for you. // Before setting to `true`, make sure to: // npm install --save-dev compression-webpack-plugin // 是否开启gzip压缩 productionGzip: false, // gzip模式下需要压缩的文件的扩展名，设置js、css之后就只会对js和css文件进行压缩 productionGzipExtensions: ['js', 'css'], // Run the build command with an extra argument to // View the bundle analyzer report after build finishes: // `npm run build --report` // Set to `true` or `false` to always turn it on or off // 是否展示webpack构建打包之后的分析报告 bundleAnalyzerReport: process.env.npm_config_report &#125;, // 开发过程中使用的配置 dev: &#123; // 环境变量 env: require('./dev.env'), // dev-server监听的端口 port: 8080, // 是否自动打开浏览器 autoOpenBrowser: true, // 静态资源文件夹 assetsSubDirectory: 'static', // 发布路径 assetsPublicPath: '/', // 代理配置表，在这里可以配置特定的请求代理到对应的API接口 // 例如将'localhost:8080/api/xxx'代理到'www.example.com/api/xxx' proxyTable: &#123;&#125;, // CSS Sourcemaps off by default because relative paths are \"buggy\" // with this option, according to the CSS-Loader README // (https://github.com/webpack/css-loader#sourcemaps) // In our experience, they generally work as expected, // just be aware of this issue when enabling this option. // 是否开启 cssSourceMap cssSourceMap: false &#125;&#125;config/dev.env.js、config/prod.env.js和config/test.env.js这三个文件就简单设置了环境变量而已，没什么特别的。五、总结到这里对模板项目的build和config文件夹下面的内容已经基本了解，知道了在实际使用中根据自己的需求修改哪里的配置，例如，当我有需要配置代理的时候要在config/index.js里面的dev.proxyTable设置，当我修改了资源文件夹名称static同样需要在config/index.js里面设置。webpack的插件好多，在看代码的过程中遇到不认识的插件都是要去查看很多文档（github，npm或者博客），感觉实际过程中更改插件配置或者使用新插件也是需要费点心思钻文档和网上其他博客介绍。","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://hongchh.github.io/tags/Web/"}]},{"title":"记一个Vue项目的开发历程","slug":"记一个Vue项目的开发历程","date":"2017-01-26T07:54:15.000Z","updated":"2017-11-11T10:00:55.187Z","comments":true,"path":"2017/记一个Vue项目的开发历程/","link":"","permalink":"https://hongchh.github.io/2017/记一个Vue项目的开发历程/","excerpt":"","text":"项目地址 https://github.com/hongchh/timeline-x一、成品展示二、项目需求添加每一天的时间记录，修改某天的时间记录（因为可能记错或者忘了记某项活动）每天的记录可以有多项活动，每项活动有对应的时间每项活动划分到特定的类型12342016-01-20，星期五1. 学习Vue, 5h，[学习]2. 跑步，0.5h，[运动]3. 看霹雳布袋戏，2h，[休闲]2、数据分析按照月份统计每天的总时间，按照年份统计每月的总时间，按照分类统计各项内容的总时间以图表形式展示月份时间支出和年份时间支出的变化情况以图表形式展示各种类型的活动的时间支出情况计算总时间和平均时间3、时光展示时光轴形式进行活动记录展示，便于回顾总结轮播图形式进行活动记录展示，便于回顾总结4、数据模型1234567891011&#123; \"items\": [&#123; \"content\": \"string\", \"time\": \"number\", \"type\": \"string\" &#125;], \"year\": \"number\", \"month\": \"number\", \"date\": \"number\", \"day\": \"number\"&#125;数据示例12345678910111213141516171819&#123; \"items\": [&#123; \"content\": \"学习Vue\", \"time\": \"5\", \"type\": \"学习\" &#125;, &#123; \"content\": \"跑步\", \"time\": \"0.5\", \"type\": \"运动\" &#125;, &#123; \"content\": \"看霹雳布袋戏\", \"time\": \"2\", \"type\": \"休闲\" &#125;], \"year\": \"2016\", \"month\": \"01\", \"date\": \"20\", \"day\": \"5\"&#125;三、开发思路1、界面构成整个应用分成2个主要界面：【主界面】，【权限界面】【权限界面】用于用户登录，也是应用的启动界面【主界面】包含3个子界面：【管理】，【时光轴】，【时光展】【时光轴】和【时光展】用于时光展示【管理】用于展示数据分析结果以及编辑时光记录（添加/修改）2、跳转关系【权限界面】验证成功之后跳转到【主界面】【主界面】默认展示【时光轴】界面【主界面】顶栏可以选择跳转到【管理】、【时光轴】或【时光展】界面【主界面】顶栏选择“锁屏”之后回到【权限界面】3、组件划分1234567891011└─App：挂载整个应用 ├─Auth：【权限界面】 │ └─StarFlow：【权限界面】底部的动画 └─Main：【主界面】的基本结构 ├─Management：【管理】 │ ├─TimeAnalysisPerMonth：月份时间分析组件 │ ├─TimeAnalysisPerYear：年份时间分析组件 │ ├─TimeAnalysisByType：分类时间分析组件 │ └─EditTimeRecord：时间记录编辑组件 ├─Timeline：【时光轴】 └─TimeSlide：【时光展】4、文件结构123456789101112131415161718└─build：构建用到的相关文件├─config：构建的配置文件├─server：应用的服务器源码│ ├─controller：服务端业务逻辑│ ├─model：数据存储逻辑│ ├─static：静态文件│ ├─views：应用的视图文件│ ├─app.js：express服务器配置文件│ └─server.js：服务器启动文件├─src：前端开发源码│ ├─assets：图片等静态资源│ ├─components：前端组件│ ├─router：前端路由│ ├─store：vuex的store│ ├─App.vue：应用的外层结构│ └─entry.js：应用的入口文件└─static：前端开发过程中用到的静态文件 └─data：存放伪数据以及伪数据生成器四、开发历程1、基础配置使用vue-cli生成一个webpack项目模板1vue init webpack timeline-x生成之后为了支持jade+sass开发，还需要安装相关的依赖123npm install node-sass --save-devnpm install sass-loader --save-devnpm install jade --save-dev配置完成之后我们就可以在项目中使用jade和sass来进行开发了，.vue文件的模板如下，注意在template标签和style标签里面使用lang属性说明jade和sass。123456789101112131415&lt;template lang=&quot;jade&quot;&gt;div#auth h1 Auth Page&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;auth&apos;&#125;&lt;/script&gt;&lt;style lang=&quot;sass&quot;&gt;#auth border: 1px solid red&lt;/style&gt;2、准备组件按照之前划分好的组件，在src/components文件夹里面准备好相关文件。暂时不需要写入各组件的内容，就按照上面的模板一样写个标题说明这是哪个组件即可。3、配置路由组件都准备好之后安装路由1npm install vue-router --save安装完成之后需要在使用路由的时候将其导入，我这里选择在router/index.js文件里面导入。1234import Vue from 'vue'import Router from 'vue-router'Vue.use(Router)按照前面确定好的页面跳转关系配置路由信息，然后测试界面跳转是否正常。1234567891011121314151617const router = new Router(&#123; mode: 'history', routes: [ &#123; path: '/auth', component: Auth &#125;, &#123; path: '/main', component: Main, children: [ &#123; path: 'management', component: Management &#125;, &#123; path: 'timeline', component: Timeline &#125;, &#123; path: 'time-slide', component: TimeSlide &#125;, &#123; path: '', redirect: 'timeline' &#125; ] &#125;, &#123; path: '/', redirect: '/auth' &#125; ]&#125;)4、组件设计UI方面使用了一些element-ui的组件，因此还需要先安装element-ui。同样地安装之后需要导入，导入方法类似之前的vue-router。注意这里还需要导入element-ui的样式文件index.css。1npm install element-ui --save12345import Vue from 'vue'import ElementUI from 'element-ui'import 'element-ui/lib/theme-default/index.css'Vue.use(ElementUI)3个时间分析图表使用的是echarts，需要先安装echarts。安装之后import需要用到的图表就行了，这样经过webpack构建之后的产品代码就只有用到的图表的那部分代码了，可以较少产品代码体积。1npm install echarts --save由于我只用到了柱状图和圆饼图，然后图表上面还使用了标题和提示等组件，所以只需要在entry.js里面导入这些组件即可。12345import 'echarts/lib/chart/pie'import 'echarts/lib/chart/bar'import 'echarts/lib/component/tooltip'import 'echarts/lib/component/title'import 'echarts/lib/component/legend'到步骤【2】准备好的文件里面开始编写组件。在template标签中编写组件的HTML结构，然后在style标签中调节样式，业务逻辑则是放在script标签中。下面我用Auth.vue来作为例子，其他组件请参考github仓库里面的代码。权限界面比较简单（参考上面的成品展示图），HTML结构如下，使用element-ui的栅格布局，同时用了另外一个动态背景组件star-flow。123456789div#auth star-flow div#auth-input el-row(:gutter=&quot;20&quot;) el-col(:span=&quot;8&quot;, :offset=&quot;8&quot;) el-tooltip(:disabled=&quot;disabled&quot;, :content=&quot;errorTip&quot;, placement=&quot;bottom-start&quot;, effect=&quot;light&quot;) el-input(placeholder=&quot;请输入密码&quot;, v-model=&quot;password&quot;, type=&quot;password&quot;) template(slot=&quot;append&quot;) el-button(@click=&quot;signin&quot;) Go样式如下，设置一下背景图、宽高度之类的。1234567891011#auth width: 100% height: 100% background: url(../../assets/auth-bg.jpg) no-repeat background-size: 100% 100% background-attachment: fixed #auth-input position: absolute width: 100% height: 10% top: 45%下面是js部分了，使用es6的写法，为了使用另一个组件，需要先将其import进来然后添加到components里面。export是将当前的组件导出，其他模块才能使用到。data里面写该组件用到的数据项，methods则是这个组件里面需要的方法函数了。（有点类似angular的controller）1234567891011121314151617181920212223242526272829303132333435import StarFlow from './StarFlow'export default &#123; name: 'auth', components: &#123; StarFlow &#125;, data () &#123; return &#123; password: '', disabled: true, errorTip: '' &#125; &#125;, methods: &#123; setTip (tip) &#123; // 消息提示，1.5秒后自动关闭 this.errorTip = tip this.disabled = false setTimeout(() =&gt; &#123; this.disabled = true this.errorTip = '' &#125;, 1500) &#125;, signin () &#123; // 验证密码解除锁屏 if (!this.password) &#123; this.setTip('密码不能为空') &#125; else &#123; this.$store.dispatch('unlockScreen', this.password) .then((err) =&gt; &#123; if (err) this.setTip('密码错误') else this.$router.replace('/main') &#125;) &#125; &#125; &#125;&#125;5、改善UI调整组件的样式，并且改进应用的样式，添加过渡动画。过渡动画直接在router-view外面套一个transition，然后编写相应的过渡样式即可，很简便。6、数据状态管理该项目由6个组件需要用到同一份数据，1个记录编辑组件、2个时光展示组件和3个数据分析组件。为了方便数据管理，同时也好制造机会学习Vuex，因此我这里引入vuex来进行应用的状态管理。安装vuex，然后在store/index.js里面导入vuex。1npm install vuex --save1234import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)定义1个store存放应用的全局状态：锁屏变量和时间记录。默认开启锁屏，所以lockScreen设置为true，而timeRecords则是一个时间记录数据，里面包含多条记录。这些数据在应用启动接触锁屏之后向服务器获取，在还没有开发服务器的时候，为了完成前端开发可以先在这里写一些伪数据进去。12345678const store = new Vuex.Store(&#123; state: &#123; lockScreen: true, timeRecords: [] &#125;, mutations, actions&#125;)在store/actions.js和store/mutations.js里面定义这些全级状态可能发生的变化。如果涉及到异步操作，则将这些涉及异步的变化放到actions.js里面，例如向服务器获取数据这个操作就是一个异步的，应该将其代码放在action里面。根据Vuex文档的介绍，mutation的代码必须要是同步的。由于涉及跟服务器的交互，所以我们还需要一个提供http服务模块。上网查了查，有vue-resource这个东西可以用，不过好像更推荐使用axios，因此我这里也选择使用axios。下面进行安装和导入。1npm install axios --save1import axios from 'axios'准备好了之后可以开始编写了，下面是actions.js的代码，其他代码请参考github仓库。实现了后台交互功能，然后通过commit相应的mutation来更新store里面的状态。注释部分的代码是在前端开发还没有服务器的时候使用的开发代码。12345678910111213141516171819202122232425262728293031323334353637383940414243export default &#123; unlockScreen (&#123;commit&#125;, password) &#123; // 验证密码，接触锁屏 // 使用\"npm run dev\"启动时候请解除下面代码的注释，注释后面的POST代码 // return new Promise((resolve, reject) =&gt; &#123; // commit('UNLOCK') // resolve(false) // &#125;) return axios.post('/api/check', &#123; password: password &#125;).then((res) =&gt; &#123; if (!res || res.status !== 200 || res.data.err) &#123; return true &#125; else &#123; commit('UNLOCK') return false &#125; &#125;) &#125;, addRecord (&#123;commit&#125;, record) &#123; // 添加记录 // 使用\"npm run dev\"启动时候请解除下面代码的注释，注释后面的POST代码 // return new Promise((resolve, reject) =&gt; &#123; // commit('UPDATE_RECORD', record) // resolve(false) // &#125;) return axios.post('/api/add', record).then((res) =&gt; &#123; if (!res || res.status !== 200 || res.data.err) &#123; return true &#125; else &#123; commit('UPDATE_RECORD', record) return false &#125; &#125;) &#125;, fatchData (&#123;commit&#125;) &#123; // 获取数据 axios.get('/static/data/data.json').then((res) =&gt; &#123; if (res.status === 200) &#123; commit('FATCH_DATA', res.data) &#125; &#125;) &#125;&#125;7、准备伪数据为了让应用有更多数据可以呈现，需要自行编造一些伪数据，我写了一个伪数据生成器，即static/data/data-generator.js。运行之后产生100多条时间记录并存放到json文件里面。具体请参考github仓库。8、完善锁屏实现锁屏功能其实不难，只要在权限界面检验之后更新store里面的锁屏状态为false，在主界面点击顶栏的锁屏之后更新store里面的锁屏状态为true即可。但为了更完善，还需要在路由里面设置一个全局钩子，在进入相应界面之前检查一下store的锁屏状态，例如，在访问主界面的时候需要检查store里面的锁屏状态是否为true，如果是的话强行给它重定向到权限界面，因为这可能是用户通过手动修改URL来访问的。这里有一个坑，在router的全局钩子里面访问不到store里面的状态。在stack-overflow里面找到了这个解决方案，把store也给import到router里面去，这样就可以访问到了。不知道有没有其他更优秀的方案，欢迎交流。12345678910111213import store from '../store'router.beforeEach((to, from, next) =&gt; &#123; // 对特定路径进行验证，增强锁屏功能 if (to.path === '/') &#123; next('/auth') &#125; else if (to.path === '/auth' &amp;&amp; !store.state.lockScreen) &#123; next('/main') &#125; else if (to.path !== '/auth' &amp;&amp; store.state.lockScreen) &#123; next('/auth') &#125; else &#123; next() &#125;&#125;)9、后台开发前端开发基本完成之后就可以开始后台开发了，我后端使用的是express框架，按照MVC模式进行开发。由于本项目关注的是前端开发，所以后端就写得比较简单，也没有用上数据库，没有什么好讲的。主要有一点需要注意，为了方便，我更改了build的目标路径。用vue-cli生成的webpack项目build之后是在主目录下面生成一个dist文件夹来存放产品文件，我将其改成build之后静态文件放到server里面的static文件夹，而index.html则放到server里面的views文件夹，这样就不用手动去搬dist里面的文件给服务器用了。改动很简单，只需要该config/index.js里面的7-8行即可。12index: path.resolve(__dirname, '../server/views/index.html'),assetsRoot: path.resolve(__dirname, '../server'),10、前后对接对接前端和后台的接口，调整代码，修正bug。如果一开始将接口想清楚、设计好的话这里基本没有什么难。本项目只有2个post数据和1个get数据的接口，没有难度。11、改进，修正小问题五、结束大概用了5天写这个项目，基本入门了Vue，还是一次蛮不错的体验。为了多点练习强行加入了vuex，虽然官方推荐不要在小项目里面使用vuex，但我觉得引入vuex之后还是可以解决很多问题，思路也清晰了很多。在用vuex之前的想法是在一个外层的组件里面获取数据然后传递给子组件。后来发现如果我在编辑记录组件里面更新或者添加了一条记录，父组件和其他兄弟组件的数据不会收到更新。如果通过$emit来让父亲组件更新数据然后再使得兄弟组件更新，整个过程又太过繁琐。而Vuex的思路是弄一个全局状态来对数据进行管理，组件树上的组件都可以更新状态，状态变化之后会反馈到相应的其他组件上。这个思路很清晰，代码写起来也很顺利，也体验了vuex的强大，确实可以省事很多。部分内容可能无法讲得很清楚，有兴趣了解的话请参考github仓库的代码和commit记录。下面说说几点收获：es6写起来感觉超棒webpack比gulp优雅vue值得尝试","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://hongchh.github.io/tags/Web/"}]},{"title":"【动态规划】从子集和问题到背包问题","slug":"【动态规划】从子集和问题到背包问题","date":"2016-12-22T02:32:02.000Z","updated":"2017-11-11T09:46:03.550Z","comments":true,"path":"2016/【动态规划】从子集和问题到背包问题/","link":"","permalink":"https://hongchh.github.io/2016/【动态规划】从子集和问题到背包问题/","excerpt":"","text":"一、问题定义有一个包含n个元素{e1, e2, ..., en}的集合S，每个元素ei都有一个对应的权值wi。现在有一个界限W，我们希望从S中选择出部分元素，使得这些元素的权值之和在不超过W的情况下达到最大，这个便是子集合问题（事实上还有其他类型的子集和问题，本文暂不讨论）。举个更具体一点的例子，某农民今年收成小番茄总重量为W万斤，有n个采购商想要向这位农民收购小番茄，他们想要采购的数目都有所不同，采购商i想要收购wi万斤小番茄(1 &lt;= i &lt;= n)。现在农民需要从采购商中挑选部分买家，将小番茄卖给他们，使得自己被收购的小番茄数目达到最大，从而赚取最大的收入（假设所有采购商给出的单位收购价都是一样的；所有采购商的收购量总和超过农民的收成量，即农民无法满足所有采购商；收购商i想要收购wi万斤小番茄，他不会只收购一半或者更多）。二、解决思路根据动态规划的思路，我们来分析一下这个问题的子问题。假设农民已经从前面n-1个收购商中选出了一组最优组合使得收购量最大，现在他要考虑是否要卖给最后一个收购商n。假如卖给收购商n，那么他能够卖给前面n-1个收购商的番茄就只有(W-wn)万斤。如果他不卖给收购商n，那么他能够卖给前面n-1个收购商的番茄就是W万斤了。于是，假设在只有(W-wn)万斤的情况下，从前面n-1个收购商中选出最优组合所收购的总重量加上卖给收购商n的重量为(O1+wn)。若W万斤都卖给前面n-1个收购商，他们之中选出的最优组合所收购的总重量为O2。农民需要考虑的问题就变成了比较(O1+wn)和O2的大小了。我们更形式化一点地进行描述，假设O(i, w)表示将w万斤小番茄提供给收购商{1, 2, ..., i}收购的时候，从这i个收购商中选出最优组合所收购的总重量。那么O1 = O(n-1, W-wn)，O2 = (n-1, W)。当农民考虑收购商n的时候，他需要判定O1和O2的大小。另外一种特殊情况，当收购商收购的数量wn超过农民拥有的所有小番茄的时候，即W &lt; wn，那么农民自然只能考虑前面n-1个收购商中的最优组合了。更进一步考虑，当我们考虑O(i, w)的时候，如果w能够容纳wi，那么我们需要考虑O(i-1, w)和(O(i-1, w-wi) + wi)的大小。如果w无法容纳wi，即w &lt; wi，那么无需考虑i，O(i, w) = O(i-1, w)。因此，我们可以得到递推公式如下所示：12if w &lt; wi, O(i, w) = O(i-1, w)else O(i, w) = max(O(i-1, w), wi + O(i-1, w-wi))得到了递推公式，我们自然就可以得到一个算法来算出最优解。算法的伪代码如下所示：12345678910111213数组O[0...n, 0...W]for w = 0, 1, ..., W 初始化O[0, w] = 0endForfor i = 1, 2, ..., n for w = 0, ..., W if w &lt; wi O[i, w] = O[i-1, w] else O[i, w] = max(O[i-1, w], wi + O[i-1, w-wi]) endForendForO[n, W]即为最优解算法实际上是实现了一个填表的过程，填了一张n*W的二维表格。整个算法的时间复杂度为O(nW)，显而易见，当W的值变得很大的时候，这个算法的效率堪忧。现在暂时抛开效率问题，我们发现，上面给出的算法只能算出最优解的值，但是并没有给出所选择的子集合。即农民用这个算法之后只知道他最多能卖多少小番茄，但还是不知道要卖给哪些收购商。为了解决这个问题，我们只需要反向搜索一下数组O即可在O(n)的时间内找出最优解的元素组合情况。反向搜索的时候，如果O(i, w)等于O(i-1, w)，说明i没有被选择，继续对前面i-1个元素考虑重量为w时候的情况。如果O(i, w)不等于O(i-1, w)的话，说明选择了i，然后接着就应该继续对前面i-1个元素考虑重量为(w-wi)时候的情况，具体的伪代码如下所示：12345678910初始化i = n, w = Wwhile i != 0 do if O[i, w] == O[i-1, w] i = i-1 else print i i = i-1 w = w-wi endIfendWhile三、代码实例下面给出一个简单的C++代码实现，代码后面还附带有简单的示例。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int MAX_NUM = 100;const int MAX_WEIGHT = 1000;class SubSetProblem &#123;public: void init(int n, int W) &#123; this-&gt;n = n; this-&gt;W = W; memset(optional, 0, sizeof(optional)); for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; weight[i]; &#125; &#125; void process() &#123; for (int i = 1; i &lt;= n; ++i) &#123; for (int w = 0; w &lt;= W; ++w) &#123; if (w &lt; weight[i]) &#123; optional[i][w] = optional[i-1][w]; &#125; else if (optional[i-1][w] &lt; weight[i] + optional[i-1][w-weight[i]]) &#123; optional[i][w] = weight[i] + optional[i-1][w-weight[i]]; &#125; else &#123; optional[i][w] = optional[i-1][w]; &#125; &#125; &#125; &#125; void result() &#123; cout &lt;&lt; \"[Select]\"; for (int i = n, w = W; i != 0; --i) &#123; if (optional[i][w] == optional[i-1][w]) &#123; continue; &#125; else &#123; cout &lt;&lt; ' ' &lt;&lt; i; w -= weight[i]; &#125; &#125; cout &lt;&lt; \"\\n[Optional] \" &lt;&lt; optional[n][W] &lt;&lt; endl; &#125;private: int n, W; int weight[MAX_NUM + 1]; int optional[MAX_NUM + 1][MAX_WEIGHT + 1];&#125;;int main() &#123; SubSetProblem ssp; int n, W; cin &gt;&gt; n &gt;&gt; W; if (n &gt; MAX_NUM || W &gt; MAX_WEIGHT) &#123; cout &lt;&lt; \"error\" &lt;&lt; endl; return -1; &#125; ssp.init(n, W); ssp.process(); ssp.result(); return 0;&#125;输入输出示例：12343 62 2 3[Select] 3 1[Optional] 5四、背包问题把上面的子集和问题拓展一下，就变成了我们常见的背包问题了。问题定义：有一个包含n个元素{e1, e2, ..., en}的集合S，每个元素ei都有一个对应的权值wi和一个对应的价值vi。现在有一个界限W，我们希望从S中选择出部分元素，使得这些元素的权值之和在不超过W的情况下，所有元素的价值总和达到最大。继续拿上面的农民买小番茄的例子来讲，假设现在每个收购商的出价都有所不同，收购商i打算收购wi万斤小番茄，出价vi。农民只有W万斤能够提供给收购商，他希望合理选择收购商，使得卖小番茄的收益达到最大。这个问题看起来跟前面的子集和问题很像，解决思路也是基本一样。同样地，农民在考虑收购商n的时候，他需要考虑两个子问题。第一，如果把W万斤小番茄全部拿来提供给前面的n-1个收购商，他能拿到的最大收益为O(n-1, W)。第二，如果先出售部分小番茄给收购商n，剩下的再提供给前面n-1个收购商，他能拿到的最大收益为(O(n-1, W-wn) + vn)。于是，只要O(n-1, W)的价值更大，农民自然不会考虑收购商n，否则他肯定要先出售部分小番茄给收购商n。最后，考虑特殊情况，当收购商n的收购量超过农民所能提供的小番茄时，农民也就只能将W万斤小番茄提供给前面n-1个收购商了。假设O(i, w)表示农民将w万斤小番茄提供给前i个收购商所能赚取的最大收益，按照之前讲解子集和问题的思路，我们可以得到递推公式如下：12if w &lt; wi, O(i, w) = O(i-1, w)else O(i, w) = max(O(i-1, w), vi + O(i-1, w-wi))可以看到，公式几乎跟之前的子集和问题一样。只不过，子集和问题中我们考虑的是重量w，而这里我们考虑的是价值v。两者本质上是同样的，只不过判定的标准变了而已。解决这种类型的背包问题的算法跟之前的一样，只需要将wi换成vi即可，最后反向搜索求解最优解的元素组合情况的做法也是与之前一样，代码相似度较高，所以下面我就不重复贴代码了。这个算法的时间复杂度也是O(nW)，反向搜索的时间复杂度为O(n)。算法缺陷也是跟之前一样，当W的值非常大的时候，算法效率低下。","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hongchh.github.io/tags/数据结构与算法/"}]},{"title":"服务器性能优化初探","slug":"服务器性能优化初探","date":"2016-11-15T13:30:46.000Z","updated":"2017-11-11T09:31:08.137Z","comments":true,"path":"2016/服务器性能优化初探/","link":"","permalink":"https://hongchh.github.io/2016/服务器性能优化初探/","excerpt":"","text":"前言本文将总结服务器性能优化的两种基本方法，反向代理和数据缓存，分别会使用到nginx和redis，关于反向代理和数据缓存的基础知识暂时不做介绍，本文将以图文并茂的形式详细地记录安装配置nginx和redis，以及使用它们来简单实现反向代理和数据缓存的过程。1、Nginx 安装与 Proxy 的配置nginx的安装过程如下，由于部分命令运行后的输出比较长(例如make)，截图比较麻烦，下面我记录了安装过程中更需要用到的命令。首先切换到root用户方便后续操作。接下来开始安装pcre库，安装的命令如下所示，安装完成后通过检查版本来判断是否安装成功。然后才是开始安装nginx，nginx的安装命令跟安装pcre的类似，最后也是通过检查版本来判断是否安装成功。12345678910111213141516$ sudo su# wget http://downloads.sourceforge.net/project/pcre/pcre/8.35/pcre-8.35.tar.gz# tar zxvf pcre-8.35.tar.gz# cd pcre-8.35# ./configure# make &amp;&amp; make install# pcre-config --version8.35# wget http://nginx.org/download/nginx-1.10.0.tar.gz# tar zxvf nginx-1.10.0.tar.gz# cd nginx-1.10.0# /configure --prefix=/usr/local/webserver/nginx --with-http_stub_status_module --with-http_ssl_module --with-pcre=/usr/local/src/pcre-8.35# make# make install# /usr/local/webserver/nginx/sbin/nginx -vnginx version: nginx/1.10.0安装完nginx之后，启动nginx，出现了以下错误。这是因为nginx默认是监听80端口，而我的Linux上80端口已经被其他程序占用了，解决办法很简单，到nginx的配置文件中修改端口即可，这里我改成了3000端口。继续启动nginx，在浏览器访问0.0.0.0:3000，看到如下页面，才能说明nginx的安装真的成功了，可以用了。完成nginx的安装之后。开始来写个简单的服务器方便后面测试。我使用NodeJS写了一个简单的服务器，代码如下所示，很简短（由于只是简单测试，所以就暂时不用Java这么庞大的东西了，方便说明实验过程）。它创建了4个服务器，分别监听8000、8001、8002、8003这四个端口。为了方便后面的测试，我设定每个服务器都响应不同的内容。监听8000端口的服务器对任何请求都响应文本&quot;There is Server-1.&quot;，监听8001端口的服务器响应文本&quot;There is Server-2.&quot;，以此类推。1234567891011121314151617181920212223242526272829var http = require('http');http.createServer((req, res) =&gt; &#123; res.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); res.end('There is Server-1.');&#125;).listen(8000, () =&gt; &#123; console.log('server listen on 8000');&#125;);http.createServer((req, res) =&gt; &#123; res.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); res.end('There is Server-2.');&#125;).listen(8001, () =&gt; &#123; console.log('server listen on 8001');&#125;);http.createServer((req, res) =&gt; &#123; res.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); res.end('There is Server-3.');&#125;).listen(8002, () =&gt; &#123; console.log('server listen on 8002');&#125;);http.createServer((req, res) =&gt; &#123; res.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); res.end('There is Server-4.');&#125;).listen(8003, () =&gt; &#123; console.log('server listen on 8003');&#125;);有了服务器之后我们可以开始来配置nginx了。主要有两个地方需要配置，如下截图。配置upstream，在里面加入4个服务器的IP地址和端口号。配置location，将请求转发到upstream配置的服务器上。完成配置之后就可以开始简单测试了。重启nginx，继续访问0.0.0.0:3000，如下截图所示，页面内容不再是刚才那个欢迎界面了，变成了NodeJS服务器提供的内容了。刷新几次页面，会发现页面的内容会发生变化，例如&quot;There is Server-1.&quot;变成&quot;There is Server-2.&quot;，说明nginx配置成功，能够正常工作。接下来继续探究nginx的负载分配策略。在重复刷新浏览器页面的时候，页面中数字的变化是大概是1、2、3、4这种顺序，大致可以猜想nginx默认是按照轮询的方式进行负载分配的。为了能够更具体地测试和统计相关数据，我用Python写了下面一个简单的爬虫程序。爬虫程序会访问0.0.0.0:3000，把响应的内容输出，根据响应内容判断响应是来自哪个服务器并统计次数，最后把统计结果输出。1234567891011121314151617181920212223242526import urlliburl = 'http://0.0.0.0:3000/'times = 100server1 = 0server2 = 0server3 = 0server4 = 0while times &gt; 0: text = urllib.urlopen(url).read() if (text[-2] == '1'): server1 += 1 if (text[-2] == '2'): server2 += 1 if (text[-2] == '3'): server3 += 1 if (text[-2] == '4'): server4 += 1 print(text) times -= 1print(\"Server-1: \" + str(server1))print(\"Server-2: \" + str(server2))print(\"Server-3: \" + str(server3))print(\"Server-4: \" + str(server4))通过调整程序中的times参数可以调整爬虫访问网站的次数，我进行了100次、1000次、10000次的测试，得到的结果如下。可以发现，四个服务器的访问次数都很均衡，所有请求都平摊到各个服务器上去了，这也说明了nginx可以很好地实现负载均衡。输出每个响应的内容得到的结果如下，由于输出实在太长了，所以我这里只做了部分截图。由输出可以看出，nginx默认的负载均衡策略确实是轮询，访问的顺序基本都是按照1、2、3、4、1、2、3、4、...顺序地访问。如何控制策略？修改均衡策略其实很简单，只要在配置文件中修改即可，下面是简单示例，将均衡策略改为按照权重分配，weight越大的服务器分配到的负载越大，最后标注backup的服务器只有等到其他非backup服务器忙或者down的时候才会使用。123456upstream nodeservers &#123; server 127.0.0.1:8000 weight = 1; server 127.0.0.1:8001 weight = 2; server 127.0.0.1:8002 weight = 3; server 127.0.0.1:8003 backup;&#125;什么是session stiky？是指当用户发出第一个request后，负载均衡器动态的把该用户分配到某个节点，并记录该节点的路由，以后该用户的所有request都会被绑定这个路由，用户只会与该服务器发生交互，使得session不会丢失。不采用session stiky的话可能造成用户session丢失，而session丢失的话就会带来很多问题，比如用户登录状态丢失等问题。如果不用session stiky的话可以使用session复制的方法来解决，即在多个节点之间复制session，实现不同服务器之间的用户状态同步。2、Redis 安装redis的安装过程如下，比较简单。下载tar包解压之后通过makefile编译，完成之后在src文件夹下即可找到服务器和客户端两个可执行程序，redis.conf是配置文件。到这里算是完成了，可以自己再把它们添加到环境变量，就不用每次都进来src文件夹下面启动程序了。1234567$ wget http://download.redis.io/releases/redis-3.2.5.tar.gz$ tar xzf redis-3.2.5.tar.gz$ cd redis-3.2.5$ make$ cd src$ ./redis-server redis.conf$ ./redis-cli启动redis服务器，如下所示。看到以下输出说明安装成功，能够正常启动服务器。我们再启动一个客户端，使用redis cli命令启动。如下所示，启动之后输入ping进行测试，输出PONG的话表明服务器能够正常工作，客户端可以连接到服务器。在redis-cli下面我们可以直接对服务器进行配置，下面截图简单演示了配置的过程。其实就是简单地输入一下配置命令，没有什么特别的地方。还有另外一种方式是通过修改redis.conf文件来进行配置。然后是操作主要类型的数据。下面我在redis-cli下面使用命令简单操作了string、hashmap、set这几种数据类型，其他数据类型的操作基本相似，就只是命令不同而已，查阅文档之后可以很顺利完成。最后，简单了解了一下Redis Sentinel的知识。Redis-Sentinel是Redis官方推荐的高可用性(HA)解决方案，当用Redis做Master-slave的高可用方案时，假如master宕机了，Redis本身(包括它的很多客户端)都没有实现自动进行主备切换，而Redis-sentinel本身也是一个独立运行的进程，它能监控多个master-slave集群，发现master宕机后能进行自动切换。它的主要功能有以下几点：不时地监控redis是否按照预期良好地运行;如果发现某个redis节点运行出现状况，能够通知另外一个进程(例如它的客户端);能够进行自动切换。当一个master节点不可用时，能够选举出master的多个slave(如果有超过一个slave的话)中的一个来作为新的master,其它的slave节点会将它所追随的master的地址改为被提升为master的slave的新地址。大概知道了Redis Sentinel是个什么东西，关于如何配置Sentinel，这里暂时不做深究。3、共享数据缓存在实验1的基础上，每个应用都使用同一 Redis 缓存，验证数据共享。首先将实验1中的代码进行小小修改，让它支持redis。修改代码后，服务器接收到请求之后会先检查redis里面是否有&quot;tmp_string_key&quot;的缓存，如果有的话就将其值读取出来响应给客户端，没有的话就设置一个。下面截取的是服务器1的代码，其他3个服务器的代码也是类似的改法。然后启动redis服务器、启动实验服务器、启动nginx。继续使用之前的爬虫来进行验证。输出的信息如下，所有的服务器相应的文本内容都是服务器4缓存的值，证明缓存数据是共享的。即第一次请求被转发到服务器4，然后服务器4设置了一个缓存键值对，后续不管请求被转发到哪个服务器，都会共享使用这个键值对，所以爬虫每次请求得到的内容都是一样的。实验到此结束。","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://hongchh.github.io/tags/Web/"}]},{"title":"NodeJS基础API搭建服务器详细过程记录","slug":"NodeJS基础API搭建服务器详细过程记录","date":"2016-11-14T12:45:50.000Z","updated":"2018-04-16T07:51:04.344Z","comments":true,"path":"2016/NodeJS基础API搭建服务器详细过程记录/","link":"","permalink":"https://hongchh.github.io/2016/NodeJS基础API搭建服务器详细过程记录/","excerpt":"","text":"前言在习惯了使用express框架，jade模板引擎等现成工具来写代码之后，很多人对于基本的NodeJS API会慢慢生疏。本文将以一个超小型web项目，来详细介绍如何使用NodeJS基础的http, fs, path, url等模块提供的API来搭建一个简单的web服务器。当做对NodeJS的一次复习，也为初学NodeJS的开发者提供一个参考。本文所搭建的项目将不会使用express等后端框架，仅使用最基础的NodeJS API，按照MVC设计模式的思路进行编码和讲解，交流意见。源代码地址如下，建议下载源码边看博客边对照源码才能比较快理解整个过程。源码地址simple-http-server项目介绍有一个简单的食品店网站，它包括一个主页index和一个详情页detail。主页展示食品店的所有食品，包括食品图片、名称、价格3个信息，如下图所示。用户点击任何一项食品就会跳转到对应的详情页，包括食品图片、名称、价格和描述4个信息，如下图所示。项目结构项目的文件结构如下所示。1234567891011121314151617181920node-example |--data(存放项目数据的文件夹) |--detail.json(存放食品详情数据) |--foods.json(存放首页食品数据) |--model(提供访问和操作数据服务的数据模型) |--detail.js(详情数据访问模块) |--foods.js(食品数据访问模块) |--public(存放css,js,图片等静态文件) |--css(存放css文件的文件夹) |--img(存放图片的文件夹) |--js(存放js文件的文件夹) |--route(路由，控制器) |--api(处理普通请求的路由，或者叫控制器) |--static(处理静态文件请求的路由，或者叫控制器) |--views(视图，即用户界面) |--index.html(主页界面) |--detail.html(详情页面) |--server.js(服务器启动文件) |--package.json(项目包信息) |--README.md(项目信息以及启动方法描述)本文只讲解服务端编程，因此两个简单界面的实现过程这里就不再啰嗦了。假设你已经能够自行完成前端的界面编程，下面开始讲解服务端编程。编写服务器server.js中要完成服务器的创建和启动，并将请求转发给相应的路由去处理。详细代码如下所示（假设我们已经有了能够正常工作的路由，这里采用Top-Down的思路，我们一层一层地往下写，专注于解决每个层次的问题）。代码中使用正则表达式来判定客户端request是否是在请求静态文件，如果是，则交给专门处理静态文件请求的路由static去处理，否则交给普通请求的路由器api去处理。普通请求根据它的HTTP方法来判断使用get或者post。最后，设置服务器监听3000端口，server.js的代码就算完成了。1234567891011121314151617181920var http = require('http');var url = require('url');var api = require('./route/api');var static = require('./route/static');// 匹配静态文件夹路径的正则表达式，用于判定请求是否为静态文件请求var staticExp = /\\/public\\/(img|css|js)\\/[a-z]*\\.(jpg|png|gif|css|js)/;http.createServer((req, res) =&gt; &#123; var pathname = url.parse(req.url).pathname; if (staticExp.test(pathname)) &#123;// 静态文件请求交由static处理 static.get(__dirname + pathname, res); &#125; else if (req.method == 'POST') &#123;// 处理普通post请求 api.post(req, res); &#125; else &#123;// 处理普通get请求 api.get(req, res); &#125;&#125;).listen(3000);console.log('[Server Info] Start server at http://localhost:3000/');编写路由我从简单的开始，先写处理静态文件请求的路由static。这个路由的逻辑很简单，只要客户端想要请求某个静态文件（css/js/图片），就将被请求的文件发送给客户端即可。代码如下所示。有以下几点需要注意的地方，首先，客户端请求文件，需要判断文件是否存在，如果存在才将其发送给客户端，不存在则作其他处理（这里我暂时没做其他处理）。其次，将文件响应给客户端的时候，需要设置好http报头的MIME type，这样文件发过去之后客户端才能识别出文件类型从而正确使用。最后，像图片、音频等多媒体文件需要用二进制的读写方式，所以在响应图片的时候记得加上&quot;binary&quot;。12345678910111213141516171819202122232425262728293031323334353637383940414243var fs = require('fs');var path = require('path');var MIME = &#123;&#125;;MIME[\".css\"] = \"text/css\";MIME[\".js\"] = \"text/js\";MIME[\".jpg\"] = \"image/jpeg\";MIME[\".jpeg\"] = \"image/jpeg\";MIME[\".png\"] = \"image/png\";MIME[\".gif\"] = \"image/gif\";function get(pathname, res) &#123; if (fs.existsSync(pathname)) &#123; var extname = path.extname(pathname); res.writeHead(200, &#123;'Content-Type': MIME[extname]&#125;); fs.readFile(pathname, (err, data) =&gt; &#123; if (err) &#123; console.log(err); res.end(); &#125; else &#123; if (isImage(extname)) &#123; res.end(data, \"binary\");// 二进制文件需要加上binary &#125; else &#123; res.end(data.toString()); &#125; &#125; &#125;); &#125;&#125;// 根据拓展名判断是否为图片function isImage(extname) &#123; if (extname === '.jpg' || extname === '.jpeg' || extname === '.png' || extname === '.gif') &#123; return true; &#125; return false;&#125;// 提供给其他模块使用的接口module.exports = &#123; get: get&#125;;static写完了，下面来继续写api。api需要根据请求的URL来响应对应的内容。例如客户端请求&quot;/&quot;，就响应它网站的主页，请求&quot;/detail?id=0&quot;就响应它id为0的食品的详情页面。如果客户端请求了不存在的URL，则给回一个404响应，表示没有找到。代码如下所示。这里我分了两个handler，本项目没有post操作，所以只有getHandler会使用到。给出postHanlder的目的是为了简单说明如何写处理客户端post请求的路由。以getHanlder[&#39;/&#39;]为例，当客户端请求&quot;/&quot;的时候，不是简单地把index.html响应给服务器这么简单，想象一下，一家食品店，每天提供的菜式可能会有所不同，或者因为季节问题而导致每个季节的特色菜都有所不同，所以我们网站主页展示的菜式也可能随之而变化。因此，我们需要根据数据库中存储的主页数据来动态渲染主页的内容。我把idnex.html写成模板，为了不使用jade等模板引擎，我在html里面使用如同&quot;&quot;这种形式的标记，当读取完模板之后，利用简单的字符串操作将标记替换成我们需要动态渲染的内容，即可实现动态渲染HTML的目的。静态文件之外的其他路由，或者叫控制器(controller)，一般都会包含业务逻辑，即业务逻辑一般是在这一层完成的。像上面的根据数据库内容动态渲染出首页，或者你在其他场景下面会见到的如登录注册的数据检验，成功登录之后将客户端重定向到对应的用户界面等等业务逻辑都是在这一层实现。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788var fs = require('fs');var url = require('url');var querystring = require('querystring');var foods = require('../model/foods')();var detail = require('../model/detail')();var getHandler = &#123;&#125;;var postHandler = &#123;&#125;;// 处理对主页的请求getHandler['/'] = function(req, res) &#123; var foodMenu = \"\"; // 拼装首页数据 var food = foods.getAllFoods(); for (var i = 0; i &lt; food.length; ++i) &#123; foodMenu += '&lt;div class=\"food-card\" id=\"' + food[i].id + '\"&gt;&lt;img src=\"'; foodMenu += food[i].image + '\"&gt;&lt;h1&gt;' + food[i].name + '&lt;/h1&gt;&lt;h2&gt;' + food[i].price + '&lt;/h2&gt;&lt;/div&gt;'; &#125; res.writeHead(200, &#123;\"Content-Type\": \"text/html\"&#125;); fs.readFile(__dirname + '/../views/index.html', (err, data) =&gt; &#123; if (err) &#123; console.log(err); res.end(); &#125; else &#123; // 动态渲染模板 res.end(data.toString().replace('&#123;&#123;foodMenu&#125;&#125;', foodMenu)); &#125; &#125;);&#125;;// 处理对详情页面的请求getHandler['/detail'] = function(req, res) &#123; var query = querystring.parse(url.parse(req.url).query); var foodDetail = detail.getDetail(query.id); res.writeHead(200, &#123;\"Content-Type\": \"text/html\"&#125;); fs.readFile(__dirname + '/../views/detail.html', (err, data) =&gt; &#123; // 动态渲染模板 res.end(data.toString().replace('&#123;&#123;image&#125;&#125;', foodDetail.image) .replace('&#123;&#123;name&#125;&#125;', foodDetail.name) .replace('&#123;&#123;description&#125;&#125;', foodDetail.description) .replace('&#123;&#123;price&#125;&#125;', foodDetail.price)); &#125;);&#125;;// 404响应，告知客户端资源未找到getHandler['/404'] = function(req, res) &#123; res.writeHead(404, &#123;\"Content-Type\": \"text/plain\"&#125;); res.end(\"404 Not Found\");&#125;;// post请求的处理方法示例postHandler['/'] = function(res, data) &#123; // do something&#125;;// get请求function get(req, res) &#123; var reqUrl = url.parse(req.url); if (typeof getHandler[reqUrl.pathname] === \"function\") &#123; getHandler[reqUrl.pathname](req, res); &#125; else &#123; getHandler[\"/404\"](req, res); &#125;&#125;// post请求（示例）function post(req, res) &#123; var reqUrl = url.parse(req.url); if (typeof postHandler[reqUrl.pathname] === \"function\") &#123; var postData = \"\"; req.on('data', (data) =&gt; &#123; postData += data; &#125;); req.on('end', () =&gt; &#123; postData = querystring.parse(postData); postHandler[reqUrl.pathname](res, postData); &#125;); &#125; else &#123; getHandler[\"/404\"](req, res); &#125;&#125;// 提供给其他模块使用的接口module.exports = &#123; get: get, post: post&#125;;最后，讲一下post方法的处理过程，虽然本项目中没有使用到post。post方法跟get方法最主要的不同之处在于post方法除了发送http头部信息之外还带有客户端提交的数据。在接收到post请求的时候，需要将数据读取出来，读取数据的方式也挺简单，只要给request设置监听器就行了。当request对象收到数据的时候会触发&quot;data&quot;事件，因此，给这个事件设置监听器，让它收到数据的时候就把数据保存起来。在接收完一个请求全部的post数据之后会触发”end&quot;事件，因此，给这个事件设置监听器，使得在接收完全部数据之后才开始对提交的数据进行相关的操作。编写数据模型先拿主页来讲吧。通过前面的截图，我们可以知道，主页上的数据包括展示菜品的图片、名称、价格，另外需要根据不同的菜品跳转到对应的详情页，因此还需要一个id来用作标识符。最后，可以得到如下的数据模型（下面的模型我使用json描述，你也可以采取其他办法）。这个数据模型描述了主页的数据模型，即首页有很多个食品foods，用数组表示，每个数据元素代表一个食品。每个食品包括四项信息，id，image，name，price。id的值是一个数字，作为唯一标识符。image是一个字符串，用来指明图片地址。name的值是字符串，表示食品的名字，price的值是一个字符串，表示食品的价格。12345678&#123; \"foods\": [&#123; \"id\": \"number\", \"image\": \"string\", \"name\": \"string\", \"price\": \"string\" &#125;]&#125;设计好数据模型的目的是方便我们设计伪数据，也方便我们对数据进行操作，一般在开始编程之前要做的事情就是设计好数据模型（数据结构），这样写程序时候才会更加顺利，很多接口才能规范下来。虽然我这里把model这一步放在了最后，但我这里model里面只是写了数据访问模块，不代表数据模型是最后才设计的，只是因为我这里讲解的思路是自定向下，刚好讲到model就顺带提一提数据模型设计。下面以foods.js为例来讲解如何编写model。代码如下所示。这里由于没有数据库（涉及数据库的话对于新手来说比较麻烦，为了讲清楚过程本文将不采用数据库存储数据），我将所有数据使用json文件存储，例如foods.json中存储了主页的所有食品的数据。foods model将对外提供接口，用于支持访问主页的食品数据，修改食品数据等操作（数据库常说的增删查改CRUD四个操作）。本项目只需要用到查询所有视频的操作，所以我这里简单实现了一个获取所有食品的方法，另外附带一个根据id获取单个食品的方法（这个方法仅是示例，没有用到）。12345678910111213141516171819202122232425var fs = require('fs');module.exports = function() &#123; // 读取文件中的数据，将其转成一个对象方便使用 var data = JSON.parse(fs.readFileSync(__dirname + '/../data/foods.json')); var foods = &#123; getAllFoods: getAllFoods, getFood: getFood &#125;; // 获取所有食品 function getAllFoods() &#123; return data.foods; &#125; // 根据id获取单个食品 function getFood(id) &#123; for (var i = 0; i &lt; data.foods.length; ++i) &#123; if (data.foods[i].id == id) return data.foods[i]; &#125; &#125; return foods;&#125;;model里面的模块一般提供数据操作的服务供控制器使用，所以在这一层就主要关注实现数据CRUD操作即可，基本没有什么业务逻辑了。照着写foods的思路，我们再把detail写完，整个项目就完成了。是不是挺简单的。进到项目目录下面，使用node server.js启动服务器跑一跑吧。最后，看完整个项目，你大概可以发现整个编写过程，或者说每个模块的划分，都好像遵照某种特定的模式在进行，其实我是按照MVC的模式来编写这个项目的，最近在另外一门学课的学习中也经常用到MVC，觉得还是挺不错的一种设计模式，有兴趣可以研究一下。当然，我不能说我写的代码完全符合MVC的规范，毕竟每个人的理解都可能有那么一些出入。本文仅供参考，欢迎交流建议，谢谢！","categories":[],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://hongchh.github.io/tags/NodeJS/"}]},{"title":"Construct-a-VPN-by-making-use-of-OpenVPN","slug":"Construct-a-VPN-by-making-use-of-OpenVPN","date":"2016-10-27T08:16:37.000Z","updated":"2017-11-11T06:02:08.582Z","comments":true,"path":"2016/Construct-a-VPN-by-making-use-of-OpenVPN/","link":"","permalink":"https://hongchh.github.io/2016/Construct-a-VPN-by-making-use-of-OpenVPN/","excerpt":"","text":"本文将图文并茂地介绍如何利用两台电脑搭建一个VPN。关于什么是VPN，VPN有什么作用等基础知识，本文暂时不作介绍。基本信息本次实验我使用了两台电脑来完成，一台电脑扮演VPN服务器，另一台则是客户端，下面是两台电脑的基本信息：服务器操作系统：Ubuntu 16.04客户端操作系统：Mac OS 10.12.1一、前期准备1、打开终端，为了方便后面的操作，先切换到root权限2、安装openvpn、libssl-dev、openssl和easy-rsa。下面是命令行示例截图，由于我之前已经安装过这几个软件了，所以下面提示这几个已经是最新版。3、创建文件夹/etc/openvpn/easy-rsa/，然后把文件夹/usr/share/easy-rsa/ 下面的内容复制到刚才创建的文件夹中。二、制作证书1、准备制作CA证书，首先编辑一下/etc/openvpn/easy-rsa/vars 文件。使用sublime编辑器编辑。主要根据自己个人情况修改下面几处信息。修改完保存之后使用source vars命令使其生效，顺便clean一下。2、创建CA证书。使用build-ca来创建，配置信息全部保持默认即可。创建完之后列出keys文件夹的文件，我们可以发现多了ca.crt和ca.key两个文件。最后把CA的证书复制到openvpn的启动目录/etc/openvpn下。3、制作服务器证书。使用./build-key-server [name]创建服务器证书，这里的[name]即我们在前面配置vars文件的时候填写在export KEY_NAME=”hongchhvpn”这里的名字。同样，创建的时候保持默认配置即可。创建完之后列出keys文件夹下面的文件，可以发现hongchhvpn.csr、hongchhvpn.crt、hongchhvpn.key几个文件。4、为服务器生成加密交换时的Diffie-Hellman文件，使用./build-dh创建。创建完成之后列出keys文件夹下的文件，可以发现多了dh2048.pem。5、将hongchhcpn.crt、hongchhcpn.key、dh2048.pem三个文件复制到openvpn的启动目录/etc/openvpn/下面。至此，服务端的证书制作完毕。下图中的vpnhongchh.*是我之前配置的另外一个VPN服务器的文件，忘记删了请忽略它。6、制作客户端证书。创建过程中的配置同样还是保持默认即可。创建完成之后列出keys文件夹，可以发现多了hongchh.crt、hongchh.csr、hongchh.key3个文件。三、配置服务器1、从openvpn自带的模版中复制服务器配置文件到openvpn的启动目录并进行解压然后再配置。使用sublime text编辑器打开配置文件，主要改动下面几个地方。把协议换成tcp协议，然后证书、密钥、dh这三个文件也相应地作修改。2、启动服务器。使用/etc/init.d/openvpn start 命令启动服务器，然后再用netstat -tunlp命令检查一下是否已经启动。如下面截图，我们可以看到1194端口上面运行着openvpn的进程，协议是tcp，说明服务器成功启动了。到这里，服务器算是搭建完成了。下面截图中你看到的是restart命令，其实是因为我前面启动了一次，现在重启一下截个图，效果一样。四、配置客户端前期准备1、在服务器这边先把相关证书准备好。把客户端证书和CA证书以及openvpn客户端的配置文件模版复制到/home/{user}下面。然后到/home/{user}目录下修改那几个文件的属性。2、退出root用户，回到home目录下，把这几个文件复制到客户端。直接拿U盘拷贝到另一台电脑即可。五、配置客户端1、在客户端上面对client.conf文件内容进行修改，改动项跟之前配置服务器的时候类似，把udp改成tcp，把证书和密钥文件也修改成相应的文件名，同时在remote那里加上服务器地址。2、下载安装Tunnelblick（Mac系统的一个openVPN客户端）。然后把刚才的client.conf配置文件拉进来，Tunnelblick会自动完成相应的配置。完成之后点击右下角的连接按钮即向VPN服务器发起连接。3、连接成功。连接成功之后在日志处会有相应的提示，在Tunnelblick的桌面小窗口也有更加直观的提示，包括流量信息等都有提示。4、使用ping命令，测试是否能ping通服务器。从前面连接成功的日志截图中可以看到连上VPN之后客户端分配到的IP为10.8.0.6，而服务器的IP地址为10.8.0.1（这里注意不是公网上面的IP，而是VPN虚拟专用网络上的IP，直接对公网IP进行ping可能不是正确的实验结果，因为你的电脑本来就可以访问到公网）。这里尝试对10.8.0.1执行ping指令。测试结果如下，可以ping通服务器，说明服务器与客户端之间的连通性良好，客户端与服务器之间可以通过VPN进行通信。到这里，利用openVPN进行VPN服务器与客户端配置的所有内容都已经完成，成功搭建了一个VPN服务器，并且通过客户端成功连接到了服务器，证明搭建的VPN是可用的，能够正常工作的，任务完成。","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"https://hongchh.github.io/tags/其他/"}]},{"title":"【动态规划】带权值区间调度问题","slug":"【动态规划】带权值区间调度问题","date":"2016-10-24T11:21:13.000Z","updated":"2017-11-11T05:35:26.049Z","comments":true,"path":"2016/【动态规划】带权值区间调度问题/","link":"","permalink":"https://hongchh.github.io/2016/【动态规划】带权值区间调度问题/","excerpt":"","text":"一、问题定义存在单一资源R，有n个需求{1, 2, ..., n}，每个需求指定一个开始时间bi与一个结束时间ei，在时间区间[bi, ei]内该需求想要占用资源R，资源R一旦被占用则无法被其他需求利用。每个需求i带有一个权值vi，代表该需求被满足之后能够带来的价值或者贡献。如果两个需求的时间区间不重叠，那么它们是相容的。带权值的区间调度问题即，对上面所描述的情境，求出一组相容子集S使得S中的区间权值之和最大。举个简单例子，某一款网络游戏近期举办了不少活动，玩家只要参加活动可以获得相应的奖励。每个活动都有对应的活动时间以及活动奖励，玩家在一个时间段之内只能参加一个活动，并且必须完整地参加一个活动才能获取奖励(即从活动开始到活动结束之间不能中断去参加其他活动)。假设现在有n个活动，部分活动的时间区间有重叠。某位精通算法的玩家希望通过计算确定合理的活动安排，使得自己获取的奖励最大化。二、解决思路继续以上面的游戏活动为背景。假设将活动按照它们的结束时间ei从早到晚进行排序。e1 &lt;= e2 &lt;= ... &lt;= en。排序之后我们会得到如下所示的活动顺序图。上图中的标记表示活动名称(活动1、活动2、…)，vi表示参加活动i能够收获的奖励，vi的值越大表示奖励越多。下面定义图中展示的p(j)。对于某个活动j，p(j)表示排在活动j之前的所有活动里面离j最近并且相容的活动，如果没有相容的活动，则p(j) = 0。例如p(3)，从图中可以看到，活动3前面只有活动2和活动1，而活动2跟活动3有区间重叠，不相容，只有活动1相容，因此p(3) = 1，代表活动3前面的所有活动中离它最近并且相容的活动是活动1。我们要解决的问题是选择一组最优活动组合使得所有活动奖励之和最大。这里再定义一个概念，OPT(n)，表示从n个活动{1, 2, ..., n}中能够获取到的最大奖励。假设我们已经从{1, 2, ..., n-1}中选取出一组最优活动组合，使得最大活动奖励为OPT(n-1)。现在要来考虑是否要参加活动n，这个时候有两种选择策略：第一，参加活动n。要参加活动n的话必须去掉{1, 2, ..., n-1}中所有跟n冲突的活动。也就是说，我们只能从活动{1, 2, ..., p(n)}中选取要参加的活动组合，而活动{p(n)+1, p(n)+2, ..., n-1}则全部不能选择，因为它们都跟活动n冲突了（回顾前面p(j)的定义）。那么这个时候选择参加活动n之后，我们会得到新的活动组合，这个组合的奖励之和会变成OPT(p(n)) + vn，即从活动{1, 2, ..., p(n)}中能够获取的最大奖励再加上活动n的奖励。第二，放弃活动n，这种情况下计算活动奖励就很简单了，选择参加的活动组合没有发生变化，故奖励仍是从{1, 2, ..., n-1}中能够获取的最大奖励OPT(n-1)。我们的目的是求取一个最优的活动组合使得奖励最大化，因此，只需要考虑上面两种选择哪一种的奖励更多即可，奖励越多的选择越优秀。如果OPT(p(n)) + vn的值更大，选择参加活动n，放弃跟n冲突的其他活动。如果OPT(n-1)更大，那么放弃活动n，继续保留原来选定的活动组合。于是我们很容易可以得到下面的递推公式：1OPT(j) = max(OPT(p(j)) + vj, OPT(j-1))得到上面的公式之后，我们可以发现，求解一个问题OPT(j)，可以通过求解它的子问题OPT(j-1)来实现，于是我们做到了把求解一个问题变成求解它的子问题。于是我们可以得到下面这个递归算法：123456OPT(j): If j == 0 then return 0 Else return max(OPT(p(j)) + vj, OPT(j-1)) Endif三、优化改进上面的递归算法是尾递归，可以使用迭代对其进行优化。使用一个数组(动态规划的专业名词叫做备忘录)来记录求解过的值，避免重复求解。改进之后可以得到下面这个迭代算法，时间复杂度为O(n)。1234OPT[n] = &#123;0&#125;For j = 1 to n: OPT[j] = max(OPT(p(j)) + vj, OPT(j-1))Endfor该算法已经可以帮助我们找到最大奖励了。但仅知道一个最大奖励并没有太大意义，我们更需要知道通过参加哪些活动来取得最大奖励。因此，我们在计算最大活动奖励的过程中，还需要记录一下选取了哪些活动。我们定义一个记录数组S，继续回到我们前面讨论过的选择活动n的时候面临的两种选择。如果采取第一选择，即参加活动n，我们便记录S[n][0] = true，S[n][1] = p(n)，代表我们在考虑活动n的时候选择了参加活动n，搭配上前面{1, 2, ..., p(n)}中的最优组合。如果采取第二选择，即放弃活动n，那么我们记录S[n][0] = false，S[n][1] = n-1，代表我们放弃活动n，此时活动的选择情况还是与之前考虑活动n-1时候的情况一致。于是我们可以得到如下算法：12345678910111213OPT[n] = &#123;0&#125;初始化 S[n][2]For j = 1 to n: If OPT(p(j)) + vj &gt;= OPT(j-1) then OPT[j] = OPT(p(j)) + vj S[j][0] = true S[j][1] = p[j] Else OPT(j) = OPT(j-1) S[j][0] = false S[j][1] = n-1 EndifEndfor通过上面算法便可以得到想要的活动组合的记录表了。然后反向搜索一下记录表便可得到最优的活动组合。1234567j = nwhile j != 0: If S[j][0] then print j Endif j = S[j][1]Endwhile四、代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;using namespace std;const int MAX_REQ_NUM = 30;struct Request &#123; int beginTime; int endTime; int value;&#125;;bool operator&lt;(const Request&amp; r1, const Request&amp; r2) &#123; return r1.endTime &lt; r2.endTime;&#125;class DP &#123;public: void setRequestNum(const int&amp; requestNum) &#123; this-&gt;requestNum = requestNum; &#125; void init() &#123; for (int i = 1; i &lt;= requestNum; ++i) &#123; cin &gt;&gt; reqs[i].beginTime &gt;&gt; reqs[i].endTime &gt;&gt; reqs[i].value; &#125; &#125; // 预备，根据结束时间对所有请求排序，初始化数组p void prepare() &#123; sort(reqs + 1, reqs + requestNum + 1); memset(p, 0, sizeof(p)); for (int i = 1; i &lt;= requestNum; ++i) &#123; for (int j = i-1; j &gt; 0; --j) &#123; if (reqs[j].endTime &lt;= reqs[i].beginTime) &#123; p[i] = j; break; &#125; &#125; &#125; memset(record, 0, sizeof(record)); &#125; // 动态规划算法 void solve() &#123; optimal[0] = 0; for (int i = 1; i &lt;= requestNum; ++i) &#123; if (optimal[p[i]] + reqs[i].value &gt;= optimal[i-1]) &#123; optimal[i] = optimal[p[i]] + reqs[i].value; record[i][0] = 1; record[i][1] = p[i]; &#125; else &#123; optimal[i] = optimal[i-1]; record[i][0] = 0; record[i][1] = i-1; &#125; &#125; &#125; // 输出结果 void output() &#123; cout &lt;&lt; \"[MAX VALUE]: \" &lt;&lt; optimal[requestNum] &lt;&lt; \"\\n[Activities]:\\n\"; for (int i = requestNum; i &gt; 0; i = record[i][1]) &#123; if (record[i][0] == 1) &#123; cout &lt;&lt; \"activity-\" &lt;&lt; i &lt;&lt; endl; &#125; &#125; &#125;private: Request reqs[MAX_REQ_NUM + 1]; int requestNum; int p[MAX_REQ_NUM + 1]; int optimal[MAX_REQ_NUM + 1]; int record[MAX_REQ_NUM + 1][2];&#125;;int main() &#123; int requestNum; DP dp; cin &gt;&gt; requestNum; dp.setRequestNum(requestNum); dp.init(); dp.prepare(); dp.solve(); dp.output(); return 0;&#125;输入格式：12345活动总数活动1的开始时间、结束时间、贡献价值活动2的开始时间、结束时间、贡献价值...活动n的开始时间、结束时间、贡献价值输入输出示例：12345678910111260 4 21 6 45 7 42 9 78 10 28 11 1[MAX VALUE]: 8[Activities]:activity-5activity-3activity-1","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hongchh.github.io/tags/数据结构与算法/"}]},{"title":"计算机网络应用层协议分析总结","slug":"计算机网络应用层协议分析总结","date":"2016-09-21T09:35:28.000Z","updated":"2017-11-11T05:25:00.718Z","comments":true,"path":"2016/计算机网络应用层协议分析总结/","link":"","permalink":"https://hongchh.github.io/2016/计算机网络应用层协议分析总结/","excerpt":"","text":"1、应用层协议原理1.1、网络应用程序体系结构C/S结构，有一个总是打开的主机称为服务器，它服务于来自许多其他称为客户机的主机请求。客户机主机既可能有时打开，也可能总是打开。C/S结构之下，客户机之间不直接通信。服务器有固定的IP地址。在C/S体系结构中，常用主机集群创建强大的虚拟服务器。基于C/S结构的应用服务通常是基础设施密集的(infrastrucuture intensive)。P2P结构，任意间断连接的主机对(称为对等方)直接相互通信，不必通过专门的服务器。P2P结构的最突出特性之一是它的自扩展性(self-scalability)。1.2、进程通信同一个端系统上的进程通过操作系统上的进程间通信机制相互通信。不同端系统上的进程通过跨越计算机网络交换报文(message)而相互通信。客户机和服务器进程对于每对通信进程，通常将这两个进程之一标示为客户机(client)，另一个标示为服务器(server)。标示的规则是，在给定的一对进程之间的通信回话中，发起通信的进程称为客户机，在会话开始时等待联系的进程是服务器。(P2P结构下一个进程既可以使服务器也可以是客户机)。进程与计算机网络之间的接口进程通过一个称为套接字(socket)的软件接口在网络上发送和接收报文。套接字是同一台主机内应用层与运输层之间的接口，是网络上建立网络应用程序的可编程接口，称为应用程序和网络之间的应用程序编程接口(API)。1.3、可供应用程序使用的运输服务可靠数据传输如果一个协议能够确保由应用程序的一端发送的数据正确地、完全地交付给该应用程序的另一端，那么该协议提供了可靠数据传输服务(reliable data transfer)。吞吐量两个进程在一条网络路径上进行通信会话时，可用吞吐量就是发送进程能够向接收进程交付比特的速率。因为其它会话将共享沿着该网络路径上的带宽，并且这些其它会话将会到达和离开，所以可用吞吐量将随时间波动。因此有了另一种服务，即运输层协议能够以某种特定的速率提供确保的可用吞吐量。定时运输层协议也能提供定时保证，如同吞吐量保证一样，定时保证可以以多种形式实现。例如，可以设置发送方注入进套接字的每个比特到达接收方的套接字不迟于100ms。这种服务对交互式实时应用程序非常适用。安全性在发送主机中，运输层协议能够加密由发送进程传输的所有数据；在接收主机中，运输层协议能够在数据交付给接收进程之前解密这些数据。1.4、因特网提供的传输服务因特网上的应用使用了两个运输层协议：UDP和TCP。TCP服务面向连接服务： 使用TCP协议时，在应用层数据报文开始流动之前，其客户机程序和服务器程序之间相互交换运输层控制信息(握手过程)。握手阶段后，两个进程的套接字之间建立一个TCP连接，连接双方可以在此连接上同时进行报文收发。报文收发结束之后，该连接将被拆除。可靠数据传输服务：进行通信的进程依靠TCP协议，无差错、按适当顺序交付发送的数据。拥塞控制机制：发送方和接收方之间的网络出现拥塞时，TCP协议的拥塞机制会抑制发送进程。TCP协议的拥塞控制试图限制每个TCP连接，使它们达到公平共享网络带宽的目的。UDP服务UDP是一种不提供不必要服务的轻量级运输层协议。它是无连接的，两个进程通信前没有握手过程。UDP协议提供的是不可靠数据传输服务，也就是说，当进程通过UDP套接字发送报文时，UDP协议不保证该报文能够被接收进程收到。此外，接收进程收到报文的顺序也可能是乱序的。UDP协议没有拥塞控制机制。TCP和UDP的安全问题TCP和UDP都没有提供任何加密机制，发送进程传送至套接字的数据与经过网络传送到目的进程的数据相同。如果某个进程以明文方式将一个口令传送至它的套接字，该明文口令将经过发送方和接收方之间的所有链路传送，这就可能在任何中间链路被嗅探和发现。由于存在种种隐私和其他安全问题，人们研制了TCP的加强版本，称为安全套接字层(Secure Socket Layer, SSL)。SSL不是独立于TCP和UDP的第三种协议，而只是对TCP的增强。这种增强是在应用层上实现的。如果一个应用程序要使用SSL的服务，它需要在其客户机和服务器中都包括SSL的代码。进程寻址为了识别接收进程，需要定义两种信息：主机名称或地址；目的主机上接收进程的标识。在因特网中，主机是用IP地址进行标识的。目的地端口号则用于标识接收进程。2、web应用和HTTP协议2.1、HTTP概况web的应用层协议是产文本传输协议(HyperText Transfer Protocol, HTTP)。HTTP协议由两部分程序实现：一个客户机程序和一个服务器程序，它们运行在不同的端系统中，通过交换HTTP报文进行会话。HTTP定义了这些报文的格式以及客户机和服务器是如何进行报文交换的。HTTP使用TCP作为它的支撑运输层协议。客户机发起一个与服务器的TCP连接，一旦连接建立，浏览器和服务器进程就可以通过套接字接口访问TCP。HTTP是一个无状态协议(stateless protocol)，一个HTTP服务器并不保存关于客户机的任何信息。2.2、非持久连接和持久连接在许多因特网应用中，客户机和服务器进行长时间通信，其中客户机发出一系列请求，服务器对每个请求进行响应。根据不同的应用程序以及应用程序的使用方式，这一系列请求可以周期性地一个接一个发出，也可以间断地发出。当客户机/服务器的交互运行于TCP协议之上时，应用程序的研制者需要确定每个请求/响应对是经一个单独的TCP连接发送，还是所有的请求及响应经相同的TCP连接发送。如果采取前一种方法，该应用程序使用非持久连接(non-persistent connection)；如果采用后一种方法，该应用程序使用持久连接(persistent connection)。HTTP既可以使用非持久连接，也可以使用持久连接，默认方式下HTTP使用持久连接。非持久连接在非持久连接的情况下，访问一个网页(假设该网页中还有引用了其他静态资源，如css,js,img等等)会经过下面几个步骤：【1】 HTTP客户机进程发起一个到服务器的TCP连接。客户机和服务器上分别有一个socket与该连接相关联。【2】 HTTP客户机经它的套接字向服务器发送一个HTTP请求报文。【3】 HTTP服务器进程经它的套接字接受该请求报文，从其存储器中检索出请求对象，在一个HTTP相应报文中封装对象，并通过其套接字向客户机发送响应报文。【4】 HTTP服务器进程通知TCP断开该TCP连接(直到TCP确认客户机已经完整地接受到响应报文为止，它才会真正中断连接)。【5】 HTTP客户机接受响应报文，TCP连接关闭。【6】 对其他资源都重复前面几个步骤上面整个过程中，每次访问一个对象(资源)都会重新建立一次TCP连接。浏览器和服务器之间发起一次TCP连接，涉及到一个”三次握手”的过程，即客户机向服务器发送一个小TCP报文段，服务器拥抱一个小TCP报文段做出确认和响应，最后，客户机向服务器返回确认。一个RTT(Round-Trip Time，即一个分组从客户机到服务器再回到客户机所花费的时间)等于三次握手中前两个部分所耗费的时间。完成三次握手的前两个部分之后，客户机将三次握手的第三个部分(确认)与一个HTTP请求报文结合起来发送到该TCP连接。一旦该请求报文到达服务器，服务器向该TCP连接发送响应报文。该请求/响应又消耗一个RTT。因此，粗略地讲，总的响应时间就是两个RTT加上服务器传输响应报文的时间。非持久连接必须为每一个请求的对象建立和维护一个全新的连接。对于每个这样的连接，在客户机和服务器都要分配TCP的缓冲区和变量，这给服务器带来了严重的负担。其次，每个对象的传输时延为两个RTT。持久连接在持久连接的情况下，服务器在发送响应后保持该TCP连接打开。在相同的客户机与服务器之间的后续请求和响应报文可通过相同的连接进行传送。一般来说，如果一个连接经过一定时间间隔仍未被使用，HTTP服务器就关闭该连接。HTTP的默认模式使用了流水线方式的持久连接。2.3、HTTP报文格式请求报文12345GET /somedir/page.html HTTP/1.1Host: www.someschool.eduConnection: closeUser-agent: Mozilla/4.0Accept-language: fr上面是一个请求报文的示例。HTTP请求报文第一行叫做请求行(request line)，其后继的行叫做首部行(header line)。请求行有3个字段：方法、URL、HTTP协议版本。首部行包含了请求的一些基本信息。在通用的HTTP请求报文格式中，首部行后面可能还有实体主体(entity body)。使用GET方法时，实体主体为空；而使用POST方法时，提交的数据信息会放在这个实体主体中。响应报文123456789HTTP/1.1 200 OKConnection: closeDate: Thu, 03 Jul 2003 12:00:15 GMTServer: Apache/1.3.0 (Unix)Last-Modified: Sun, 6 May 2007 09:23:24 GMTContent-Length: 6821Content-Type: text/html(data data data ...)上面是一个HTTP响应报文的示例。响应报文分成3部分：状态行(status line)、首部行(header line)、实体主体(entity body)。状态行有3个字段：协议版本、状态码、响应状态信息。首部行则包含了一些基本信息。实体主体部分是报文的主体，包含所请求的对象本身。下面是一些常见的状态码和状态信息：12345200 OK: 请求成功，信息包含在返回的响应报文中301 Moved Permanently: 请求对象已经被永久转移了400 Bad Request: 请求不能被服务器理解404 Not Found: 请求的文档不在服务器上505 HTTP Version Not Supported: 服务器不支持请求报文使用的HTTP协议版本2.4、cookieHTTP协议是无状态的，为了能够识别用户，HTTP使用cookie这项技术。cookie技术有4个组成部分：【1】在HTTP响应报文中有一个cookie首部行【2】在HTTP请求报文中有一个cookie首部行【3】在用户端系统中保留有一个cookie文件，由用户浏览器管理【4】web站点有一个后台数据库cookie的工作过程客户端访问一个网站请求报文到达服务器服务器产生一个唯一识别码以此识别码作为索引在数据库中产生一个表项服务器用一个包含Set-cookie首部行的HTTP响应报文对客户端进行响应，Set-cookie首部行含有识别码客户端接收到响应报文，看到Set-cookie首部浏览器在它管理的特定cookie文件中添加报文中的识别码客户端继续向服务器请求页面，这时浏览器会从cookie文件中提取识别码并放置到请求报文的cookie首部行中服务器根据请求报文中的cookie信息识别用户客户端后续每次向服务器发送请求都将重复8、9两步直到cookie被删除2.5、web缓存web缓存器(web cache)也叫代理服务器(proxy server)，它是能够代表初始web服务器来满足HTTP请求的网络实体。web缓存器有自己的磁盘存储空间，并在该存储空间中保存最近请求过的网络实体。它既可以是客户机也可以是服务器。主要的工作流程如下：【1】浏览器建立一个到web缓存器的TCP连接并向web缓存器中的对象发送一个HTTP请求【2】web缓存器检查本地是否存储了该对象的拷贝。如果有，web缓存器就用HTTP响应报文向客户机浏览器返回该对象【3】如果web缓存器没有该对象，它将与该对象的初始服务器打开一个TCP连接，然后发送获取对象的HTTP请求。收到请求后，初始服务器向web缓存器发送具有该对象的HTTP响应【4】当web缓存器接收该对象时，它在本地存储空间存储该对象的拷贝，并用HTTP响应报文向客户机浏览器发送该对象部署web缓存器有两个原因：减少客户机请求的响应时间；减少一个机构内部网与因特网接入链路的通信量，从而减少带宽，降低费用。2.6、条件GET方法尽管高速缓存能减少用户感受到的响应时间，但也引入了一个新的问题，即存放在缓存器上的对象可能不是最新的。保存在服务器中的对象在该拷贝缓存在客户机后可能已经被修改了。幸运的是，HTTP协议有一种机制，允许缓存器证实它的对象是最新的。这种机制就是条件GET(conditional GET)方法。条件GET请求包含下面两个特性：使用GET方法；报文中包含一个If-modified-since首部行。其工作流程如下：【1】缓存器向服务器发送一个请求报文【2】服务器向缓存器发送具有被请求对象的响应报文，其中包含Last-Modified首部行【3】缓存器存储该对象同时也存储了Last-Modified中描述的最后修改时间【4】一段时间过后，客户机向缓存器发送请求报文来请求对象【5】缓存器接收到客户机的报文之后，向服务器发送一个条件GET方法确认对象是否最新【6】服务器检查，发送缓存的对象还是最新的之后，向缓存发送一个状态为304(Not Modified)的响应【7】缓存器接收到响应确认最新之后再将对象发送给客户机【8】如果服务器检查发现缓存对象不是最新的，则向缓存器发送响应报文同时把最新的对象附在报文的实体主体中传送【9】缓存器接受响应报文之后更新缓存对象并发送给客户机3、文件传输协议：FTPFTP运行在TCP上，使用两个并行的TCP连接来传输文件，一个是控制连接(control connection)，一个是数据连接(data connection)。控制连接用于在两个主机之间传输控制信息，如用户标识、口令、改变远程目录的命令以及”put”和”get”文件的命令。数据连接用于实际传输一个文件。因为FTP协议使用一个分离的控制链接，所以我们也称FTP的控制信息是带外(out-of-band)传送的。当用户主机与远程主机开始一个FTP会话前，FTP的客户机首先在21号端口上向服务器发起一个用于控制的TCP连接。FTP的客户机通过该控制连接发送用户的标识和口令，也发送改变远程目录的命令。当FTP服务器从控制连接上收到一个文件传输命令后，就会发起一个到客户机的数据连接。FTP在该数据连接上准确地传送一个文件后关闭该连接。如果在同一会话期间，用户还需要传输另外一个文件，FTP则打开另一个数据连接。因此对FTP传输而言，控制连接贯穿了整个用户会话期间，但是针对会话中的每一次文件传输都需要建立一个新的数据连接(即数据连接是非持久的)。FTP服务器必须在整个会话期间保留用户的状态(state)信息。4、因特网中的电子邮件电子邮件系统主要由3各部分组成：用户代理(user agent)、邮件服务器(mail server)和简单邮件传输协议(Simple Mail Transfer Protocol, SMTP)。用户代理允许用户阅读、回复、转发、保存和撰写报文。邮件服务器是电子邮件系统结构的核心。一个典型的发送邮件过程如下：发送方的用户代理向其所在的邮件服务器发送邮件，该邮件被放在邮件服务器的发送报文队列中，邮件从发送方的邮件服务器发送到接收方的邮件服务器，接收方的用户代理从它所在的邮件服务器中获取邮件。SMTP是因特网电子邮件中主要的应用层协议。它使用TCP可靠数据传输服务，从发送方的邮件服务器向接收方的邮件服务器发送邮件。SMTP有两个部分：运行在发送方邮件服务器的客户机和运行在接收端邮件服务器的服务端。每个邮件服务器上既有SMTP客户机也有SMTP服务器。4.1、简单邮件传输协议–SMTPSMTP一般不适用中间邮件服务器发送邮件。例如，A的邮件服务器再中国广东，B的邮件服务器在美国西海岸，当A向B发送邮件的时候，发起的TCP连接是直接从中国广东连接到美国西海岸，中间不经过其他服务器。如果B的服务器没有开机，那么邮件会保留在A的服务器上并在稍后继续进行新的发送尝试，也就是说，该邮件不会在中间某个其他邮件服务器上存留。SMTP发报过程：客户机在25端口建立一个到服务器的TCP连接，如果服务器没有开机，客户机会在稍后继续尝试连接。连接建立之后，服务器和客户机执行一些应用层的握手。在握手阶段，SMTP客户机指明发送方的邮件地址和接收方的邮件地址。握手阶段结束后，客户机开始发送邮件报文。SMTP可以利用TCP提供的可靠数据传输无差错地将邮件投递到接收方的服务器。SMTP使用的是持久连接，该客户机如果还有另外的报文要发送到该服务器，也会在同一个TCP连接上进行发送；否则，TCP连接会被关闭。4.2、邮件访问协议前面介绍了邮件服务器之间利用SMTP协议传送邮件的过程。现在，我们继续来看用户代理与邮件服务器之间是如何传输的。A向B发邮件时，A的用户代理会利用SMTP协议把邮件推送到其所在的邮件服务器，邮件服务器再利用SMTP协议将邮件发送给B所在的邮件服务器。这里我们会发现一个细节，这里有两个步骤使用了SMTP协议。为什么要这么做呢？主要原因是，如果从A的用户代理直接用SMTP协议向B所在的邮件服务器发送邮件，那么A的邮件可能无法被B接收到。因为B的邮件服务器可能关机了，通过先从用户代理将邮件发送到A的邮件服务器上之后，邮件缓存在A的服务器上并由服务器去不断尝试给B的服务器发送邮件直到成功。这样用户在自己的电脑上发送完邮件之后就不用继续关注邮件的发送过程了，也就是说不用一直开着电脑了，由服务器去帮助完成这些事情即可。邮件到达B的邮件服务器之后，会缓存在服务器上，等待B的用户代理来访问获取邮件。注意，这里B的用户代理不能用SMTP协议去向服务器取回邮件，因为取邮件是一个拉操作，而SMTP是一个推协议。于是邮件访问协议横空出世，该协议将B所在的邮件服务器上的邮件传送给B的电脑上的用户代理。目前有多个流行的邮件访问协议，包括第三版邮局协议(Post Office Protocol-Version 3, POP3)、因特网邮件访问协议(Internet Mail Access Protocol, IMAP)以及HTTP。最后，整个邮件发送和接收过程如下图所示：5、DNS：因特网的目录服务主机的识别方式有两种：主机名和IP地址。主机名可以方便人们记住，而路由器则喜欢格式化的IP地址。域名系统(Domain Name System, DNS)的主要任务就是实现主机名到IP地址的映射转换。DNS是一个由分层的DNS服务器实现的分布式数据库，是一个允许主机查询分布式数据库的应用层协议。与HTTP、FTP、SMTP协议一样，DNS协议也是应用层协议。它运行在UDP之上，使用客户机/服务器模式在通信的端系统之间运行，在通信的端系统之间通过下面的端到端运输层协议来传送DNS报文。DNS通常由其他应用层协议(包括HTTP、FTP、SMTP)所使用，用于将用户提供的主机名解析为IP地址。假设某用户用浏览器访问某一个网站，DNS的工作流程如下：【1】用户主机上运行着DNS应用的客户端【2】浏览器从URL中提取出要访问的网站的主机名，将主机名传送给本机的DNS客户端【3】DNS客户端向DNS服务器发送一个包含主机名的请求【4】DNS客户端收到一份来自服务器的回答报文，其中包含对应于主机名的IP地址【5】浏览器向对应的IP地址定位的HTTP服务器发起一个TCP连接除了主机名到IP地址的转换外，DNS还提供了一些重要服务：主机别名(host aliasing)、邮件服务器别名(mail server aliasing)、负载分配(load distribution)。5.1、负载分配概述繁忙的站点可能被冗余分布在多台服务器上，每台服务器均运行在不同的端系统上，有着不同的IP地址。对于这些冗余的web服务器，一个IP地址集合对应于同一个规范主机名。DNS数据库中存储着这些IP地址集合。当客户机为映射到这个IP地址集合的名字发出一个DNS请求时，该服务器用包含全部这些地址的报文进行回答，但在每个回答中旋转这些地址排放的顺序。因为客户机通常总是向IP地址排在最前面的服务器发送HTTP请求，所以DNS就在所有这些冗余web服务器之间旋转分配负载。DNS的旋转同样适用于邮件服务器。5.2、DNS工作机理概述分布式、层次数据库DNS使用了大量服务器，它们以层次方式组织，并且分布在全世界范围内。没有一台DNS服务器具有因特网上所有主机的映射，相反，该映射分布在所有的DNS服务器上。DNS服务器有3种类型：根DNS服务器、顶级域(Top-Level Domain, TLD)DNS服务器和权威DNS服务器。这些DNS服务器的层次结构如下图所示。当一个DNS客户机想要获取IP地址时，它首先会从根服务器那边联系，根服务器返回TLD服务器的IP地址，DNS客户机根据IP地址继续去跟对应的TLD服务器联系，TLD服务器返回权威服务器的IP地址，这样一层一层找下去直到获取到相应主机的IP地址。除了根、TLD和权威DNS服务器之外，还有另一类服务器，本地DNS服务器(local DNS server)。每个ISP都有一台本地DNS服务器。当主机与某个ISP连接时，该ISP提供一台主机的IP地址，该主机具有一台或多台其他本地DNS服务器的地址。DNS缓存为了改善时延性能并减少在因特网上到处传输的DNS报文数量，DNS广泛使用了缓存技术。当一个DNS服务器接收一个DNS回答时，DNS服务器能将回答中的信息缓存在本地存储器。如果在DNS服务器中缓存了一个主机名/IP地址对，另一个对相同主机名的查询到达该服务器时，该服务器就能马上提供所要求的IP地址，即使它不是该主机名的权威服务器。由于主机和主机名与IP地址见的映射关系不是永久的，所以DNS服务器在一段时间后会将缓存信息丢弃。","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://hongchh.github.io/tags/计算机网络/"}]},{"title":"稳定匹配问题与GS算法-单身狗脱单秘籍","slug":"稳定匹配问题与GS算法-单身狗脱单秘籍","date":"2016-09-19T08:46:25.000Z","updated":"2017-11-11T05:17:39.089Z","comments":true,"path":"2016/稳定匹配问题与GS算法-单身狗脱单秘籍/","link":"","permalink":"https://hongchh.github.io/2016/稳定匹配问题与GS算法-单身狗脱单秘籍/","excerpt":"","text":"稳定匹配问题稳定匹配问题(stable matching)是一个常见的问题，GS算法是解决稳定匹配问题的一个优秀的算法。下面，我将以男女配对的例子来介绍稳定匹配问题并阐述GS算法的具体步骤。GS算法，全称Gale-Shapley算法。学习完稳定匹配问题和整个算法流程之后，我觉得它还可以起另外一个别名，Get-rid-of-Single算法，单身狗脱单算法。问题描述有n只男性单身狗的集合M = {m1, m2, ..., mn}和n只女性单身狗的集合W = {w1, w2, ..., wn}。假设每只男性单身狗对n只女性单身狗的喜好程度都不同，每只女性单身狗对n只男性单身狗亦如是。男单身狗mi(1 &lt;= i &lt;= n)有一张属于自己的关于对面n只女单身狗的排序表，mi把他最爱慕的女性放在第一位，第二爱慕的女性放在第二位，以此类推，排名越靠前女性表示mi越爱慕的女性。同样地，女单身狗wi(1 &lt;= i &lt;= n)也有一张属于自己的关于对面n只男单身狗的排序表，排名越靠前的男性越受wi的喜爱。每只单身狗都希望与自己最喜爱的对象结为侠侣，浪迹江湖。现在，有一个名唤月老的NPC在为这2*n只单身狗牵红线，月老收集了这些单身狗各自的排序表，并根据他们的排序表来牵红线让这些单身狗结成n对侠侣，使得这n对侠侣达成一个稳定匹配，和谐地浪迹江湖。【稳定匹配】假设有两对伴侣(m1, w1)、(m2, w2)，在m1的排序表中w2的排名比w1高，也就是说，m1喜欢w2比喜欢他现任w1要多一点。此时，若w2正好喜欢m1比喜欢她现任m2要多一点，那么m1和w2就很有可能背叛他们目前各自的侠侣关系重新与更喜欢的对象结为侠侣，剩下被甩的w1和m2继续沦落为单身狗。上面这种情况我们称为不稳定因素，要是一个匹配之中没有任何不稳定因素，那么这个匹配称为稳定匹配。再举个例子，同样是(m1, w1)、(m2, w2)，m1更喜欢w2，但是w2不喜欢m1。此时，这个匹配是稳定的。因为m1和w2并非相互之间都更喜欢对方，因此他们不会”私奔”，不会打破现有的匹配关系。这样一个匹配，虽然m1无法得到自己最喜欢的w2，但这个匹配的关系是和谐稳定的。因此，我们定义稳定匹配的概念如下：给定的一组匹配结果里面，n对侠侣之间任何两对侠侣都不会存在有人想”私奔”的不稳定因素。输入输出输入： 每个男单身狗对n个女单身狗的排序表，每个女单身狗对n各男单身狗的排序表输出： n对满足稳定匹配的伴侣算法基本思想初始，每个人都是单身狗，分别根据自己对异性的排序表开始找对象。假设一只男性单身狗mi选择了他的排序表上排名最高的女性w，并且向她示爱。这个时候就可能存在下面3种情况：【1】w也是单身狗，于是他们两个结为侠侣，成功脱单【2】w已经和某男性mj脱单，但是w更喜欢mi，于是w把mj甩了，重新和mi结为侠侣。mi成功挖到墙脚，换mj变成单身狗【3】w已经和某男性mj脱单，而且w不喜欢mi，于是mi挖墙脚失败，为了脱单只能继续寻找排名表上下一个喜欢的女性示爱对于每个单身狗都重复上述的过程，不断地去”骚扰”排名表上的女性，找到还没脱单的就一起脱单，找到脱单的就挖墙脚，挖不动就找下一个喜欢的对象继续重复上述过程。这就是”伟大”的单身狗脱单(GS)算法。算法的伪代码如下所示：1234567891011121314151617初始化所有M和W集合中元素为单身狗初始化侠侣集合S为空集While 存在男单身狗mi 令w是mi的排名表中mi还未示爱的女性中排名最高的女性 If w也是单身狗 then (mi, w)组成侠侣，加入侠侣集合S Else w已经和mj脱单 If w更偏爱mj而不爱mi then mi挖墙脚没戏，保持单身 Else w更偏爱mi而不爱mj then (mj, w)解除侠侣关系，从侠侣集合S中移除 mj沦落为单身狗 mi挖墙脚成功，(mi, w)组成侠侣，加入侠侣集合S Endif EndifEndwhile输出集合S中的所有侠侣配对情况算法分析仔细分析一下这个单身狗脱单算法我们可以发现它具备下面几个特性：某只女单身狗w从第一次跟别人组成侠侣之后，如果某个男单身狗m继续向她示爱，而且m刚好在w的排序表上的排名比w的现任更高，那么w会甩了现任然后与m“私奔”。如果m在w的排序表上的排名比w的现任低，那么w不理睬m，继续和现任保持关系。这个规律可以看出，w自从第一个跟别人组成侠侣之后，她如果后面还有与其他人组成侠侣，那么跟她组成侠侣的人只会”越来越好”，即越来越符合她的排序表，也就是说，她得到的异性质量会越来越好。某只男单身狗向他排序表上的女性示爱，第一个示爱失败之后只能找第二个，再失败再找第三个，以此类推。于是这个那单身狗在他脱单之前，他能选择的女性只会越来越不符合他的排序表，也就是说，他能选择的异性质量会越来越差。这个算法在执行结束之后会返回一个稳定的匹配。为什么呢？因为该脱单的都脱单了，能挖动的墙脚也都被挖了，最后组成的匹配结果中，任何两对侠侣之间不会再存在任何能够挖墙脚私奔的不稳定因素了。乍一看GS算法好像是偏爱女性的一种算法。但实际上，GS算法在某些情况下也存在偏爱男性的情况。如果男性的排名表完全协调(他们全都列出不同女性作为他们的第一选择)，那么在GS算法的所有运行中所有男人最终都与他们的第一选择匹配，而与女人的排序表无关。怎么理解呢？假设男单身狗m1最喜欢女单身狗w1，m2最喜欢w2，…，mn最喜欢wn。那么所有男单身狗在选择时都会进入前面说到的【1】这种情况，也就是直接和最喜欢的女性脱单了。这个时候女性就变成没有选择权了，如果这时候女单身狗的排序表刚好跟男单身狗完全冲突的话，也就是说，w1最不喜欢m1，w2最不喜欢m2，以此类推。那么这种情境下的匹配结果虽然是稳定的，但却也往往也是带着一股不太好的气息，因为男性都得到了最喜爱的女性，而女性却都得到了最不喜爱的男性。算法实现经过前面的讨论我们基本清楚了稳定匹配问题和GS算法是怎么一回事了。下面，我用C++简单实现了GS算法的整个过程。为了在O(1)的时间内判断出女性w是否更加偏爱mi或mj，我将女性对男性的排序表的存储方式小小调整了一下，跟男性对女性排序表的存储方式有所不同。另外，侠侣集合S的数据结构也采用数组表示以便更简单地在O(1)的时间内增加或删除侠侣。GS算法的时间复杂度为O(n^2)，但是不同代码实现可能会有不同的复杂度。如果判断女性w是否更加偏爱mi或mj这个地方使用遍历女性w的排序表的方法的话会造成更高的复杂度。集合的增删元素操作这里也会有相应的复杂度影响。有了上面两个O(1)复杂度的改进之后，下面整个算法实现的时间复杂度为O(n^2)。下面是实现代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;using namespace std;class GSModel &#123;public: GSModel(int cpNum): cpNum(cpNum) &#123; free_m = new bool[cpNum]; free_w = new bool[cpNum]; result = new int[cpNum]; order_m = new int*[cpNum]; order_w = new int*[cpNum]; for (int i = 0; i &lt; cpNum; ++i) &#123; order_m[i] = new int[cpNum]; order_w[i] = new int[cpNum]; &#125; &#125; ~GSModel() &#123; for (int i = 0; i &lt; cpNum; ++i) &#123; delete [] order_m[i]; delete [] order_w[i]; &#125; delete [] free_m; delete [] free_w; delete [] result; delete [] order_m; delete [] order_w; &#125; // 输入男性和女性的排序表 void init() &#123; cout &lt;&lt; \"[man's order list of women]\\n\"; for (int i = 0; i &lt; cpNum; ++i) &#123; cout &lt;&lt; \"[m-\" &lt;&lt; i &lt;&lt; \"]: \"; for (int j = 0; j &lt; cpNum; ++j) &#123; cin &gt;&gt; order_m[i][j]; &#125; free_m[i] = true; &#125; cout &lt;&lt; \"[woman's order list of man]\\n\"; for (int i = 0; i &lt; cpNum; ++i) &#123; cout &lt;&lt; \"[w-\" &lt;&lt; i &lt;&lt; \"]: \"; int man; for (int j = 0; j &lt; cpNum; ++j) &#123; cin &gt;&gt; man; order_w[i][man] = cpNum - j; &#125; free_w[i] = true; result[i] = -1; &#125; &#125; // 判断是否全部人都脱单 bool isOk() const &#123; for (int i = 0; i &lt; cpNum; ++i) if (free_m[i]) return false; return true; &#125; void solve() &#123; while (true) &#123; for (int i = 0; i &lt; cpNum; ++i) &#123; if (free_m[i]) &#123; for (int j = 0; j &lt; cpNum &amp;&amp; free_m[i]; ++j) &#123; int w = order_m[i][j]; // 女方自由 if (free_w[w]) &#123; result[w] = i; free_m[i] = false; free_w[w] = false; &#125; // 女方已有对象，但爱此男比爱现任多一点 else &#123; if (order_w[w][i] &gt; order_w[w][result[w]]) &#123; free_m[result[w]] = true; result[w] = i; free_m[i] = false; &#125; &#125; &#125; &#125; &#125; if (isOk()) break; &#125; &#125; // 输出匹配结果 void print() const &#123; for (int i = 0; i &lt; cpNum; ++i) &#123; cout &lt;&lt; \"(w-\" &lt;&lt; i &lt;&lt; \", m-\" &lt;&lt; result[i] &lt;&lt; \")\\n\"; &#125; &#125;private: bool* free_m; bool* free_w; int** order_m; int** order_w; int* result; int cpNum;&#125;;int main() &#123; int cpNum; cin &gt;&gt; cpNum; GSModel gsm(cpNum); gsm.init(); gsm.solve(); gsm.print(); return 0;&#125;输入输出示例：1234567891011123[man&apos;s order list of women][m-0]: 0 1 2[m-1]: 1 0 2[m-2]: 0 2 1[woman&apos;s order list of man][w-0]: 1 2 0[w-1]: 0 1 2[w-2]: 1 0 2(w-0, m-1)(w-1, m-0)(w-2, m-2)","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hongchh.github.io/tags/数据结构与算法/"}]},{"title":"socket通信基础知识点记录","slug":"socket通信基础知识点记录","date":"2016-09-11T07:34:52.000Z","updated":"2017-11-11T05:05:54.825Z","comments":true,"path":"2016/socket通信基础知识点记录/","link":"","permalink":"https://hongchh.github.io/2016/socket通信基础知识点记录/","excerpt":"","text":"网络通信是一种进程间通信(IPC, Inter-Process Communication)，要求位于不同网络节点不同进程的通信双方必须遵循统一的通信协议方可实现。基于套接字(Socket)通信是应用在不同节点上的进程间通信的典型办法。1、基本原理1.1、 Socket API基本概念Socket API是TCP/IP网络的API，用于提供IPC通信。下面是socket API的概念模型。Socket是物理网络地址和逻辑端口号的一个集合，通过这个集合可以向另外一个位置的与它具有相同定义的Socket进行数据传输。由于Socket是由机器地址和端口号来识别，那么在一个特定的计算机网络上，每一个socket都是由此方式被唯一标识的，这也使得应用程序可以被唯一定位。socket类型有两种：一个是流式socket，提供进程之间的逻辑链接，并且支持可靠的数据交换；另一个则是数据包socket，无连接且不可靠。1.2、 JAVA对网络通信的支持JDK提供的预定义类库支持Java程序直接发送与接收TCP数据段或UDP数据报，并帮助程序员以更直接的方式处理建立在TCP之上的应用层协议HTTP、FTP等。JDK预定义的类均放在程序包java.net中，使用其中哪些类取决于所需要处理的通信协议。例如，基于TCP的应用程序可使用Socket，ServerSocket等类；基于HTTP和FTP等协议直接访问URL资源的应用程序可使用URL、URLConnection等类。1.3、TCP、UDP与端口传输控制协议(TCP, Transfer Control Protocol)是一种面向连接的传输层协议，可为两台主机上的应用程序提供可靠的数据流连接。所谓”面向连接”意味着两个使用TCP通信的应用程序在交换数据之前必须先建立一个TCP连接，带通信结束后须关闭该连接。这一过程与电话通信类似。TCP执行的任务包括把应用层传来的数据分解为合适的数据段交给网络层，确认接收到的数据分组，设置发送最后确认分组的超时时间等，为应用层屏蔽了实现端到端可靠通信的细节。TCP可保证数据从连接的一端送到另一端时仍能保持原来发送时的次序，否则将出现一个传输错误。TCP为需要可靠通信的应用程序提供了一种点对点信道，在因特网上常见的FTP、SMTP等协议都是建立在TCP的基础上。用户数据报协议(UDP, User Datagram Protocol)不是基于连接的，而是为应用层提供一种非常简单、高效的传输服务。UDP从一个应用程序向另一个应用程序发送独立的数据报，但并不保证这些数据报一定能到达另一方，并且这些数据报的传输次序无保障，后发送的数据报可能先到达目的地。使用UDP协议时，任何必需的可靠性都须由应用层自己提供。UDP适用于对通信可靠性要求低且对通信性能要求高的应用，如DNS、RIP等协议都建立在UDP的基础上。由于现代计算机大多运行多任务操作系统，故一台主机上可能同时运行多个应用程序进程，并且一个进程还可能使用多个不同的连接，因而仅用主机名或IP地址无法唯一标识数据包的源或目标。端口为标识参与通信的主机、进程与连接提供了一种统一的、唯一的方法。2、数据报socket2.1 面向无连接数据包UDPUDP协议使用数据报式套接字，在数据传输之前不需要先建立连接，UDP没有组装和重传请求的功能，并不保证接收方能够接收到该数据包，也不保证接收方所接收到的数据和发送方所发送的数据在内容和顺序上是完全一致的。其主要工作是将应用程序传输过来的数据分块交给网络层，确认接收到分组信息。2.2 面向连接数据包UDP一般来说，很少用数据报socket实现面向连接通信，因为此API提供的连接非常简单，通常难以满足应用需求。3、流式socket3.1 基本编程原理流式socket所完成的通信是一种基于连接的通信，即在通信开始之前先由通信双方确认身份并建立一条专用的虚拟连接通道，然后它们通过这条通道传送数据信息进行通信，当通信结束时再将原先所建立的连接拆除。在这个过程中，Server端首先在某个端口提供一个监听Client请求的监听服务，并处于监听状态，当Client端向该Server的这个端口提出服务请求时，Server端课Client端就建立了一个连接和一条传输数据的通道，通信结束时该通道被拆除。3.2 单线程服务程序与客户程序使用基于TCP协议的双向通信时，网络中的两个应用程序之间必须首先建立一个连接，这一连接的两个端点分别被称为socket。由于socket被绑定到某一固定的端口号，故TCP可将数据传输给正确的应用程序。从应用变成的角度看，应用程序可将一个输入流或一个输出流绑定到某一socket，读写这些输入/输出流即可实现基于TCP的通信。使用网络通信的应用程序普遍采用客户机/服务器计算模型(C/S架构)，其中客户程序作为通信的发起者，向服务器提出信息或服务请求；服务程序则负责提供这种信息或服务，服务程序经常在一个无限循环中等待客户程序的请求并执行相应的服务。在Java程序中使用socket通信可支持在一台主机上运行的单个服务程序为多个不同的客户程序提供服务。其通信模式如下，服务程序将选定一个固定的端口号对外发布服务，客户程序则必须先按约定的主机与端口号向服务程序发送一个要求建立连接的请求(这些请求称为连接请求)，申请建立一个到服务程序的连接。服务程序在收到某一客户程序的连接请求后，并不是利用对外发布的那个端口号建立与该客户程序的连接，而是另外分配一个新的端口号建立与客户程序之间的连接，原端口号仍用于监听其他客户程序的连接请求，不会因为该端口长期处理客户程序请求而导致其他客户程序阻塞。3.3 多线程服务程序单线程的服务端在同一时刻只能处理一个客户连接，一旦服务程序的accept()被调用，服务程序主线程将持续执行客户程序发来的服务请求，再无其他线程监听服务程序对外发布的端口，导致后续的客户连接请求失败。一种简单的改进途径是当服务程序处理完一个客户连接后再次循环执行accept()。这种改进虽然可以使服务程序在处理完一个客户程序的所有服务请求后，还可继续建立与下一客户程序的连接并处理请求。但在一个客户程序提交的服务请求需占用服务程序较长时间的情况下，其他客户程序的连接请求将进入队列等待，甚至可能因队列溢出而丢失。另外一种改进途径是使用多线程编程方式，让服务程序的主线程执行监听客户程序连接请求的任务，而处理客户程序服务请求的任务则交由另一个新建的线程负责。4、应用层协议开发4.1 应用层协议理解一般来说，网络协议有三个要素，分别是：语法、语义与规则(时序)。语义规定了通信双方彼此之间准备”讲什么”，即确定协议元素的类型；语法规定通信双发彼此之间”如何讲”，即确定协议元素的格式；变换规则用以规定通信双方彼此之间的”应答关系”，即确定通信过程中的状态变化，通常可用状态变化图来描述。针对应用层协议，此三要素的含义是：语法是消息的语法和描写，语义是指消息的解释或含义，规则是进程间通信的顺序。4.2 FTP协议开发文件传输协议FTP(File Transfer Protocol)是一个用于在两台装有不同操作系统的计算机之间传输计算机文件的软件标准，工作于应用层。FTP服务一般运行在20和21两个端口。端口20用于在客户端和服务器之间传输数据流，而端口21用于传输控制流。当数据通过数据流传输时，控制流处于空闲状态。FTP协议有两种工作方式：PORT方式和PASV方式，即主动模式和被动模式。主动模式要求客户端和服务器同时打开并且监听一个端口以建立连接，主动模式的连接过程是：客户端向服务器的FTP端口(默认是21)发送连接请求，服务器接受连接，建立一条命令链路。当需要传送数据时，服务器从20端口向客户端的空闲端口发送连接请求，建立一条数据链路来传送数据。在主动模式下，客户端可以由于安装了防火墙会产生一些问题，所以创立了被动模式。被动模式只要求服务器端产生一个监听相应端口的过程，这样就可以绕过客户端安装了防火墙的问题。被动模式的连接过程是：客户端向服务器的FTP端口发送请求，服务器接受连接，建立一条命令链路。当需要传送数据时，客户端向服务器空闲端口发送连接请求，建立一条数据链路来传送数据。4.3 HTTP协议开发超文本传输协议HTTP采用典型的”请求-答复”通信模型：客户程序建立与服务器程序的连接后，向服务程序发送一个服务请求；服务程序根据请求获取相应的文档作为答复送回客户程序，最后关闭连接。由于在客户程序和服务程序的整个会话过程中可能需要建立多个连接(例如，为获取两个不同URL指定的资源而分别建立两个TCP连接)，而不是持久地使用同一TCP连接，故HTTP是一种无状态协议。在HTTP协议的实现中可通过减少TCP连接的建立与次数以提高通信效率，HTTP/1.1的持久连接机制甚至还保证了客户程序与服务程序之间同一类型元素持久地使用同一连接，但HTTP仍不能被视为一种可保持会话状态的协议。","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://hongchh.github.io/tags/计算机网络/"}]},{"title":"计算机网络概述","slug":"计算机网络概述","date":"2016-09-11T01:05:13.000Z","updated":"2017-11-11T04:21:14.892Z","comments":true,"path":"2016/计算机网络概述/","link":"","permalink":"https://hongchh.github.io/2016/计算机网络概述/","excerpt":"","text":"1、基本概念主机(host)，或者称为端系统(end system)，通过通信链路(communication link)和分组交换机(packet switch)连接到一起。链路的传输速率是以bps度量，当一台端系统有数据要向另一台端系统发送时，发送端系统将数据分段，并为每段加上首部字节。由此形成的信息包称为分组(packet)。从发送端系统到接收端系统，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的路径(route或path)。端系统通过因特网服务提供商(Internet Service Provider, ISP)接入因特网。每个ISP是一个由多个分组交换机和多段通信链路组成的网络。通过网络链路和交换机移动数据有两种基本方法：电路交换(circuit switching)和分组交换(packet switching)。在电路交换网络中，沿着端系统通讯路径，为端系统之间通信所提供的资源(缓存、链路传输速率)在通信会话期间会被预留。在分组交换网络中，这些资源则不会被预留，会话的报文按需使用这些资源，排队等待接入通信线路。2、电路交换电路交换：每条链路都有n条电路，能够支持n条电路同时连接。每台主机都与一台交换机直接连接。当两台主机要通信时，该网络在两台主机之间创建一条专用的端到端连接(end-to-end connection)。因为每条链路具有n条电路，每条链路由端到端连接使用，该连接在连接期间获得该链路带宽的1/n部分。电路交换网络中的多路复用：链路中的电路要么通过频分多路复用(Frequency-Division Multiplexing, FDM)实现，要么通过时分多路复用(Time-Division Multiplexing, TDM)实现。对于FDM，链路的频谱由跨越链路创建的所有连接所共享，该链路在连接期间为每条连接专用一个频段，这个频段的宽度称为带宽(bandwidth)。对于TDM，时间被划分成固定区间的帧，并且每帧又被划分成固定数量的时隙。当网络跨越一条链路创建一条连接时，该网络在每个帧中为该连接指定一个时隙。这些时隙专门由该连接单独使用，用于传输该连接的数据。3、分组交换多数分组交换机在链路的输入端使用存储转发传输(store-and-forward transmission)机制。存储转发传输机制是指在交换机能够开始向输出链路传输该分组的第一个bit之前，必须接受到整个分组。因此，存储转发式分组交换机沿着该分组的路径在每条链路的输入端引入了存储转发时延。考虑从一台主机经分组交换网络向另一台主机发送一个L比特分组需要多长时间。假定在这两台主机之间有Q段链路，每段链路的速率为R bps。假定这是该网络中的唯一分组。从主机A发出的该分组首先传输到第一段链路上，这需要L/R s。然后它在余下的Q-1段链路上传输，即它必须存储和转发Q-1次，每次都有L/R的存储转发时延，因此总时延为QL/R。每个分组交换机有多条链路与之项链，对于每条项链的链路，该分组交换机具有一个输出缓存(output buffer，也称输出队列，output queue)，用于存储路由器准备发往那条链路的分组。如果到达的分组需要跨越链路传输，但发现该链路整忙于传输其他分组，该到达分组必须在输出缓存中等待。因此，除了存储转发时延以外，分组还要承受输出缓存的排队时延(queue delay)。这些时延是变化的，变化程度取决于网络中的拥塞水平。因为缓存空间的大小是有限的，所以一个到达的分组可能发现该缓存被等待传输的分组完全占满了，这种情况下将出现分组丢失(也称为丢包，packet lost)。4、分组交换和电路交换对比分组交换因其端到端时延是变动且不可预测的，故不适合实时服务(例如，电话和视频会议)。分组交换提供了比电路交换更好的带宽共享，比电路交换更简单、更有效、成本更低。5、分组是怎样通过分组交换网形成其通路在因特网中，每个通过该网络传输的分组在它的首部包含了其目的地址，该地址是一种层次结构，当分组到达网络中的一台路由器时，该路由器检查分组的目的地址的一部分，冰箱相邻路由器转发该分组。每个路由器具有一个转发表用于将目的地址(或目的地址的一部分)映射到输出链路。当分组到达一台路由器时，该路由器检查目的地址，并用这个目的地址搜索转发表，以找到合适的输出链路。然后，路由器将该分组导向输出链路。6、分组交换网中的时延概述当分组从一个节点(主机或路由器)沿着这条路径到后继节点时，该分组在沿途的每个节点都经受了几种不同类型的时延。这些时延中最为重要的就是节点处理时延(nodal processing delay)、排队时延(queuing delay)、传输时延(transmission delay)和传播时延(propagation delay)，这些时延总体累加起来是节点总时延(total nodal delay)。6.1、处理时延检查分组首部和决定将该分组导向何处所需的时间是处理时延的一部分。处理时延也包括其他因素，比如检查比特级差错所需的时间，该差错出现在这些分组比特从上游节点向路由器传输的过程中。6.2、排队时延在队列中，当分组在链路上等待传输时，它经受排队时延。一个特定分组的排队时延将取决于先期到达的、正在排队等待向链路传输的分组的数量。如果该队列是空的，并且当前没有其他分组在传输，则该分组的排队时延为0。另一方面，如果流量很大，并且许多其他分组也在等待传输，该排队时延将很大。6.3、传输时延用L比特表示分组长度，R bps表示从路由器A到路由器B的链路传输速率，那么传输时延是L/R。这是将分组的所有比特推(传输)向链路所需要的时间。6.4、传播时延一旦一个比特被推向链路，该比特需要向路由器B传播。从该链路的起点到路由器B传播所需要的时间是传播时延。该比特以该链路的传播速率传播。传播时延等于两台路由器之间的距离除以传播速率，即d/s，d是A到B之间的距离，s是传播速率。6.5、排队时延与丢包令a表示分组到达队列的平均速率(a的单位是每秒分组，pkt/s)，R是传输速率，所有分组都是由L比特组成。则比特到达队列的平均速率是La bps。比率La/R被称为流量强度(traffic intensity)。如果La/R大于1，则比特到达队列的平均速率超过该队列的传输速率，这种情况下，队列的增加将趋于无界，排队时延将趋于无穷大。丢包：一条链路前的队列只有有限的容量，到达的分组发现一个满的队列时，由于没有地方存储这个分组，路由器将丢弃(drop)该分组，该分组将会丢失(lost)。6.6、端到端时延假定源主机和目的主机之间有N-1台路由器，并且该网络是无拥塞的(因此可忽略排队时延)，在每台路由器和源主机的处理时延是dproc，每台路由器和源主机的传输速率是R bps，每条链路的传播时延是dprop。节点时延累加起来得到端到端时延：de2e=N(dproc+dtrans+dprop)。其中dtrans=L/R，L是分组长度。6.7、计算机网络中的吞吐量假设主机A通过网络向主机B发送一个大文件。任何瞬间的瞬间吞吐量(instantaneous throughput)是主机B接受到该文件的速率(以bps计)。若该文件由F比特组成，主机B接受到所有F比特用了T秒，则文件传送的平均吞吐量(average throughput)是F/T bps。7、协议层次和它们的服务模型7.1、分层的体系结构一个协议层能够用软件、硬件或两者的结合来实现。HTTP和SMTP等应用层协议通常都是在端系统中用软件实现的，运输层协议也是如此。物理层和数据链路层负责处理跨特定链路的通信，它们通常在与给定链路相关的网络接口卡(例如以太网或者WiFi接口卡)中实现。网络层经常是硬件和软件的混合体。五层模型：应用层-&gt;运输层-&gt;网络层-&gt;链路层-&gt;物理层七层模型：应用层-&gt;表示层-&gt;会话层-&gt;运输层-&gt;网络层-&gt;链路层-&gt;物理层各层的所有协议被称为协议栈(protocol stack)。因特网的协议栈由5个层次组成：物理层、链路层、网络层、运输层和应用层。应用层：应用层是网络应用程序及其应用层协议存留的地方。应用层包括许多协议，例如HTTP、SMTP、FTP等等。应用层协议分布在多个端系统上，一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息分组。这种位于应用层的信息分组称为报文(message)。运输层：运输层提供了在应用程序端点之间传送应用层报文的服务。在因特网中，有两个运输层协议，即TCP和UDP，利用其中任何一个都能传输应用层报文。TCP向它的应用程序提供了面向连接的服务。这种服务包括了应用层报文向目的地的确保传递和流量控制(即发送方/接收方速率匹配)。TCP也将长报文划分为短报文，并提供拥塞控制机制，当网络拥塞时，源抑制其传输速率。UDP协议向它的应用程序提供无连接服务。这是一种不提供不必要服务的服务，不提供可靠性，没有流量控制，没有拥塞机制。传输层分组称为报文段(segment)。网络层：网络层负责将称为数据报(datagram)的网络层分组从一台主机移动到另一台主机。源主机中的运输层协议向网络层递交运输层报文段和目的地址。网络层包括著名的IP协议，该协议定义了数据报中的各个字段以及端系统和路由器如何作用于这些字段。网络层还包括决定路由的选路协议，数据报根据该路由从源传输到目的地。链路层：网络层通过一系列路由器在源和目的地之间发送分组。为了将分组从一个节点移动到路径上的下一个节点，网络层必须依靠链路层的服务。在每个节点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个节点。数据报到达下一个节点后链路层将数据报上传给网络层。因为数据报从源到目的地传送通常需要经过几条链路，所以它可能被沿途不同链路上的不同链路层协议处理。例如，某个数据报可能被一条链路上的以太网和下一条链路上的PPP所处理，网络层将接受来自每个不同的链路层协议的不同服务。链路层的分组称为帧(frame)。物理层：链路层的任务是讲整个帧从一个网络元素移动到邻近的网络元素，而物理层的任务是将该帧中的一个个比特从一个节点移动到下一个节点。该层的协议仍然是链路相关的，并且进一步与链路(例如，双绞铜线，光纤)的实际传输媒体有关。7.2、报文、报文段、数据报、帧数据从发送端系统的协议栈向下，上下中间的链路层交换机和路由器的协议栈，进而向上到达接收端系统的协议栈。在发送主机，应用层报文(application-layer message)被传送给运输层。在最简单的情况下，运输层收取报文并附加信息(即运输层首部信息)，该首部将被接收端的运输层使用。应用层报文和运输层首部共同构成了运输层报文段(transport-layer segment)。运输层报文段因此封装了应用层报文。附加的信息可能包括下列信息，如允许接收端运输层向上适当的应用程序交付报文的信息；差错检测比特信息。运输层向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，形成了网络层数据报(network-layer datagram)。该数据报接下来被传递给链路层，链路层当然也增加它自己的链路层首部信息并创建了链路层帧(link-layer frame)。于是，每一层分组具有两种类型字段：首部字段和有效载荷字段(payload field)，有效载荷通常来自上一层的分组。","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://hongchh.github.io/tags/计算机网络/"}]},{"title":"JavaScript-事件流、事件处理程序及事件对象总结","slug":"JavaScript-事件流、事件处理程序及事件对象总结","date":"2016-08-26T09:31:07.000Z","updated":"2017-11-11T04:14:50.223Z","comments":true,"path":"2016/JavaScript-事件流、事件处理程序及事件对象总结/","link":"","permalink":"https://hongchh.github.io/2016/JavaScript-事件流、事件处理程序及事件对象总结/","excerpt":"","text":"JS与HTML之间的交互通过事件实现。事件就是文档或浏览器窗口中发生的一些特定的交互瞬间。可以使用监听器(或处理程序)来预定事件，以便事件发生时执行相应的代码。这种在传统软件工程中被称为观察员模式，支持页面的行为与页面的外观之间的松散耦合。本文将介绍JS事件相关的基础知识。一、事件流事件流描述的是从页面中接受事件的顺序。事件冒泡事件开始时由最具体的元素(文档中嵌套层次最深的那个节点)接收，然后逐级向上传播到较为不具体的结点(文档)。以下面HTML页面为例，如果你点击了页面中的按钮，那么&quot;click&quot;事件会按照&lt;button&gt;、&lt;body&gt;、&lt;html&gt;、document的顺序传播。换句话说，事件冒泡指的就是事件从底层触发事件的元素开始沿着DOM树向上传播，直到document对象。12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;Test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=\"myBtn\"&gt;A Btn&lt;/button&gt; &lt;/body&gt;&lt;/html&gt;事件捕获与事件冒泡的思路相反，事件捕获的思想是不太具体的节点应该更早地接收到事件，最具体的结点应该最后才接收事件。同样还是上面那个例子，点击页面中的按钮之后，&quot;click&quot;事件会按照document、&lt;html&gt;、&lt;body&gt;、&lt;button&gt;的顺序传播。换句话说，事件捕获就是指事件从document对象开始沿着DOM树向下传播，直到事件的实际目标元素。DOM事件流“DOM2级事件”规定的事件包括三个阶段: 事件捕获阶段、处于目标阶段和事件冒泡阶段。首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。还是以之前的点击按钮为例，在DOM事件流中，捕获阶段，&quot;click&quot;事件从document开始向下传递到body元素(注意，实际目标button在捕获阶段不会接收到事件)。目标阶段，button元素接收到&quot;click&quot;事件。最后，冒泡阶段，事件又被传播回文档。二、事件处理程序事件是用户或浏览器自身执行的某种动作，而响应某个事件的函数就叫做事件处理程序或事件侦听器。HTML事件处理程序这里的HTML事件处理程序指的是直接在HTML元素里面通过特性(attribute)定义的事件处理程序，请看下面的代码示例。这样是定的事件处理程序会创建一个封装着元素属性值的函数，this值等于事件的目标元素。通过这种方法指定事件处理程序存在不少缺点，不推荐使用。12345678&lt;button onclick=\"alert('HaHa~')\"&gt;Btn-1&lt;/button&gt;&lt;button onclick=\"alert('event.type')\"&gt;Btn-2&lt;/button&gt;&lt;button onclick=\"handler()\"&gt;Btn-3&lt;/button&gt;&lt;script type=\"text/javascript\"&gt; function handler() &#123; alert(\"Haha~\"); &#125;&lt;/script&gt;DOM0级事件处理程序通过JS指定事件处理程序的传统方式就是将一个函数赋值给一个事件处理程序属性，请看下面代码示例。通过这种方式指定的事件处理程序是在元素的作用域中运行，this引用的是当前元素。这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。若要删除事件，直接令onclick的值为空即可。1234567var btn = document.getElementById(\"myBtn\");btn.onclick = function() &#123; console.log(\"this.id\"); // \"myBtn\"&#125;;// 删除事件处理程序btn.onclick = null;DOM2级事件处理程序“DOM2级事件”定义了两个方法用于指定和删除事件处理程序，addEventListener()和removeEventListener()。所有DOM节点中都包含这两个方法。这两个方法都接收3个参数，要处理的事件、处理函数、布尔值。最后的布尔值为true时表示在捕获阶段调用事件处理程序，为false时表示在冒泡阶段调用处理程序。与DOM0级方法一样，这里添加的事件处理程序也是在其依附的元素的作用域中运行。DOM2级方法添加事件处理程序的优势是可以添加多个事件处理程序。这些事件处理程序会按照它们被添加的顺序触发。下面是代码示例：12345678var btn = document.getElementById(\"myBtn\");// 添加，触发点击事件时先输出\"myBtn\"再输出\"HaHa~\"btn.addEventListener(\"click\", function() &#123; console.log(this.id);&#125;, false);btn.addEventListener(\"click\", function() &#123; console.log(\"HaHa~\");&#125;, false);通过addEventListener()添加的事件只能通过removeEventListener()来删除。删除时传入的参数与添加时使用的参数应该保持一致。这也意味着通过addEventListener()添加的匿名函数将无法删除，因为无法将添加时传递的匿名函数传给removeEventListener()，即便在删除的时候写了一个一模一样的函数，但此时这个函数只是一个新的匿名函数。请看下面代码示例：123456789101112131415var btn = document.getElementById(\"myBtn\");// 无法删除匿名函数btn.addEventListener(\"click\", function() &#123; console.log(this.id);&#125;, false);btn.removeEventListener(\"click\", function() &#123; console.log(this.id);&#125;, false);// 正确的添加和删除方式function handler() &#123; console.log(this.id);&#125;btn.addEventListener(\"click\", handler, false);btn.removeEventListener(\"click\", handler, false);大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览器。最好只在需要在事件到达目标之前截获它的时候才将事件处理程序添加到捕获阶段。JS高级程序设计上给出的建议是，如果不是特别需要，不建议在事件捕获阶段注册事件处理程序。IE事件处理程序IE实现了与DOM中类似的两个方法: attachEvent()和deleteEvent()。这两个方法接收两个参数，事件处理程序名称和事件处理程序。注意，第一个参数是事件处理程序名称而不是事件名称，也就是说在注册点击事件的处理程序时应该传入&quot;onclick&quot;而不是&quot;click&quot;，这里跟DOM的方法有些差别。另外，这两个方法注册的事件处理程序是在全局作用域中运行而不是元素作用域，this的值指向window。还有一点需要特别小心，通过attachEvent()方法也可以添加多个事件处理程序，但是它们的执行顺序却不是按照它们被添加的顺序，而是完全相反，跟DOM方法截然不同。突然觉得IE真的特别反人类~下面是代码示例：123456789var btn = document.getElementById(\"myBtn\");function handler1() &#123; // ... &#125;function handler2() &#123; // ... &#125;// 添加，触发点击事件时先执行handler2再执行handler1btn.attachEvent(\"onclick\", handler1);btn.attachEvent(\"onclick\", handler2);// 删除btn.deleteEvent(\"onclick\", handler1);btn.deleteEvent(\"onclick\", handler2);三、事件对象在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息，包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。DOM中的事件对象兼容DOM的浏览器会将一个event对象传入事件处理程序中，无论指定事件处理程序时用的是DOM0还是DOM2的方法，都会传入event对象。event对象只有在事件处理程序执行期间才会存在，一旦事件处理程序执行完毕，event对象就会被销毁。下面是代码示例：1234567var btn = document.getElementById(\"myBtn\");btn.onclick = function(event) &#123; console.log(event.type); // \"click\"&#125;btn.addEventListener(\"click\", function(event) &#123; console.log(event.type);&#125;, false);event对象包含与创建它的特定事件有关的属性和方法，触发的事件类型不一样，可用的属性方法也有所不同。但是所有的事件都会有下列的属性或方法：bubbles: 布尔值，表示事件是否冒泡cancelable: 布尔值，表示是否可以取消事件的默认行为currentTarget: 元素，事件处理程序当前正在处理事件的那个元素defaultPrevented: 布尔值，表示是否调用过preventDefault()方法detail: 整数，与事件相关的细节信息eventPhase: 整数，调用事件处理程序的阶段，1表示捕获阶段，2表示目标阶段，3表示冒泡阶段preventDefault(): 函数，取消事件的默认行为，cancelable为true时可以调用该方法stopImmediatePropagation(): 函数，取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用stopPropagation(): 函数，取消事件的进一步捕获或冒泡，bubbles为true时可以调用这个方法target: 元素，事件的目标trusted: 布尔值，为true时表示事件是浏览器生成的，否则表示事件是通过JS创建的type: 字符串，被触发的事件类型view: 与事件关联的抽象视图，等同于发生事件的window对象下面代码示例展示了上述部分属性的用法，也可以帮助我们进一步理解事件流。假设页面中有一个按钮&quot;myBtn&quot;。当点击按钮时，this和currentTarget都等于body元素，因为事件处理程序是注册在body元素上。target的值却等于按钮元素，因为它是click事件的真正目标。由于按钮上没有注册事件处理程序，结果&quot;click&quot;事件冒泡到了document.body那里才得到处理。12345document.body.onclick = function(event) &#123; console.log(event.currentTarget === document.body); // true console.log(this === document.body); // true console.log(event.target === document.getElementById(\"myBtn\")); // true&#125;;再看一个例子，下面代码中，stopPropagation()方法取消了事件的进一步捕获或冒泡。当我点击按钮时，本来应该会因为事件冒泡机制触发按钮和body元素上的点击事件处理程序，输出&quot;From Bth ...&quot;和&quot;From Body ...&quot;。现在点击事件在按钮元素上触发之后就被阻止继续在DOM层次中的传播，因此body上的事件处理程序不会被触发。123456789var btn = document.getElementById(\"myBtn\");btn.onclick = function(event) &#123; console.log(\"From Bth ...\"); event.stopPropagation(); // 停止事件传播&#125;;document.body.onclick = function() &#123; console.log(\"From Body ...\");&#125;;IE中的事件对象在IE中，使用DOM0的方法添加事件处理程序时，event对象作为window对象的一个属性存在。如果是通过attachEvent()方法添加，则event对象是作为参数传入事件处理函数。下面是代码示例：12345678var btn = document.getElementById(\"myBtn\");btn.onclick = function() &#123; var event = window.event; console.log(event.type); // \"click\"&#125;;btn.attachEvent(\"onclick\", function(event) &#123; console.log(event.type); // \"click\"&#125;);IE的event对象同样也包含与创建它的事件相关的属性和方法，这些属性和方法也会因为事件类型的不同而有所差异。但所有事件对象都会包含下列属性：cancelBubble: 布尔值，可读可写，默认为false。将其设置为true时取消事件冒泡returnValue: 布尔值，可读可写，默认为true。将其设置为false时取消事件的默认行为srcElment: 元素，事件的目标元素，与DOM中的target属性相同type: 字符串，事件类型在IE中，事件处理程序的作用域是根据指定它的方式来确定，this的值不一定是指向事件的目标元素。因此，使用srcElement属性更具保险。请看下面代码实例，第一种方式中this的值为目标元素，而第二种方式，前面讲过这种方式的事件处理程序是在全局作用域中执行，因此this的值为window。1234567var btn = document.getElementById(\"myBtn\");btn.onclick = function() &#123; console.log(window.event.srcElement === this); // true&#125;btn.attachEvent(\"onclick\", function(event) &#123; console.log(event.srcElement === this); // false&#125;);","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://hongchh.github.io/tags/JavaScript/"}]},{"title":"JavaScript-DOM扩展","slug":"JavaScript-DOM扩展","date":"2016-08-24T12:11:00.000Z","updated":"2017-11-11T04:04:26.485Z","comments":true,"path":"2016/JavaScript-DOM扩展/","link":"","permalink":"https://hongchh.github.io/2016/JavaScript-DOM扩展/","excerpt":"","text":"一、选择符API扩展querySelector()该方法接受一个CSS选择符，返回与该模式匹配的第一个元素。没有匹配的元素则返回null。在Document类型调用该方法会在文档元素的范围内查找匹配元素，在Element类型调用该方法会在该元素的后代范围内查找匹配元素。传入非法的选择符时会抛出错误。123var div = document.querySelector(\"div\");var myDiv = document.querySelector(\"#myDiv\");var bth = myDiv.querySelector(\".btn\");querySelectorAll()该方法参数与querySelector()方法一样，但返回的是一个NodeList实例，包含所有匹配的元素。如果没有匹配的元素，则返回一个空的NodeList。返回的NodeList带有属性方法，其底层实现类似于一组元素的快照，而非不断对文档进行搜索的动态查询，从而避免了使用NodeList通常会引起的大多数性能问题。123var div = document.querySelectorAll(\"div\");var .btn = document.querySelectorAll(\".btn\");var firstDiv = div.item(0); // 或者div[0]matchesSelector()该方法接受一个CSS选择符，如果调用元素与该选择符匹配则返回true，否则返回false。12var div = document.querySelector(\"div.aha\");console.log(div.matchesSelector(\".aha\")); // true二、元素遍历扩展Element Traversal API为DOM元素添加了以下5个属性：childElementCount: 返回子元素(不包括文本节点和注释)的个数firstElementChild: 指向第一个子元素；firstChild的Element版lastElementChild: 指向最后一个子元素；lastChild的Element版previousElementSibling: 指向前一个同辈元素；previousSibling的Element版nextElementSibling: 指向后一个同辈元素；nextSibling的Element版过去，要跨浏览器遍历某元素的所有子元素，需要像下面的示例1一样去写代码，childNodes列表中包含元素节点、文本节点、注释节点等信息，因此需要检测元素节点。而有了上面5个拓展属性之后就可使得代码更加简洁，而且循环次数更少，如示例2。123456789101112131415// 示例1var child = element.firstChild;while (child != element.lastChild) &#123; if (child.nodeType == 1) &#123; // 需要检查是否为元素节点 processChild(child); &#125; child = child.nextSibling;&#125;// 示例2child = element.firstElementChild;while (child != element.lastElementChild) &#123; processChild(child); child = child.nextElementSibling;&#125;三、HTML5扩展与类相关的扩充getElementsByClassName(): 该方法接受一个参数，即包含一个或多个类型的字符串，返回一个NodeList，包含所有带有指定类型的元素。classList属性: 在操作类名时，需要通过className属性添加、删除和替换类名，由于className的值是一个字符串，所以每次修改都需要替换整个字符串的值，如果元素有多个类名，仅修改其中一个类名都需要写不少代码，非常麻烦。classList的出现解决了这些麻烦，使得操作类名更简单更安全。classList属性是新集合类型DOMTokenList的实例，有length属性表示包含的元素数量，通过item()方法或方括号语法可以取得每个元素。DOMTokenList还有以下方法：add(value): 将给定的字符串添加到列表中contains(value): 如果列表中存在给定的值，返回true，否则返回falseremove(value): 从列表中删除给定字符串toggle(value): 如果列表中存在给定值，删除它，否则添加它下面给出代码示例，示例1展示了使用className修改类名的过程，示例2则是使用classList的过程。123456789101112131415// 示例1，删除\"xxx\"类var classNames = div.className.split(/\\s+/);var pos = -1;for (var i = 0; i &lt; classNames.length; ++i) &#123; if (className[i] == \"xxx\") &#123; pos = i; break; &#125;&#125;classNames.splice(i, 1);div.className = classNames.join(\" \");// 示例2div.classList.remove(\"xxx\"); // 删除\"xxx\"类div.classList.add(\"yyy\"); // 添加\"yyy\"类焦点管理document.activeElement: 引用DOM中当前获得了焦点的元素。元素获得焦点的方式有页面加载、用户输入和代码中调用focus()方法。默认情况下，文档刚刚加载完时，document.activeElement中保存的是document.body元素的引用。文档加载期间，document.activeElement的值是null。document.hasFocus(): 该方法用于确定文档是否获取了焦点，便于检测用户是否正在与页面交互。1234var btn = document.getElementById(\"#btn\");btn.focus();console.log(document.activeElement == btn); // trueconsole.log(document.hasFocus()); // trueHTMLDocumentdocument.readyState: Document的readyState属性有两个可能值，&quot;loading&quot;表示正在加载文档，&quot;complete&quot;表示已经加载完文档。document.readyState的基本用法如下：123if (document.readyState == \"complete\") &#123; // do something&#125;document.compatMode: 该属性用于告诉开发人员浏览器采用了哪种渲染模式，标准模式下其值为&quot;CSS1Compat&quot;，混杂模式下其值为&quot;BackCompat&quot;。document.head: 包含对&lt;head&gt;元素的引用。字符集属性document.charset: 表示文档中使用的字符集。基本用法如下：12console.log(document.charset);document.charset = \"utf-8\";document.defaultCharset: 表示根据默认浏览器及操作系统的设置，当前文档的默认字符集应该是什么。自定义数据属性HTML5规定可以为元素添加非标准的属性，但要添加前缀data-，目的是为元素提供与渲染无关的信息或者语义信息。这些属性可以任意添加、随便命名，但必须以data-开头。添加自定义属性之后在JS中可以通过元素的dataset属性来访问。dataset是一个键值对，每个data-name形式的属性都会有一个对应的属性，属性名会去掉data-前缀。12345// &lt;div id=\"myDiv\" data-name=\"xxx\" data-phone=\"123\" data-email=\"yyy\"&gt;&lt;/div&gt;var div = document.getElementById(\"myDiv\");console.log(div.dataset.name); // \"xxx\"console.log(div.dataset.phone); // \"123\"console.log(div.dataset.email); // \"yyy\"插入标记innerHTML属性：在读模式下，innerHTML属性返回与调用元素的所有子节点(包括元素、注释、文本)对应的HTML标记。在写模式下，会根据指定的值创建新的DOM树，然后用这个DOM树完全替换调用元素原先的所有子节点。1234&lt;div id=\"myDiv\"&gt; &lt;p&gt;some content&lt;/p&gt; &lt;p&gt;another content&lt;/p&gt;&lt;/div&gt;123var div = document.getElementById(\"myDiv\");console.log(div.innerHTML); // 输出\"&lt;p&gt;some content&lt;/p&gt;\\n&lt;p&gt;another content&lt;/p&gt;\"div.innerHTML = \"haha~\"; // div的内容变成&lt;div id=\"myDiv\"&gt;haha~&lt;/div&gt;outerHTML属性：读模式下，outerHTML返回调用它的元素以及所有子节点的HTML标签。在写模式下会根据指定的HTML字符串创建新的DOM子树，然后用这个子树完全替换调用元素。123456&lt;div id=\"div-1\"&gt; &lt;div id=\"div-2\"&gt; &lt;p&gt;some content&lt;/p&gt; &lt;p&gt;another content&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;123var div2 = document.getElementById(\"div-2\");console.log(div2.outerHTML); // 输出\"&lt;div id=\"div-2\"&gt;&lt;p&gt;some content&lt;/p&gt;&lt;p&gt;another content&lt;/p&gt;&lt;/div&gt;\"div2.outerHTML = \"haha~\"; // div的内容变成&lt;div id=\"div-1\"&gt;haha~&lt;/div&gt;insertAdjacentHTML()方法：该方法接受两个参数，要插入的位置和要插入的HTML文本。第一个参数必须是下列值之一：&quot;beforebegin&quot;: 在当前元素之前插入一个紧邻的同辈元素&quot;afterbegin&quot;: 在当前元素下插入一个新的子元素，新元素放在原有的第一个子元素之前&quot;beforeend&quot;: 在当前元素的最后一个子元素后面插入新的子元素&quot;afterend&quot;: 在当前元素后面插入一个紧邻的同辈元素下面是代码示例：1234element.insertAdjacentHTML(\"beforebegin\", \"&lt;p&gt;haha~&lt;/p&gt;\");element.insertAdjacentHTML(\"afterbegin\", \"&lt;p&gt;haha~&lt;/p&gt;\");element.insertAdjacentHTML(\"beforeend\", \"&lt;p&gt;haha~&lt;/p&gt;\");element.insertAdjacentHTML(\"afterend\", \"&lt;p&gt;haha~&lt;/p&gt;\");内存与性能问题：假设某个元素有一个事件处理程序(或者引用了一个JS对象作为属性)，在使用上述的某个属性将该元素从文档树中删除后，元素与事件处理程序(或JS对象)之间的绑定关系在内存中并没有一并删除。如果这种情况频繁出现，页面占用的内存数量就会明显增加。因此，在使用innerHTML、outerHTML和insertAdjacentHTML()时最好先手动删除要被替换元素的所有事件处理程序和JS对象属性。使用innerHTML属性与通过多次DOM操作先创建节点再指定它们之间的关系相比，效率要高很多。这是因为在设置innerHTML或outerHTML时，就会创建一个HTML解析器，这个解析器是在浏览器级别的代码(通常是C++)基础上运行，比执行JS要快得多。此外，创建和销毁这个HTML解析器也会带来性能损失，所以最好将设置innerHTML和outerHTML的次数控制在合理的范围之内。scrollIntoView()方法该方法可以在所有HTML元素上调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中。当页面发生变化时，一般会用这个方法来吸引用户的注意力。实际上，为某个元素设置焦点也会导致浏览器滚动并显示出获得焦点的元素。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://hongchh.github.io/tags/JavaScript/"}]},{"title":"JavaScript-DOM基础知识总结（二）","slug":"JavaScript-DOM基础知识总结（二）","date":"2016-08-24T04:46:00.000Z","updated":"2017-11-11T03:53:24.650Z","comments":true,"path":"2016/JavaScript-DOM基础知识总结（二）/","link":"","permalink":"https://hongchh.github.io/2016/JavaScript-DOM基础知识总结（二）/","excerpt":"","text":"一、动态脚本动态脚本是指页面加载时不存在，但将来某一时刻通过修改DOM动态添加的脚本。创建动态脚本有以下两种方法：插入外部文件和直接插入JS代码。如下面代码示例，两种方法都需要等到&quot;document.body.appendChild(script);&quot;这句代码执行完之后才会将脚本引入。第二种方法中使用异常处理的目的是要兼容IE浏览器。1234567891011121314151617181920function loadScript(url) &#123; var script = document.createElement(\"script\"); script.type = \"text/javascript\"; script.src = url; document.body.appendChild(script);&#125;function loadScriptString(code) &#123; var script = document.createElement(\"script\"); script.type = \"text/javascript\"; try &#123; script.appendChild(document.createTextNode(code)); &#125; catch(ex) &#123; script.text = code; &#125; document.body.appendChild(script);&#125;loadScript(\"client.js\");loadScriptString(\"function haha() &#123; console.log('haha~'); &#125;\");二、动态样式与动态脚本类似，动态样式是指页面刚加载时不存在的样式，页面加载完成后动态添加到页面的样式。添加动态样式也有两种方式：通过&lt;link&gt;标签引入外部文件和通过&lt;style&gt;标签直接写入CSS代码。下面给出代码示例，大部分与动态脚本的写法类似。123456789101112131415161718192021function loadStyle(url) &#123; var link = document.createElement(\"link\"); link.rel = \"stylesheet\"; link.type = \"text/css\"; link.href = url; document.getElementsByTagName(\"head\")[0].appendChild(link);&#125;function loadStyleString(css) &#123; var style = document.createElement(\"style\"); style.type = \"text/css\"; try &#123; style.appendChild(document.createTextNode(css)); &#125; catch(ex) &#123; style.styleSheet.cssText = css; &#125; document.getElementsByTagName(\"head\")[0].appendChild(link);&#125;loadStyle(\"styles.css\");loadStyleString(\"body &#123;background-color: red&#125;\");三、操作表格为了方便构建表格，HTML DOM为&lt;table&gt;、&lt;tbody&gt;、&lt;tr&gt;元素添加了一些属性和方法。需要时可以查看一下相关文档，这里不作列举。四、使用NodeListNodeList、NamedNodeMap和HTMLCollection这三个集合都是动态的，每当文档结构发生变化，他们就会得到更新。因此，他们始终会保存着最新最准确的信息。如以下代码示例，for循环会一直下去，因为divs.length会不断更新，i永远会小于divs.length。每次访问NodeList都会运行一次基于文档的查询，因此需要尽量减少访问NodeList的次数，减少DOM操作。12345678910111213var divs = document.getElementsByTagName(\"div\");var div = null;// 死循环for (var i = 0; i &lt; divs.length; ++i) &#123; div = document.createElement(\"div\"); document.body.appendChild(div);&#125;// 缓存NodeList的信息，不反复访问NodeListvar len = divs.length;for (var i = 0; i &lt; len; ++i) &#123; // ...&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://hongchh.github.io/tags/JavaScript/"}]},{"title":"JavaScript-DOM基础知识总结","slug":"JavaScript-DOM基础知识总结","date":"2016-08-23T07:01:00.000Z","updated":"2017-11-10T13:14:01.963Z","comments":true,"path":"2016/JavaScript-DOM基础知识总结/","link":"","permalink":"https://hongchh.github.io/2016/JavaScript-DOM基础知识总结/","excerpt":"","text":"DOM(文档对象模型)是针对HTML和XML文档的一个API。DOM描绘了一个层次化的节点树，允许开发人员添加、删除和修改页面的某一部分。一、Node类型DOM1级定义了一个Node接口，该接口将由DOM中的所有节点类型实现。这个Node接口在JavaScript中是作为Node类型实现的。JS中的所有节点类型都继承自Node类型，共享着相同的基本属性和方法。每个节点都有一个nodeType属性表明节点类型，节点类型由下面12个数值常量表示，任何节点必属于其中之一。Node.ELEMENT_NODE(1);Node.ATTRIBUTE_NODE(2);Node.TEXT_NODE(3);Node.CDATA_SECTION_NODE(4);Node.ENTITY_REFERENCE_NODE(5);Node.ENTITY_NODE(6);Node.PROCESSING_INSTRUCTION_NODE(7);Node.COMMIT_NODE(8);Node.DOCUMENT_NODE(9);Node.DOCUMENT_TYPE_NODE(10);Node.DOCUMENT_FRAGMENT_NODE(11);Node.NOTATION_NODE(12);通过比较someNode.nodeType与上述某个数值常量是否相等可以确定节点类型。此外，节点除了nodeType属性之外还保存有nodeName和nodeValue属性，这两个属性的值取决于节点类型。举个例子，元素节点的nodeName中保存着元素的标签名而nodeValue的值则为null。1-节点关系每个加点都有一个childNodes属性，其中保存着一个类数组的NodeList对象用于保存一组有序的子节点。NodeList对象的独特之处在于，它实际上是基于DOM结构动态查询的结果，因此DOM结构的变化能够自动反应到NodeList对象中。访问NodeList中的节点时可以通过方括号向数组一样访问，也可以通过item()方法访问，如以下示例：12var firstChild = someNode.childNodes[0];var secondChild = someNode.childNodes.item(1);每个节点都有一个parentNode属性，该属性指向该节点在文档树中的父节点。包含在childNodes列表中的所有节点具有相同的父节点，因此它们的parentNode属性指向同一个节点。此外，包含在ChildNodes列表中的每个节点相互之间都是同胞节点。通过使用列表中每个节点的previousSibling和nextSibling属性，可以访问同一列表中的任何其他节点。列表的第一个节点的previousSibling属性值为null，最后一个节点的nextSibling属性值为null。父节点有firstChild和lastChild属性分别指向其childNodes列表中的第一个和最后一个节点。最后，所有节点都有一个ownerDocument属性，该属性指向表示整个文档的文档节点。2-操作节点节点关系指针都是只读的，因此DOM提供了一些操作节点的方法。下面介绍几个常用的操作方法：appendChild(node)：用于向childNodes列表的末尾添加一个节点。添加节点后，childNodes的新增节点、父节点以及最后一个子节点的关系指针会得到相应更新。更新之后，appendChild()返回新增的节点。如果传入appendChild()的节点已经是文档的一部分了，那么结果就是将该节点从原来的位置转移到新的位置。任何DOM节点不能同时出现在文档中的多个位置上。1234567var returnedNode = someNode.appendChild(newNode);console.log(returnedNode == newNode); // trueconsole.log(someNode.lastChild == newNode); // truereturnedNode = someNode.appendChild(someNode.firstChild); // 插入已存在的节点console.log(returnedNode == someNode.firstChild); // falseconsole.log(returnedNode == someNode.lastChild); // trueinsertBefore(node1, node2)：该方法接受两个参数，要插入的节点与参考节点。插入节点会变成参考节点的前一个同胞节点(previousSibling)同时被返回。如果参考节点为null，那么将与appendChild()执行同样的操作。1234// 插入到倒数第二个位置returnedNode = someNode.insertBefore(newNode, someNode.lastChild);// 插入到最后一个位置returnedNode = someNode.insertBrfoer(newNode, null);replaceChild(node1, node2)：该方法接受两个参数，要插入的节点和被替换的节点。替换节点将从文档树中被移除，同时插入节点占据其位置。从技术上讲，被替换节点仍然存在文档中，但它在文档树中已经没了自己的位置。removeChild(node)：用于将某个节点从文档树种移除。cloneChild(node)：克隆某个节点。该方法可以接受一个布尔值参数，表示是否执行深复制。执行深复制时，除了克隆当前节点之外还会将其整个子节点树也克隆。若是浅复制，则仅复制当前节点。复制后返回的节点副本属于文档所有，但是没有为其制定父节点，需要通过appendChild()等方法将其添加到文档树中。cloneNode()不会复制DOM节点的JS属性，例如事件处理程序等。normalize()：处理文档树种的文本节点。由于解析器的实现或者DOM操作等原因，可能会出现文本节点不包含文本，或者接连出现两个文本节点的情况。当在某个节点上调用这个方法时，就会在该节点的后代节点中查找符合上述两种情况的文本节点，找到空文本节点则删除它，找到连续的文本节点则合并为一个文本节点。二、Document类型JS通过Document类型表示文档。document对象是HTMLDocument(继承自Document类型)的一个实例。Document节点具有以下特征：nodeType: 9nodeName: “#document”nodeValue: nullparentNode: nullownerDocument: null1-文档的子节点Document节点的子节点可以是DocumentType、Element、ProcessingInstruction或Comment。document对象有内置的快速访问某些特殊元素的属性，如下所示：document.documentElement：该属性始终指向页面中的&lt; html&gt;元素document.body：指向&lt; body&gt;元素document.doctype：取得对&lt; !DOCTYPE&gt;的引用2-文档信息document对象提供了一些属性用于获取所表现的网页的一些信息，主要有下列几个属性：document.title：&lt; title&gt;元素中的文本，修改该属性可惜修改网页标题document.URL：网页完整的URL，即浏览器地址栏中显示的URLdocument.domain：网页的域名document.referrer：链接到当前页面的那个页面的URL3-查找元素document.getElementById()：该方法接受一个参数，即要获取元素的ID。找到相应的元素则返回该元素，否则返回null。如果存在多个相同ID的元素，则返回文档中第一次出现的元素document.getElementsByTagName()：该方法接受一个参数，即要获取元素的标签名。返回一个HTMLCollection对象，包含所有符合查找标签名的元素，可以通过方括号或item()方法访问每一个项。HTMLCollection对象还有一个namedItem()方法可以通过元素的name特性取得集合中的项，而且，对命名的项也可以使用方括号语法来访问。给该方法传入参数&quot;*&quot;可以获取文档中所有元素。下面给出代码示例12345678&lt;img src=\"img-1.jpg\" name=\"img-1\"&gt;&lt;img src=\"img-2.jpg\"&gt;&lt;script&gt; var images = document.getElementsByTagName(\"img\"); // 获取所有img元素 var img1 = images.namedItem(\"img-1\"); // 获取命名为img-1的图片元素 var img1 = images[\"img-1\"]; // 另一种等价的访问方式 var all = document.getElementsByTagName(\"*\"); // 获取文档中所有元素&lt;/script&gt;document.getElementsByName()：该方法接受一个参数，查找名称。与getElementsByTagName()方法类似，该方法也返回一个HTMLCollection对象，返回所有带有给定name特性的元素4-特殊集合除了属性和方法之外，document对象还有一些特殊的集合。这些集合都是HTMLCollection对象，为访问文档常用的部分提供快捷方式。document.anchors：文档中所有带name特性的&lt; a&gt;元素document.forms：文档中所有&lt; form&gt;元素document.images：文档中所有&lt; img&gt;元素document.links：文档中所有带href特性的&lt; a&gt;元素三、Element类型Element类型用于表现XML或HTML元素，提供了对元素标签名、子节点及特性的访问。Element节点具有以下特征：nodeType: 值为1nodeName: 元素标签名nodeValue: nullparentNode: 可能是Document或Element子节点可能是Element、Text、Comment、ProcessingInstruction、CDATASection或EntityReference要想访问元素的标签名，可以使用nodeName属性，也可以使用tagName属性。在HTML中，标签名始终以大写表示，而在XML则会与源代码一致，因此，可能会出现如下代码所示的问题：123456var div = document.getElementById(\"myDiv\");console.log(div.tagName); // 输出\"DIV\"// 如果需要执行某些判断，使用下面的写法更好，适用于多种文档if (div.tagName.toLowerCase() == \"div\") &#123; // do something&#125;1-HTML元素所有HTML元素都由HTMLElement类型表示，HTMLElement类型继承自Element类型并添加了一些属性，添加的属性分别对应每个HTML元素中都存在的下列标准特性：id：元素在文档中的唯一标识符title：有关元素的附加说明信息lang：元素内容的语言代码，很少使用dir：语言的方向，值为”ltr”(从左到右)或”rtl”(从右到左)className：元素的class特性，即CSS类名通过给以上属性赋值可以修改相应元素特性的值，如以下代码示例：12345// 假设存在&lt;div id=\"myDiv\" class=\"bd\" title=\"a div\" lang=\"en\" dir=\"ltr\"&gt;&lt;/div&gt;var div = document.getElementById(\"myDiv\");console.log(div.id); // 输出\"myDiv\"console.log(div.title); // 输出\"a div\"div.className = \"ft\"; // 类名变为\"ft\"2-获取和操作特性getAttribute()：该函数接受一个参数，用于获取某个特性的值。传递的参数要与实际的也姓名相同，因此当获取类名的时候要传入&quot;class&quot;而不是&quot;className&quot;，特性不区分大小写。下面给出代码示例:12var div = document.getElementById(\"myDiv\");console.log(div.getAttribute(\"id\")); // 输出\"myDiv\"setAttribute()：该函数接受两个参数，要设置的特性名和值。通过setAttribute()方法既可以操作HTML特性也可以操作自定义特性。请看下面代码示例12div.setAttribute(\"class\", \"ft\");div.setAttribute(\"mycolor\", \"red\");removeAttribute()：该方法接受一个参数，用于删除特性3-attributes属性Element类型是使用attributes属性的唯一一个DOM节点类型。attributes属性中包含一个NamedNodeMap对象，元素的每一个特性都有一个Attr节点表示，每个节点都保存在NamedNodeMap对象中，该对象拥有以下方法。attributes属性中包含一系列节点，每个节点的nodeName就是特性的名称，nodeValue就是特性的值。getNamedItem(name)：返回nodeName属性等于name的节点removeNamedItem(name)：删除nodeName属性等于name的节点setNamedItem(node)：向列表中添加节点，以节点的nodeName属性为索引item(pos)：返回位于数字pos位置处的节点关于attributes如何使用请看下面代码示例：12345// 获取某个div元素的id的值的两种方式var id = div.attributes.getNamedItem(\"id\").nodeValue;id = div.attributes[\"id\"].nodeValue;// 设置id的值div.attributes[\"id\"].nodeValue = \"xxx\";4-创建元素使用document.createElement()方法可以创建新元素。该方法接受一个参数，即要创建的元素的标签名。创建元素之后可通过属性设置相关的特性，通过appendChild()等方法添加到文档树中。5-元素的子节点元素可以有任意数目的子节点和后代节点。元素的childNodes属性中包含了它的所有子节点。如果想要通过特定的标签名获取子节点或后代节点，可以通过元素调用getElementsByTagName()方法，这种调用方式除了搜索起点是当前元素之外，其他方面都跟通过document调用这个方法相同。请看以下代码示例：1234// 获取div元素下的img元素var img = div.getElementsByTagName(\"img\");// 获取整个文档中的img元素var allImg = document.getElementsByTagName(\"img\");四、Text类型文本节点由Text类型表示，可以通过noveValue或data属性访问Text节点中包含的文本。文本节点作为元素节点的子节点，只要元素开始与结束标签之间存在内容，就会创建一个文本节点。在JS中，也可以直接使用document.createTextNode(text)创建文本节点。在JS中创建文本节点可能会使得一个父节点下面存在连续的多个文本节点，可以直接在父元素上调用normalize()方法将多个文本节点合并称为一个。使用下列方法可以操作节点中的文本。appendData(text)：将text添加到节点的末尾deleteData(offset, count)：从offset指定的位置开始删除count个字符insertData(offset, text)：从offset指定的位置开始初入textreplaceData(offset, count, text)：用text替换从offset指定位置开始到offset+count为止处的文本splitText(offset)：从offset指定的位置将当前文本节点分成两个文本节点substringData(offset, count)：提取从offset位置开始到offset+count为止处的字符串五、Comment类型文档中的注释在DOM中由Comment类型表示，它与Text类型继承自相同的基类，拥有除splitText()之外的所有字符串操作方法。与Text类型相似，可通过nodeValue或data属性来获取注释内容。浏览器不会识别位于&lt;html&gt;标签后面的注释，如果要访问注释节点，一定要保证它是&lt;html&gt;元素的后代。六、CDATASection类型该类型只针对基于XML的文档，表示CDATA区域。七、DocumentType类型该类型包含与文档的doctype相关的所有信息八、DocumentFragment类型在所有的节点类型中只有DocumentFragment在文档中没有对应的标记。DOM规定文档片段是一种”轻量级”的文档，可以包含和控制节点，但不会像完整的文档那样占用额外的资源。不能把文档片段直接添加到文档中，但可以将它作为一个仓库来使用，在里面保存将来可能添加到文档中的节点。创建文档片段的方法如下：1var fragment = document.createDocumentFragment();如果将文档中的节点添加到文档片段中，就会从文档树中移除该节点，浏览器中也不再显示这些节点。添加到文档片段中的新节点同样也不属于文档树。可以通过appendChild()或insertBefore()将文档片段中的内容添加到文档中。在将文档片段作为参数传递给这两个方法时，实际上只会将文档片段的所有子节点添加到相应的位置上，文档片段本身永远不会成为文档树的一部分。以下面代码为例，如果逐个地添加列表项，将导致浏览器反复渲染新信息，使用一个文档片段来保存创建的列表项，最后一次性地将它们添加到文档中，就可以完美地避开反复渲染的问题。123456789var fragment = document.createDocumentFragment();var ul = document.getElementById(\"myList\");var li = null;for (var i = 0; i &lt; 10; ++i) &#123; li = document.createElement(\"li\"); li.appendChild(document.createTextNode(\"Item \" + (i+1))); fragment.appendChild(li); // 添加新元素到文档片段中&#125;ul.appendChild(fragment); // 一次性将文档片段中的内容添加到文档九、Attr类型该类型用于表示元素的特性，由于有getAttribute()等方法，因此很少使用这个类型来操作元素特性。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://hongchh.github.io/tags/JavaScript/"}]},{"title":"【分治策略】逆序对问题总结","slug":"【分治策略】逆序对问题总结","date":"2016-08-18T08:41:00.000Z","updated":"2017-11-10T12:59:04.211Z","comments":true,"path":"2016/【分治策略】逆序对问题总结/","link":"","permalink":"https://hongchh.github.io/2016/【分治策略】逆序对问题总结/","excerpt":"","text":"一、逆序对1. 问题背景假如有一组电影集合，包括n部电影。某个人对这n部电影的喜欢程度各有高低，根据其喜欢程度对这n部电影进行排名，按照从1到n的方式进行标记，这就形成了一个关于电影的排名表。假设你和一个陌生人各有自己对于这n部电影的排名表。现在想要比较你跟这个陌生人的“品味”差别，看看你们俩是否有“类似”的爱好。一个很自然的办法就是对比两个人各自的排名表，看看两个排名表的排名状况是否相似。如果两张排名表上的电影顺序非常接近，就表示两个人的”品味”非常接近，反之则两个人的”品味”差距较大。2. 问题的具体描述给定一个序列包含n个数据{a1, a2, ..., an}，我们假设所有的数都是不相同的，我们想定义一个度量，它将告诉我们这个序列跟处于上升顺序的序列相差多远。如果a1 &lt; a2 &lt; ... &lt; an，那么这个度量的值应该为0，表示与上升顺序基本一致。如果数变得更加杂乱时这个度量也就相应增大，表示与上升顺序相差较大。把这个概念量化的一种自然方式是计算序列中的逆序对的个数。逆序对的判断标准如下，当i &lt; j且ai &gt; aj时，这两个元素构成一个逆序对。举个例子，序列{2，4，1，3，5}中有3个逆序对(2,1)，(4,1)，(4,3)，所以该序列与上升顺序的序列之间的不相似度为3。3. 逆序对的应用继续考虑背景介绍中提出的问题，我们可以把任意两个人的排名表，其中一个作为上升顺序表来参考，然后计算另一个排名表中的逆序对个数。逆序对越多，则两个排名表的差别越大，说明两个人的爱好品味差别越大。逆序对如果很接近0，说明两个人的爱好品味都很接近。这种计算可以用于许多方面，比如书本、电影、餐厅等等，对用户的嗜好进行匹配，进而知道哪些用户跟哪些用户的兴趣爱好更为接近，这些计算结果可以用于许多应用软件的推荐服务。4. 计算逆序对的算法显然，存在一个时间复杂度为O(n^2)的暴力算法，遍历所有可能的数据对(ai, aj)，计算出其中的逆序对的个数。这种算法比较简单便不多做阐述，这里介绍的是一种更高效的算法，它的时间复杂度只有O(nlogn)。这个算法的思想跟归并排序很是类似，也是一个分治算法。它的基本思想如下：把要统计逆序对个数的序列C沿着中间位置切分成两个子序列A和B，递归地计算子序列A和子序列B中逆序对的个数并排序，然后合并两个子序列，合并的同时计算所有(ai,aj)的数对中逆序对的个数(ai在子序列A，aj在子序列B)。这个算法的关键过程是合并计数这个环节，假设我们已经递归地排序好了这个序列的两个子序列并计算好了子序列的逆序对个数，我们要如何计算总的逆序对个数呢？由于子序列A和B是已经排好序的，在把A和B合并到C时，按照归并排序的合并过程，每次都挑选两个子序列中最小的元素加入到C中。每次A中的元素ai被加到C中，不会遇到新的逆序，因为ai小于子序列B中剩下的每个元素，并且ai出现在B中元素的前面(子序列A为原序列的前半部分)。但每次B中的元素bj被加到C中，说明它比子序列A中剩下的元素都小，由于B中所有元素本来都排在A后面，所以bj就与A中剩下的所有元素都构成逆序对，此时A中剩下的元素个数就是与bj构成的逆序对的个数。理解这个过程之后，我们就可以很容易地在合并过程中计算逆序对个数了，合并计数过程的伪代码如下：12345678910111213141516171819mergeAndCount(A, B)初始化count= 0，C = 空while A和B都不为空 令ai和bj分别为A和B中的首元素 if ai &lt;= bj 把ai加入到输出表C中 A = A - &#123;ai&#125; else 把bj加入到输出表C中 B = B - &#123;bj&#125; count += A中剩下的元素 endIfendWhileif A 为空 把B中剩下元素加入到Celse 把A中剩下元素加入到CendIfreturn 合并结果C和逆序对个数count整个合并计数过程如以上所示，理解了合并计数过程之后再来理解整个计算逆序对个数的算法就简单多了，整个算法流程的伪代码如下：12345678910sortAndCount(C)if L只有1个元素 没有逆序,c1 = c2 = c3 = 0else 把这个表C均分成两半，A和B (c1, A) = sortAndCount(A) (c2, B) = sortAndCount(B) (c3, C) = mergeAndCount(A, B)endIfreturn (c1 + c2 + c3, C)5. C++代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;using namespace std;class Array &#123;public: Array(const int&amp; size): size(size) &#123; entry = new int[size]; &#125; ~Array() &#123; if (entry != NULL) &#123; delete [] entry; &#125; &#125; int operator[](int i) const &#123; return entry[i%size]; &#125; int&amp; operator[](int i) &#123; return entry[i%size]; &#125; int count() &#123; int* tmp = new int[size]; int c = sortAndCount(entry, tmp, 0, size-1, true); delete [] tmp; return c; &#125;private: int sortAndCount(int* arr, int* tmp, int beg, int end, bool inArr) &#123; if (beg &lt; end) &#123; int mid = (beg + end) / 2; int c1 = sortAndCount(arr, tmp, beg, mid, !inArr); int c2 = sortAndCount(arr, tmp, mid+1, end, !inArr); int c3 = 0; if (inArr) &#123; c3 = mergeAndCount(arr, tmp, beg, mid, end); &#125; else &#123; c3 = mergeAndCount(tmp, arr, beg, mid, end); &#125; return c1 + c2 + c3; &#125; else &#123; if (!inArr) tmp[beg] = arr[beg]; return 0; &#125; &#125; int mergeAndCount(int* arr1, int* arr2, int beg, int mid, int end) &#123; int i = beg, j = mid+1, k = beg, c = 0; while (i != mid+1 &amp;&amp; j != end+1) &#123; if (arr2[i] &lt; arr2[j]) &#123; arr1[k++] = arr2[i++]; &#125; else &#123; arr1[k++] = arr2[j++]; c += mid - i + 1; &#125; &#125; while (i != mid+1) arr1[k++] = arr2[i++]; while (j != end+1) arr1[k++] = arr2[j++]; return c; &#125; int* entry; int size;&#125;;int main() &#123; int size; cin &gt;&gt; size; Array arr(size); for (int i = 0; i &lt; size; ++i) &#123; cin &gt;&gt; arr[i]; &#125; cout &lt;&lt; \"逆序对个数: \" &lt;&lt; arr.count() &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hongchh.github.io/tags/数据结构与算法/"}]},{"title":"JavaScript-window、location对象基础知识整理","slug":"JavaScript-window、location对象基础知识整理","date":"2016-08-18T02:43:00.000Z","updated":"2017-11-10T12:54:01.321Z","comments":true,"path":"2016/JavaScript-window、location对象基础知识整理/","link":"","permalink":"https://hongchh.github.io/2016/JavaScript-window、location对象基础知识整理/","excerpt":"","text":"一、window对象window是BOM的核心对象，表示浏览器的一个实例。在浏览器中，window对象有双重角色，它是通过JS访问浏览器窗口的一个接口，也是Global对象。任何在全局作用域中声明的变量和函数都会变成window对象的属性和方法。虽然全局变量也是window对象的属性，但是与直接在window上定义的属性也是有点不同。全局变量不能通过delete操作符删除，而直接在window上定义的属性则可以。另外，直接访问未声明的变量会抛出错误，而通过window对象访问则不会，只是返回undefined。123456789var p1 = 'p1';window.p2 = 'p2';delete window.p1; // 无法删除delete window.p2;console.log(window.p1); // 输出'p1'console.log(window.p2); // undefinedconsole.log(window.p3); // undefinedconsole.log(p3); // 出错如果页面中包含框架(frame)，则每个框架都有自己的window对象，并且保存在frames集合中，可以通过数值索引或者框架名称来访问相应的window对象。举个例子，对于下面代码，可以使用window.frames[0]或者window.frames[&quot;top&quot;]来访问名字为”top”的框架。123456789101112&lt;html&gt; &lt;head&gt; &lt;title&gt;Frames&lt;/title&gt; &lt;/head&gt; &lt;frameset rows=\"160, *\"&gt; &lt;frame src=\"top-frame.html\" name=\"top\"&gt;&lt;/frame&gt; &lt;frameset cols=\"50%, 50%\"&gt; &lt;frame src=\"left-frame.html\" name=\"left\"&gt;&lt;/frame&gt; &lt;frame src=\"right-frame.html\" name=\"right\"&gt;&lt;/frame&gt; &lt;/frameset&gt; &lt;/frameset&gt;&lt;/html&gt;通过window对象的属性可以获取和调节窗口位置。使用下面代码可以跨浏览器获取窗口左边和上边的位置。使用moveTo和moveBy方法可以移动窗口调节位置，moveTo接受的参数是新位置的坐标，moveBy接受的参数是水平和垂直方向上的偏移量。(移动窗口的方法在某些浏览器中可能被禁用；这两个方法不适用于框架)12345var leftPos = (typeof window.screenLeft == \"number\") ? window.screenLeft : window.screenX;var topPos = (typeof window.screenTop == \"number\") ? window.screenTop : window.screenY;window.moveTo(0, 0); // 移动到屏幕左上角window.moveBy(0, 100); // 向下移动100像素通过window对象的属性可以获取和调节窗口大小。使用resizeTo和resizeBy方法可以调节窗口大小，resizeTo接受的参数是窗口的新宽度和高度，resizeBy接受的参数是新宽度高度与原来的宽度高度的差值。超时调用window对象的setTimeout方法用于超时调用，它接受两个参数：需要执行的代码和以毫秒为单位的时间数值。执行代码可以以字符串或函数的形式进行传参。这个方法的运行效果是使得传入参数的执行代码会在经过一段时间之后才开始执行。传递字符串可能导致性能损失，因此应该尽量以函数的形式传递需要执行的代码。另外，JS是一个单线程的解释器，一定时间内只能执行一段代码，为了控制要执行的代码，就有一个JS任务队列。这些任务会按照它们被添加到队列的顺序执行。setTimeout的第二个参数实际上是告诉JS再过多久之后把当前任务添加到任务队列，如果队列是空的，那么添加后任务就会马上执行，否则还需要等待队列前面的代码执行完之后才执行setTimeout第一个参数里面的任务。也就是说，即便我第二个参数指定为1秒，但是1秒过后任务不一定会准时执行。123456// 以字符串形式传入需要执行的代码，1000毫秒后输出'23333'setTimeout(\"console.log('23333')\", 1000);// 以函数形式传入需要执行的代码，2000毫秒后输出'hehe~'setTimeout(function() &#123; console.log('hehe~');&#125;, 2000);超时调用其他注意点：调用setTimeout之后会返回一个数值ID，通过这个ID可以来取消某个对应的超时调用。调用clearTimeout，将ID作为参数传入，即可取消该ID所对应的超时调用。超时调用的代码都是在全局作用域中执行，this的值在非严格模式下指向window对象，严格模式下为undefined。间歇调用间歇调用与超时调用类似，只不过它是按照指定的时间间隔重复执行代码，知道间歇调用被取消或者页面被卸载。设置间歇调用的方法是setInterval，接受的参数与setTimeout相同。setInterval方法也会返回一个ID，对应一个特定的间歇调用。取消间歇调用时，通过clearInterval方法即可完成。间歇调用也是在全局作用域中执行，this的值与超时调用一样。123456789var num = 1;var ID = null;ID = setInterval(function() &#123; console.log(num); num += 1; if (num == 5) &#123; clearInterval(ID); &#125;&#125;, 500);一般认为，使用超时调用模拟间歇调用是一种最佳模式，如以下代码示例。在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动，而使用超时调用，则可以完全避开这个缺点，保证先后顺序。123456789var num = 1;function func() &#123; console.log(num); num += 1; if (num &lt; 5) &#123; setTimeout(func, 500); &#125;&#125;setTimeout(func, 500);二、location对象location对象提供了与当前窗口中加载的文档有关的信息，还提供一些导航功能。location对象既是window对象的属性，也是document对象的属性，也就是说，window.location和document.location引用的是同一个对象。location对象可以将URL解析为独立的片段，让开发人员可以通过不同的的属性访问这些片段。下表列出location对象的所有属性并给出例子说明。属性名例子说明hash“#contents”URL中的hash(#号后面跟着的字符串，锚)host“www.wrox.com:80”服务器名称和端口号hostname“www.wrox.com”服务器名称href“http://www.wrox.com“完整的URLpathname“/WileyCDA”URL中的路径名port“80”端口号protocol“http”协议search“?q=javascript”查询字符串查询字符串：通过search属性可以获取查询字符串，但search属性返回的是从问号到URL结尾的所有内容，因此不能很好地方便我们访问查询字符串中的属性。在使用search属性获取查询字符串之后还需要再对其进行解析，然后才可以获取我们想要获得的属性和属性值。可以使用如下代码来解析查询字符串：123456789101112131415function getQueryStringArgs() &#123; var qs = (location.search.length &gt; 0 ? location.search.substring(1) : \"\"); var args = &#123;&#125;; var items = qs.length ? qs.split(\"&amp;\") : []; var item = null, name = null, value = null; for (var i = 0; i &lt; items.length; ++i) &#123; item = items[i].split(\"=\"); name = decodeURIComponent(item[0]); // 查询字符串一般是被编码过的，所以这里需要解码 value = decodeURIComponent(item[1]); if (name.length) &#123; args[name] = value; &#125; &#125; return args;&#125;位置操作：使用location对象可以改变浏览器的位置。下面给出代码示例。每次修改location的属性(hash属性除外)，页面都会以新的URL重新加载，页面刷新后浏览器的历史记录中会生成一条新纪录。如果想要仅跳转页面但是不产生历史记录，可以通过replace方法来实现。最后，location还有一个与位置相关的方法，reload，重新加载页面。1234567891011121314location.assign(\"http://www.wrox.com\");window.location = \"http://www.wrox.com\";location.href = \"http://www.wrox.com\";// 上面3种示例都是直接修改整个URL，下面给出只修改URL中的某个部分来改变位置的例子location.hash = \"#section1\";location.search = \"?q=javascript\";location.hostname = \"www.yahoo.com\";location.pathname = \"mydir\";location.port = 8080;// 使用replace不产生历史记录location.replace(\"http://www.wrox.com\");// 重新加载页面location.reload(); // 从服务器或浏览器缓存中重新加载location.reload(true); // 从服务器重新加载","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://hongchh.github.io/tags/JavaScript/"}]},{"title":"【分治策略】归并排序算法总结","slug":"【分治策略】归并排序算法总结","date":"2016-08-17T04:41:00.000Z","updated":"2017-11-10T12:45:36.338Z","comments":true,"path":"2016/【分治策略】归并排序算法总结/","link":"","permalink":"https://hongchh.github.io/2016/【分治策略】归并排序算法总结/","excerpt":"","text":"归并排序思想归并排序的思想很简单，拿到一个无序的序列，先从序列的中间位置将其切分成两个子序列，然后对两个子序列递归地进行归并排序，最后，将排好序的子序列合并成一个完整的有序序列。归并排序算法的伪代码如下：123456序列seq = [s1, s1, s3, ..., sn]归并排序： 将seq切分成两个部分seq1, seq2; 对seq1进行归并排序; 对seq2进行归并排序; 把seq1和seq1合并称为一个完整的序列seq;数组归并排序对数组进行归并排序，需要开一个临时数组以便合并时可以使用。在普通的数组归并排序实现中，空间开销可能会达到O(nlogn)或者更差的复杂度，这里介绍另外一种方式，在O(n)的空间开销内完成数组的归并排序。C++代码实现如下所示，以下面代码为例，在归并排序时，开了两个数组arr和tmp，通过不断交换两个数组来实现空间的高效利用。假如归并当前这一层需要将元素存在arr中，那么下一层就反过来将元素存在tmp中，就这样不断轮替，就不用再每一层的合并操作里都开临时数组去辅助实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;using namespace std;class SortingArray &#123;public: SortingArray(const int&amp; size): size(size) &#123; entry = new int[size]; &#125; ~SortingArray() &#123; if (entry != NULL) &#123; delete [] entry; &#125; &#125; int operator[](int i) const &#123; return entry[i%size]; &#125; int&amp; operator[](int i) &#123; return entry[i%size]; &#125; void sort() &#123; int* tmp = new int[size]; // 临时数组 mergeSort(entry, tmp, 0, size-1, true); delete [] tmp; &#125;private: void mergeSort(int* arr, int* tmp, int beg, int end, bool inArr) &#123; if (beg &lt; end) &#123; int mid = (beg + end) / 2; mergeSort(arr, tmp, beg, mid, !inArr); mergeSort(arr, tmp, mid+1, end, !inArr); // arr和tmp轮替 if (inArr) &#123; merge(arr, tmp, beg, mid, end); &#125; else &#123; merge(tmp, arr, beg, mid, end); &#125; &#125; else &#123; // 如果到最后一层需要考虑这层的元素是否需要转移到tmp上 if (!inArr) tmp[beg] = arr[beg]; &#125; &#125; void merge(int* arr1, int* arr2, int beg, int mid, int end) &#123; int i = beg, j = mid+1, k = beg; while (i != mid+1 &amp;&amp; j != end+1) &#123; if (arr2[i] &lt; arr2[j]) arr1[k++] = arr2[i++]; else arr1[k++] = arr2[j++]; &#125; while (i != mid+1) arr1[k++] = arr2[i++]; while (j != end+1) arr1[k++] = arr2[j++]; &#125; int* entry; int size;&#125;;int main() &#123; int size; cin &gt;&gt; size; SortingArray sa(size); for (int i = 0; i &lt; size; ++i) &#123; cin &gt;&gt; sa[i]; &#125; sa.sort(); for (int i = 0; i &lt; size; ++i) &#123; cout &lt;&lt; sa[i] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; return 0;&#125;链表归并排序对链表进行归并排序就比较简单且高效了，不仅时间复杂度只有O(nlogn)，而且空间复杂度仅为O(1)。主要流程还是一样，切分，排序，合并。不过，在对链表沿着中间点切分成两部分可能要麻烦点，我这里采取的方法是常见的链表切分方法，快慢指针法。具体的C++代码实现如下所示，切分链表时，定义两个指针，一个快指针和一个慢指针，快指针一次移动2步，慢指针一次移动1步，当快指针到达链表末尾时，慢指针的位置就是链表中点。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;iostream&gt;using namespace std;struct Node &#123; Node(int entry = 0, Node* next = NULL): entry(entry), next(next) &#123;&#125; int entry; Node* next;&#125;;class SortingList &#123;public: SortingList(): head(NULL), last(NULL) &#123;&#125; ~SortingList() &#123; while (head != NULL) &#123; Node* tmp = head; head = head-&gt;next; delete tmp; &#125; &#125; void push(const int&amp; e) &#123; if (head == NULL) &#123; head = new Node(e); last = head; &#125; else &#123; last-&gt;next = new Node(e); last = last-&gt;next; &#125; &#125; void sort() &#123; // 排序可能使得头尾节点产生变化，注意重新调整 head = mergeSort(head); last = head; while (last != NULL &amp;&amp; last-&gt;next != NULL) last = last-&gt;next; &#125; int pop() &#123; int e = head-&gt;entry; Node* tmp = head; head = head-&gt;next; delete tmp; return e; &#125;private: // 需要注意排序使得结点顺序改变可能导致头指针发生变化，因此需要返回新的头指针 Node* mergeSort(Node* subList) &#123; if (subList != NULL &amp;&amp; subList-&gt;next != NULL) &#123; Node* mid = divideIntoTwoList(subList); subList = mergeSort(subList); mid = mergeSort(mid); subList = merge(subList, mid); &#125; return subList; &#125; // 快慢指针法切分链表 Node* divideIntoTwoList(Node* subList) &#123; Node* fast = subList-&gt;next; Node* slow = subList; while (fast != NULL) &#123; fast = fast-&gt;next; if (fast != NULL) &#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; &#125; fast = slow-&gt;next; slow-&gt;next = NULL; return fast; &#125; // 合并两个链表，空间开销O(1) Node* merge(Node* list1, Node* list2) &#123; Node fakeHead; Node* last = &amp;fakeHead; while (list1 != NULL &amp;&amp; list2 != NULL) &#123; if (list1-&gt;entry &lt; list2-&gt;entry) &#123; last-&gt;next = list1; list1 = list1-&gt;next; &#125; else &#123; last-&gt;next = list2; list2 = list2-&gt;next; &#125; last = last-&gt;next; &#125; if (list1 != NULL) last-&gt;next = list1; else last-&gt;next = list2; return fakeHead.next; &#125; Node* head; Node* last;&#125;;int main() &#123; int n, e; cin &gt;&gt; n; SortingList sl; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; e; sl.push(e); &#125; sl.sort(); for (int i = 0; i &lt; n; ++i) &#123; cout &lt;&lt; sl.pop() &lt;&lt; ' '; &#125; cout &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hongchh.github.io/tags/数据结构与算法/"}]},{"title":"JavaScript模仿块级作用域与私有变量","slug":"JavaScript模仿块级作用域与私有变量","date":"2016-08-17T01:53:00.000Z","updated":"2017-11-10T12:41:57.801Z","comments":true,"path":"2016/JavaScript模仿块级作用域与私有变量/","link":"","permalink":"https://hongchh.github.io/2016/JavaScript模仿块级作用域与私有变量/","excerpt":"","text":"一、块级作用域JS没有块级作用域的概念，定义在块语句中的变量，实际上是在包含函数中而非语句中创建的，如下面例子，变量i和j创建之后即便离开了块语句，只要还在包含函数func中，就可以访问到这两个变量。必须等到函数func执行完毕销毁作用域之后，变量i和j才会被销毁。123456789101112function func(count) &#123; for (var i = 0; i &lt; count; ++i) &#123; console.log(i); &#125; console.log(i); // 可以访问到i，输出5 &#123; var j = '2333'; &#125; console.log(j); // 可以访问到j，输出2333&#125;func(5);使用一个匿名立即调用函数就可以解决这个问题，模拟出块级作用域的效果。具体的语法如下，将块级作用域的内容放在这个匿名函数的函数体中，在这个匿名函数中定义的变量在函数执行完毕之后都会销毁，因此，外部访问不到块级作用域中的变量。这种技术经常在全局作用域中被用在函数外部，避免向全局作用域中添加过多的变量和函数。在多人协作开发的项目中，过多的全局变量和函数名常常会导致命名冲突，通过这种技术可以创建自己的私有作用域，不用再担心变量的命名，也不会搞乱全局作用域。123(function() &#123; // 模拟块级作用域&#125;)();二、私有变量JS没有私有成员的概念，所有对象的属性都是公有的，外部都可以访问到。不过倒是有私有变量的概念，例如函数中定义的变量都可以被认为是私有变量，因为只能在函数内部访问到这些变量。下面介绍几种JS中创建私有变量常用的模式。1. 构造函数内构建闭包通过在函数内部创建闭包，那么闭包通过自己的作用域链可以访问这些私有变量，利用闭包，创建用于访问私有变量的公有方法(特权方法)。如下面代码示例，privateVar和privateFunc都位于闭包函数publicFunc的作用域链上，外部访问不到，只能通过publicFunc函数来访问。这种在构造函数中定义特权方法的方式有一个缺点，这个缺点就是构造函数模式下，每次创建对象的时候构造函数中的每个方法(无论公有或私有)都会被重新创建一遍。123456789101112131415161718function MyObject() &#123; // 私有变量和函数 var privateVar = 1; function privateFunc() &#123; return true; &#125; // 特权方法 this.publicFunc = function() &#123; privateVar += 1; // 访问私有变量 if (privateFunc()) &#123; // 调用私有方法 console.log(privateVar); &#125; &#125;;&#125;var obj = new MyObject();obj.publicFunc(); // 输出22. 静态私有变量这种模式创建了一个私有作用域，并在其中封装了一个构造函数及相应的方法。在私有作用域中定义了私有变量和私有函数，然后定义构造函数和公有方法，公有方法在原型上定义。定义构造函数时不使用函数声明，而是直接使用函数表达式，并且不使用var关键字定义，目的是为了让构造函数变成一个全局函数，在私有作用域之外可以访问到构造函数，这样我们才可以创建对象。(严格模式下不允许给未经声明的变量赋值，因此不能使用这种方法)。这种模式下，特权方法在原型上定义，因此所有实例都使用同一个函数，这个特权方法作为一个闭包也总是引用私有作用域中的函数和变量，因此，这种模式下私有变量与函数都是有实例共享的，解决了构造函数模式下的多次创建问题。12345678910111213141516171819// 私有作用域(function() &#123; // 静态私有成员和方法 var staticPrivateVar = '2333'; function staticPrivateFunc() &#123; console.log('static'); &#125; // 构造函数 MyObject = function() &#123;&#125; // 公有方法 MyObject.prototype.publicFunc = function() &#123; console.log(staticPrivateVar); // 访问私有变量 staticPrivateFunc(); // 调用私有方法 &#125;&#125;)();// 全局作用域var obj = new MyObject();obj.publicFunc(); // 输出\"2333\"和\"static\"3. 模块模式模块模式的存在是为了给单例创建私有变量和方法使单例得到增强，这种模式的语法如下，使用一个返回对象的匿名立即调用函数，在这个函数内部，首先定义了私有变量和函数，然后将一个对象字面量作为函数的返回值返回。返回的对象字面量中仅包含可以公开的属性方法。如果需要创建一个对象并对某些数据进行初始化，同时还要公开一些能够访问私有数据的方法，那么就可以使用模块模式。通过这种模式创建的对象都是Object的实例，没有特定属于某一种类型，因此不适用与instanceof之类的操作符。12345678910111213141516171819var singleton = (function() &#123; // 私有变量和函数 var privateVar = '2333'; function privateFunc() &#123; return true; &#125; // 公有变量和函数 return &#123; publicVar: 'hehe~', publicFunc: function() &#123; if (privateFunc()) &#123; // 调用私有函数 console.log(privateVar); // 访问私有变量 &#125; &#125; &#125;;&#125;)();singleton.publicFunc(); // 输出'2333'console.log(singleton.publicVar); // 输出'hehe~'4. 增强的模块模式这种模式解决了上面说到的模块模式无法检查类型的问题，具体做法就是使用某种类型的实例，然后在匿名立即调用函数返回之前给对象加入属性方法，具体语法如下。这种模式创建的单例对象属于某种特定的类型，可以使用instanceof操作进行检测。123456789101112131415161718192021222324// 某种自定义类型function SomeType() &#123;&#125;var singleton = (function() &#123; // 私有变量和函数 var privateVar = '2333'; function privateFunc() &#123; return true; &#125; // 创建对象 var object = new SomeType(); // 公有变量和函数 object.publicVar = 'hehe~'; object.publicFunc = function() &#123; if (privateFunc()) &#123; // 调用私有函数 console.log(privateVar); // 访问私有变量 &#125; &#125; // 返回对象 return object;&#125;)();singleton.publicFunc(); // 输出'2333'console.log(singleton.publicVar); // 输出'hehe~'console.log(singleton instanceof SomeType); // 检测类型，输出'true'","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://hongchh.github.io/tags/JavaScript/"}]},{"title":"JavaScript闭包的原理与缺陷","slug":"JavaScript闭包的原理与缺陷","date":"2016-08-16T08:37:00.000Z","updated":"2017-11-10T12:36:00.874Z","comments":true,"path":"2016/JavaScript闭包的原理与缺陷/","link":"","permalink":"https://hongchh.github.io/2016/JavaScript闭包的原理与缺陷/","excerpt":"","text":"闭包的原理闭包是指有权访问另一个函数作用域中的变量的函数。根据下面的代码示例来理解什么是闭包，在add函数内部的匿名函数中，访问到外部函数的变量outerArg，在执行add(10)之后外部函数返回了，并且将内部的匿名函数赋值给了变量addTen，此时通过addTen调用函数，依然可以访问到outerArg，也就是10。这个闭包中的变量，只能通过调用addTen函数访问，无法通过其他渠道访问到，下面代码最后一行通过输出属性的方式尝试访问结果是输出undefined。outerArg是属于add函数的作用域中的变量，addTen有权访问add函数作用域中的变量，因此addTen是一个闭包。闭包产生的本质是：在一个函数(外部函数)内部定义的函数(内部函数)会将外部函数作用域中的活动对象添加到自己的作用域链中，下面代码中inner函数将add函数的outerArg添加到自己的作用域链上。在add函数执行完之后，其执行环境会被销毁，但由于inner函数还在引用outerArg，所以outerArg不会被销毁，依然保留在inner函数的作用域链中。直到inner函数(addTen函数)被销毁之后，outerArg才会跟着其作用域链一起被销毁。由于闭包变量是位于作用域链上，因此必须调用闭包函数进入其作用域之后才能访问到闭包变量。123456789101112function add(outerArg) &#123; function inner(innerArg) &#123; return innerArg + outerArg; &#125; return inner;&#125;var addTen = add(10);console.log(addTen(1)); // 输出11console.log(addTen(2)); // 输出12console.log(addTen(3)); // 输出13console.log(addTen.outerArg); // undefined闭包的缺陷首先，闭包会将外部函数的活动对象都添加到自己的作用域链中，因此相对于普通的函数会更加耗费内存。其次，闭包只能获取到外部函数中任何变量的最后一个值。如下面代码所示，在for循环中的匿名函数可以访问到闭包变量i，但是由于闭包所保存的是整个变量对象，因此所有闭包函数中访问到的变量i其实就是同一个变量i(Outer函数的变量i)，而Outer函数在执行完毕后，其变量i的值为5，所以5个闭包函数访问到的值都是5。12345678910111213141516function Outer() &#123; var arr = new Array(); for (var i = 0; i &lt; 5; ++i) &#123; arr[i] = function() &#123; return i; &#125;; &#125; return arr;&#125;var arr = Outer();console.log(arr[0]()); // 输出5console.log(arr[1]()); // 输出5console.log(arr[2]()); // 输出5console.log(arr[3]()); // 输出5console.log(arr[4]()); // 输出5最后，this对象的指向可能与预期的不一致。以下面代码为例，getName的执行结果是输出Window而不是someObj，原因就是getNameFunc函数返回之后，它的执行环境会被销毁，返回的函数赋值给getName，当我执行getName的时候执行环境实在全局环境下，this指向的对象是window，this.name引用到的是全局作用域下的name，也就是&#39;Window&#39;。1234567891011var name = 'Window';var someObj = &#123; name: 'someObj', getNameFunc: function() &#123; return function() &#123; return this.name; &#125; &#125;&#125;;var getName = someObj.getNameFunc();console.log(getName()); // 输出'Window'闭包缺陷的解决方案对于闭包只能获取到外部函数中任何变量的最后一个值问题，可通过定义一个立即执行函数(IIFE)来解决。这种方法的原理其实是在执行立即调用函数时，传入变量i作为参数，而i是按值传递的，相当于复制了一次i的值，所以5次循环调用了5次函数复制了5个不同的i的值创建了5个值不同的变量num，而内部函数(这里指代码中注释inner处的函数)的闭包变量不在是引用i，而是引用了变量num。每个内部函数都有其对应的闭包变量num，这个时候闭包函数的行为就符合我们的预期效果了。12345678910111213141516171819function Outer() &#123; var arr = new Array(); for (var i = 0; i &lt; 5; ++i) &#123; arr[i] = function(num) &#123; // inner return function() &#123; return num; &#125; &#125;(i); &#125; return arr;&#125;var arr = Outer();console.log(arr[0]()); // 输出0console.log(arr[1]()); // 输出1console.log(arr[2]()); // 输出2console.log(arr[3]()); // 输出3console.log(arr[4]()); // 输出4对于this对象问题，可以通过避免直接使用this对象的方式来解决。这种方式其实是给this对象起了个别名，用that指向外部函数作用域的this对象，然后在内部函数中引用that，将其加入到闭包中，这样就可以正确地访问到外部函数作用域的this对象了。123456789101112var name = 'Window';var someObj = &#123; name: 'someObj', getNameFunc: function() &#123; var that = this; // 别名 return function() &#123; return that.name; &#125; &#125;&#125;;var getName = someObj.getNameFunc();console.log(getName()); // 输出'someObj'最后，分享一个实用的闭包内存优化技巧。闭包会引用外部函数的整个活动对象，这种机制可能会导致保存多余的变量而造成内存浪费，以下面代码为例，内部函数仅仅引用了obj对象的id属性，而闭包会把整个obj对象都保存下来，如果该对象上有很多耗费内存的属性，那么这种简单的引用方式会导致产生一个很大的闭包。优化方式如AnotherOuter函数的写法所示，关键在于把需要引用的变量保存下来，然后通过把obj对象设置为null让它丢失引用以便被自动内存回收机制回收处理，这样，闭包函数引用的就只有id这个变量了。123456789101112131415161718192021function Outer() &#123; var obj = &#123;&#125;; obj.id = '12345678'; obj.name = 'aha'; // ... 假设经过很多处理过程，最后obj上带有很多属性 return function() &#123; return obj.id; &#125;;&#125;function AnotherOuter() &#123; var obj = &#123;&#125;; obj.id = '12345678'; obj.name = 'aha'; // ... 假设经过很多处理过程，最后obj上带有很多属性 var id = obj.id; obj = null; return function() &#123; return id; &#125;;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://hongchh.github.io/tags/JavaScript/"}]},{"title":"【贪心算法】Huffman编码","slug":"【贪心算法】Huffman编码","date":"2016-08-16T03:04:00.000Z","updated":"2017-11-10T12:27:40.188Z","comments":true,"path":"2016/【贪心算法】Huffman编码/","link":"","permalink":"https://hongchh.github.io/2016/【贪心算法】Huffman编码/","excerpt":"","text":"问题描述有一组字符集{c1, c2, ..., cn}，在使用这组字符集的过程中，通过统计发现每个字符都有其相应的出现频率，假设对应的频率为{f1, f2, ..., fn}。现在需要对这些字符进行二进制编码，我们希望的编码结果如下：每个字符都有其独一无二的编码；编码长度是变长的，频率大的字符使用更少的二进制位进行编码，频率小的字符则使用比较多的二进制位进行编码，使得最终的平均编码长度达到最短；每个字符的编码都有特定的前缀，一个字符的编码不可能会是另一个字符的前缀，这样我们可以在读取编码时，当读取的二进制位可以对应一个字符时，就读取出该字符。举个例子，假如我们有字符集{&#39;a&#39;, &#39;b&#39;, &#39;c&#39;}，字符&#39;a&#39;的编码为001，字符&#39;b&#39;的编码为010，那么此时c的编码不能为00或者01，这样我们才能识别&#39;a&#39;和&#39;c&#39;或者&#39;b&#39;和&#39;c&#39;。算法描述上述问题可以使用Huffman编码来解决，Huffman编码实际上是一个贪心算法。在这个算法中，使用二叉树来表示前缀码，每个字符都是树的叶子结点，非叶子结点则不代表任何字符。将每个字符构造成结点形成结点集S，每次都从结点集S中选出频率最低的两个结点x和y作为子节点进行建树，为这两个子结点构造一个父节点，父节点不保存任何字符，父节点的频率为两个子节点频率之和，将两个子节点从S中移走，将父节点加入S中。不断迭代下去，直到S只剩一个结点时，这个结点就是树的根节点。这样我们就得到了一棵Huffman树，整个过程就是一个自底向上的建树过程。由于从根节点到每个叶子节点有且仅有一条路径，所以，每个叶子的路径都是不一样的，唯一的。我们把从根节点到叶子节点的路径记录下来，便可作为叶子节点上字符的编码。初始化编码为空，从根节点开始，往左走则编码加0，往右走则编码加1，具体展示图如下所示：建树过程的伪代码如下：123456789101112给定字符集C=&#123;c1,c2,...,cn&#125;，每个字符ci都有相应的频率fi根据字符集构建结点集S=&#123;s1,s2,...,sn&#125;，每个结点si保存有字符ci和频率fi的信息while |S| != 1 do 取出S中频率最小的两个结点x和y; 构造父节点z; z.f = x.f + y.f; z.c = undefined; z.left = x; z.right = y; 将x和y从S中移走，将z加入S;endWhile此时S[0]就是根节点，返回根节点最后整个Huffman编码过程的C++实现如下(建树+编码)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;/* Huffman树的节点 */struct Node &#123; Node() &#123;&#125; Node(int frequency, char ch, Node* left, Node* right) &#123; this-&gt;frequency = frequency; this-&gt;ch = ch; this-&gt;left = left; this-&gt;right = right; &#125; int frequency; char ch; Node* left; Node* right;&#125;;class HuffmanCode &#123;public: HuffmanCode() &#123;&#125; ~HuffmanCode() &#123; if (nvec.size() &gt; 0) clear(nvec[0]); &#125; /* 建树 */ void buildTree(const char* ch, const int* fq, const int&amp; size) &#123; for (int i = 0; i &lt; size; ++i) &#123; Node* node = new Node(fq[i], ch[i], NULL, NULL); nvec.push_back(node); &#125; while (nvec.size() != 1) &#123; Node* x = getMinNodeAndRemoveIt(); Node* y = getMinNodeAndRemoveIt(); Node* z = new Node(x-&gt;frequency + y-&gt;frequency, '\\0', x, y); nvec.push_back(z); &#125; &#125; /* 编码 */ void buildCode() &#123; buildCodeByDFS(nvec[0], \"\"); &#125; /* 获取特定字符的编码 */ string getCode(char ch) &#123; return code[ch]; &#125;private: /* 清空Huffman树，释放资源 */ void clear(Node* root) &#123; if (root != NULL) &#123; clear(root-&gt;left); clear(root-&gt;right); delete root; &#125; &#125; /* 获取结点集中频率最小的结点并将其移出结点集 */ Node* getMinNodeAndRemoveIt() &#123; int min = 0; for (int i = 1; i &lt; nvec.size(); ++i) &#123; if (nvec[i]-&gt;frequency &lt; nvec[min]-&gt;frequency) &#123; min = i; &#125; &#125; Node* tmp = nvec[nvec.size() - 1]; nvec[nvec.size() - 1] = nvec[min]; nvec[min] = tmp; tmp = nvec[nvec.size() - 1]; nvec.pop_back(); return tmp; &#125; /* 遍历Huffman树进行编码 */ void buildCodeByDFS(Node* r, string str) &#123; if (r-&gt;left == NULL &amp;&amp; r-&gt;right == NULL) code[r-&gt;ch] = str; if (r-&gt;left != NULL) buildCodeByDFS(r-&gt;left, str + \"0\"); if (r-&gt;right != NULL) buildCodeByDFS(r-&gt;right, str + \"1\"); &#125; vector&lt;Node*&gt; nvec; // 结点集 map&lt;char, string&gt; code; // 字符编码&#125;;int main() &#123; char ch[100]; int fq[100], size; cin &gt;&gt; size; if (size &lt;= 0 || size &gt; 100) &#123; cout &lt;&lt; \"字符集大小不合适\" &lt;&lt; endl; return -1; &#125; for (int i = 0; i &lt; size; ++i) &#123; cin &gt;&gt; ch[i] &gt;&gt; fq[i]; &#125; HuffmanCode hfmc; hfmc.buildTree(ch, fq, size); hfmc.buildCode(); string code; for (int i = 0; i &lt; size; ++i) &#123; code = hfmc.getCode(ch[i]); cout &lt;&lt; ch[i] &lt;&lt; \": \" &lt;&lt; code &lt;&lt; endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hongchh.github.io/tags/数据结构与算法/"}]},{"title":"【贪心算法】Kruskal算法的实现与应用","slug":"【贪心算法】Kruskal算法的实现与应用","date":"2016-08-14T05:56:00.000Z","updated":"2017-11-10T12:23:20.305Z","comments":true,"path":"2016/【贪心算法】Kruskal算法的实现与应用/","link":"","permalink":"https://hongchh.github.io/2016/【贪心算法】Kruskal算法的实现与应用/","excerpt":"","text":"问题背景假设我们有n个位置的集合V={v1, v2, ..., vn}，我们想在它们顶部建立一个通信网络，网络应该是连通的，即任何两个位置vi和vj之间至少存在一条路径可以相互到达。对于确定的两个位置(vi,vj)，假设在这两个位置之间建立网络连接的费用为c(i,j)，c(i,j) &gt; 0。将上述问题抽象成一个无向图G=(V,E)，用图来表示可能被建立的链接的集合，图的每个结点代表每个位置，图的每条边e的长度表示该边连接的两个结点vi和vj之间建立网络连接的费用c(i,j)。为了求得最小的建造费用，只需要找到n-1条边将n个结点连接起来并确保图的连通性，然后这n-1条边的权值尽可能小。抽象为图之后上述问题可以用最小生成树模型来解决。算法描述Kruskal算法是用于解决最小生成树问题的一种优秀的算法，其主要思路是，先将原图G的所有边按照权值大小进行排序，同时假定我们有一个n个结点，但是还没有边的子图T。每次都从G的边中取出权值最小的边e并尝试加入到子图T中，加入e时需要保持子图T中不能产生环，如果加入e之后会产生环则放弃该边，否则把边e加入子图T。重复这样的操作，直到子图T变成一个连通图时结束算法，对于一个有n个结点的图，等价于在得到n-1条边时就可以结束算法了。Kruskal算法的过程展示图如下所示：算法实现要实现kruskal算法，先来了解一些背景知识，【图的连通分支】，一个图被分成几个小块，每个小块都是连通的。小块与小块之间不连通，那么每个小块称为一个连通分支。一个孤立结点也算一个连通分支。下面，还要需要了解一种数据结构，这里我暂且将它称为MergeQuery数据结构。在Kruskal算法中，当考虑一条边e = (u, v)时，我们需要有效地找出包含结点u和v的连通分支。如果两个连通分支不同，u和v位于不同的连通分支，不存在连接结点u和v的路径，此时边e可以加入到最小生成树中。如果连通分支相同，那么u和v处于同一个连通分支中，也就是已经存在一条从u到v路径，此时边e不能加入最小生成树(加入的话会产生环)。接着，我们在考虑如果一条边e连接的结点u和v位于不同的连通分支可以加入的情况，此时将边e加入之后，u和v就连通了，原本u和v所在的两个连通分支也将合并称为一个连通分支。MergeQuery数据结构将用于支持Kruskal算法的相关操作，该数据结构维护不相交的集合(即图的连通分支)，对于一个结点u，操作query(u)返回包含u的集合的名字。若query(u) == query(v)则说明u和v位于同一连通分支。此外还有一个操作merge(A, B)，用于将两个集合合并为一个集合(两个连通分支合并)。在Kruskal算法中，选取权值最小的边e = (u, v)之后，先使用query操作检测u和v是否位于同一连通分支，若是则放弃这条边，如果不是，则加入边e，使用merge(A, B)将u和v所在的两个连通分支合并。实现MergeQuery的一种简单的数据结构：维护一个数组component，假设图有n个结点{1, 2, ..., n}，创建一个长度为n的component数组，初始化component[i] = i。查找操作query(u)可以用O(1)的时间给出一个结点u所属的集合，合并操作merge(A, B)则需要O(n)的时间来合并两个集合。merge(A, B)的实现如下，任意选择一个保留的集合名，比如选到A，对于另一个集合B中的所有元素i都令component[i] = A。最后，基于kruskal算法的特点，我们存储一个图的方式将不会使用邻接表或者邻接矩阵，而是直接存储边，具体的数据结构如下所示，重载小于操作符的目的是为了方便对边进行排序。123456789101112struct Edge &#123; Edge(int vertex1 = 0, int vertex2 = 0, int weight = 0) &#123; this-&gt;vertex1 = vertex1; this-&gt;vertex2 = vertex2; this-&gt;weight = weight; &#125; int vertex1, vertex2, weight;&#125;;bool operator&lt;(const Edge&amp; e1, const Edge&amp; e2) &#123; return e1.weight &lt; e2.weight;&#125;最后，kruskal算法的整个算法流程的伪代码实现如下所示：12345678910111213输入为n个结点m条边的图，每条边都带有一个权值w对所有边按照权值大小进行排序，排序结果为&#123;e1,e2,...,em&#125;初始化MergeQuery数据结构mq，结点数量为nminimalSpanningTree = &#123;&#125;;for i=1 to m, do A = mq.query(ei.u); B = mq.query(ei.v); if A != B mq.merge(A, B, ei); 将边ei加入minimalSpanningTree; endIfendForreturn minimalSpanningTree;整个算法的C++实现如下，下面代码运行之后会输出一个连通图，该图为原图的最小生成树。同时还会输出最小生成树所有边的权值的和。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAX_VERTEX_NUM = 10;struct Edge &#123; Edge(int vertex1 = 0, int vertex2 = 0, int weight = 0) &#123; this-&gt;vertex1 = vertex1; this-&gt;vertex2 = vertex2; this-&gt;weight = weight; &#125; int vertex1, vertex2, weight;&#125;;bool operator&lt;(const Edge&amp; e1, const Edge&amp; e2) &#123; return e1.weight &lt; e2.weight;&#125;class MergeQuery &#123;public: MergeQuery(const int&amp; vertexNum): vertexNum(vertexNum) &#123; component = new int[vertexNum]; for (int i = 0; i &lt; vertexNum; ++i) &#123; component[i] = i; &#125; &#125; ~MergeQuery() &#123; if (component != NULL) delete [] component; &#125; int query(const int&amp; vertex) const &#123; return component[vertex]; &#125; void merge(int A, int B) &#123; for (int i = 0; i &lt; vertexNum; ++i) &#123; if (component[i] == B) component[i] = A; &#125; &#125;private: int vertexNum; int* component;&#125;;class Kruskal &#123;public: Kruskal(const int&amp; vertexNum, const int&amp; edgeNum) &#123; this-&gt;vertexNum = vertexNum; this-&gt;edgeNum = edgeNum; mq = new MergeQuery(vertexNum); edges = new Edge[edgeNum]; minimalSpanningTree = new int[vertexNum-1]; &#125; ~Kruskal() &#123; if (mq != NULL) delete mq; if (edges != NULL) delete [] edges; &#125; void getEdge() &#123; for (int i = 0; i &lt; edgeNum; ++i) &#123; cin &gt;&gt; edges[i].vertex1 &gt;&gt; edges[i].vertex2 &gt;&gt; edges[i].weight; &#125; &#125; void minimalSpanning() &#123; sort(edges, edges + edgeNum); int treeEdgeNum = 0; for (int i = 0; i &lt; edgeNum; ++i) &#123; int A = mq-&gt;query(edges[i].vertex1); int B = mq-&gt;query(edges[i].vertex2); if (A != B) &#123; mq-&gt;merge(A, B); minimalSpanningTree[treeEdgeNum++] = i; &#125; &#125; &#125; void getTree() &#123; int weightSum = 0; cout &lt;&lt; \"最小生成树: (v1, v2, weight)\" &lt;&lt; endl; for (int i = 0; i &lt; vertexNum-1; ++i) &#123; weightSum += edges[minimalSpanningTree[i]].weight; cout &lt;&lt; edges[minimalSpanningTree[i]].vertex1 &lt;&lt; ' ' &lt;&lt; edges[minimalSpanningTree[i]].vertex2 &lt;&lt; ' ' &lt;&lt; edges[minimalSpanningTree[i]].weight &lt;&lt; endl; &#125; cout &lt;&lt; \"最小生成树边权值总和为: \" &lt;&lt; weightSum &lt;&lt; endl; &#125;private: int vertexNum; int edgeNum; int* minimalSpanningTree; MergeQuery* mq; Edge* edges;&#125;;int main() &#123; int vertexNum, edgeNum; cin &gt;&gt; vertexNum &gt;&gt; edgeNum; if (vertexNum &gt; MAX_VERTEX_NUM) &#123; cout &lt;&lt; \"结点数量过多\" &lt;&lt; endl; return -1; &#125; Kruskal k(vertexNum, edgeNum); k.getEdge(); // 输入图的所有边 k.minimalSpanning(); // kruskal最小生成树算法 k.getTree(); // 输出结果 return 0;&#125;Kruskal算法的其他应用—聚类最大间隔聚类：给定集合U = {p1, p2, ..., pn}，对于每对个体pi和pj，d(pi, pj)表示两个个体之间的距离，规定d(pi, pi)=0，d(pi, pj) &gt; 0(i != j)，并且d(pi, pj) = d(pj, pi)。给定参数k(k &lt;= n)，将U中的个体划分称为k组，则一个U的k聚类是把U分成k个非空集合C1, C2, ..., Ck的划分。我们希望每个聚类内部的点都尽可能地聚集，密集程度尽可能高，而位于两个不同聚类中的点尽可能地相互远离，寻找具有最大可能间隔的k聚类。在此，我们定义一个k聚类的间隔是处在两个不同聚类中的任何一对点之间的距离的最小值，简单点说就是k个聚类里面任意两个聚类之间的距离的最小值，我们希望这个最小值是所有可能的划分中最大的，这样，k个聚类就能最大程度地远离彼此。最大间隔聚类问题可以使用kruskal算法来解决。把集合U中的个体看成结点，个体之间的距离看成边，在集合U上生成一个具有k个连通分支的图，这k个连通分支就是k个聚类。在生成图的过程中都将邻近点尽可能地一起带入同一个聚类中。通过对前面kruskal算法的理解我们可以知道，算法开始会初始化n个连通分支，然后每次加入一条边就相当于合并两个连通分支，知道最后剩下一个连通分支时就是最小生成树了。那，我们把终止条件修改一下，在使用Kruskal最小生成树算法时，一旦得到k个连通分支就停止算法，由于Kruskal算法每次加入新边时都是考虑权值最小的边，因此，当得到K个连通分支时，还未加入的k-1条边中其实就是最小生成树中距离最大的k-1条边，因此，当去掉这最长的k-1条边时得到的这k个聚类的间隔也是最大的。若图有n个结点，那么最小生成树有n-1边，要在加入最小生成树的最后k-1边时结束算法，那么最后得到的k个连通分支一共有n-k条边，也就是算法在加入n-k条边之后即可停止了。最后算法的伪代码如下所示：123456789101112131415输入n个结点m条边的图，每条边都带有一个权值w对所有边按照权值大小进行排序，排序结果为&#123;e1,e2,...,em&#125;初始化MergeQuery数据结构mq，结点数量为nKCluster = &#123;&#125;;edgeNum = 0;for i=1 to m &amp;&amp; edgeNum != n-k, do A = mq.query(ei.u); B = mq.query(ei.v); if A != B mq.merge(A, B, ei); 将边ei加入KCluster; edgeNum = edgeNum + 1; endIfendForreturn KCluster;可以回顾上面的kruskal算法流程图，假如我们要聚出3个类，那么在进行到(d)这一步即可停止算法了，此时的3个连通分支就是3个最大间隔聚类，{v1, v3}，{v2, v5}，{v4, v6}。上述伪代码的C++实现如下，下面代码运行之后输出结果为一个包含k个连通分支的图，每个连通分支代表一个聚类。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAX_VERTEX_NUM = 10;struct Edge &#123; Edge(int vertex1 = 0, int vertex2 = 0, int weight = 0) &#123; this-&gt;vertex1 = vertex1; this-&gt;vertex2 = vertex2; this-&gt;weight = weight; &#125; int vertex1, vertex2, weight;&#125;;bool operator&lt;(const Edge&amp; e1, const Edge&amp; e2) &#123; return e1.weight &lt; e2.weight;&#125;class MergeQuery &#123;public: MergeQuery(const int&amp; vertexNum): vertexNum(vertexNum) &#123; component = new int[vertexNum]; for (int i = 0; i &lt; vertexNum; ++i) &#123; component[i] = i; &#125; &#125; ~MergeQuery() &#123; if (component != NULL) delete [] component; &#125; int query(const int&amp; vertex) const &#123; return component[vertex]; &#125; void merge(int A, int B) &#123; for (int i = 0; i &lt; vertexNum; ++i) &#123; if (component[i] == B) component[i] = A; &#125; &#125;private: int vertexNum; int* component;&#125;;class Kruskal &#123;public: Kruskal(const int&amp; vertexNum, const int&amp; edgeNum, const int&amp; KCluster) &#123; this-&gt;vertexNum = vertexNum; this-&gt;edgeNum = edgeNum; this-&gt;KCluster = KCluster; mq = new MergeQuery(vertexNum); edges = new Edge[edgeNum]; minimalSpanningTree = new int[vertexNum-KCluster]; &#125; ~Kruskal() &#123; if (mq != NULL) delete mq; if (edges != NULL) delete [] edges; &#125; void getEdge() &#123; for (int i = 0; i &lt; edgeNum; ++i) &#123; cin &gt;&gt; edges[i].vertex1 &gt;&gt; edges[i].vertex2 &gt;&gt; edges[i].weight; &#125; &#125; void minimalSpanning() &#123; sort(edges, edges + edgeNum); int treeEdgeNum = 0; for (int i = 0; i &lt; edgeNum &amp;&amp; treeEdgeNum &lt; vertexNum-KCluster; ++i) &#123; int A = mq-&gt;query(edges[i].vertex1); int B = mq-&gt;query(edges[i].vertex2); if (A != B) &#123; mq-&gt;merge(A, B); minimalSpanningTree[treeEdgeNum++] = i; &#125; &#125; &#125; void getTree() &#123; int weightSum = 0; cout &lt;&lt; \"K聚类-结果图: (v1, v2, weight)\" &lt;&lt; endl; for (int i = 0; i &lt; vertexNum-KCluster; ++i) &#123; cout &lt;&lt; edges[minimalSpanningTree[i]].vertex1 &lt;&lt; ' ' &lt;&lt; edges[minimalSpanningTree[i]].vertex2 &lt;&lt; ' ' &lt;&lt; edges[minimalSpanningTree[i]].weight &lt;&lt; endl; &#125; &#125;private: int vertexNum; int edgeNum; int KCluster; int* minimalSpanningTree; MergeQuery* mq; Edge* edges;&#125;;int main() &#123; int vertexNum, edgeNum, KCluster; cin &gt;&gt; vertexNum &gt;&gt; edgeNum &gt;&gt; KCluster; if (vertexNum &gt; MAX_VERTEX_NUM) &#123; cout &lt;&lt; \"结点数量过多\" &lt;&lt; endl; return -1; &#125; if (KCluster &gt; vertexNum) &#123; cout &lt;&lt; \"聚类数量过大，超过结点数量\" &lt;&lt; endl; return -1; &#125; Kruskal k(vertexNum, edgeNum, KCluster); k.getEdge(); // 输入边 k.minimalSpanning(); // kruskal最小生成树算法 k.getTree(); // 输出结果 return 0;&#125;","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hongchh.github.io/tags/数据结构与算法/"}]},{"title":"JavaScript-OOP常见模式总结（二）","slug":"JavaScript-OOP常见模式总结（二）","date":"2016-08-12T04:12:00.000Z","updated":"2017-11-10T12:11:48.182Z","comments":true,"path":"2016/JavaScript-OOP常见模式总结（二）/","link":"","permalink":"https://hongchh.github.io/2016/JavaScript-OOP常见模式总结（二）/","excerpt":"","text":"前言：之前我总结了JavaScript OOP常见的几种模式，今天继续把剩下的几种模式整理总结一遍。这几种模式相对于之前的工厂模式，构造函数模式等基础模式来说算是进阶版，有兴趣可以先看之前那篇博文熟悉一下几种基础的OOP模式，《JavaScript OOP常见模式总结》一、创建对象模式1. 动态原型模式该模式将所有信息都封装在构造函数中，可以在构造函数中初始化原型，并且保持了同时使用构造函数和原型的优点。在执行构造函数时，会通过检验某个应该存在的方法是否有效再决定是否需要初始化原型对象。以下面代码为例，所有信息都封装在了构造函数中，并且，为了避免多次初始化原型对象，使用了if条件语句来判断getProperty()方法是否存在。所以，仅在第一次调用构造函数时会初始化原型对象，创建obj1时初始化了原型对象，后面创建obj2对象时就仅执行添加属性部分的代码。这种模式的好处就是可以把属性和方法的定义都全部写到一起(都封装在构造函数中)，不用独立去写构造函数和原型。本质上和组合模式没有什么区别。123456789101112131415function MyObject(property) &#123; // 添加属性 this.property = property; // 添加方法 if (typeof this.getProperty != \"function\") &#123; MyObject.prototype.getProperty = function() &#123; return this.property; &#125;; &#125;&#125;var obj1 = new MyObject('xxxx');var obj2 = new MyObject('yyyy');console.log(obj1.getProperty()); // 输出\"xxxx\"console.log(obj2.getProperty()); // 输出\"yyyy\"2. 寄生构造函数模式这种模式的基本思想是创建一个函数用于封装创建对象的代码，然后返回新创建的对象。表面上看起来跟工厂模式没什么区别，就只是在创建对象时使用了new操作符。寄生模式返回得到对象跟构造函数或构造函数原型之间没有任何关系，工厂模式存在的弊病在这种模式下也存在。1234567891011function MyObject(property) &#123; var o = new Object(); o.property = property; o.getProperty = function() &#123; return this.property; &#125;; return o;&#125;var obj = new MyObject('xxxx'); // 使用new操作符创建对象，工厂模式则是直接调用工厂函数console.log(obj.getProperty()); // 输出\"xxxx\"3. 稳妥构造函数模式首先介绍一个概念，稳妥对象(durable object)，没有公共属性，其方法也不引用this对象，这种对象就称为稳妥对象。稳妥构造函数模式与寄生构造函数模式相似，不同的是，创建对象的实例方法不引用this，不适用new操作符调用构造函数。以下面代码为例，构造函数中的方法都没有引用this对象，变量obj中保存的是一个稳妥对象，除了通过getProperty()和getPrivate()方法访问对象的属性之外，没有其他办法能够访问到property和private属性，这两个属性就相当于C++中类的私有成员变量一样。这种模式本质上是构建了闭包，让私有变量存在于对象上某个函数的闭包中，只有通过调用对象上特定的函数才能访问到它闭包中的变量。这样做的好处就是防止数据被其他程序改动，保证安全性。此模式适合在一些安全性要求较高的执行环境中使用。123456789101112131415161718function MyObject(property) &#123; var o = new Object(); // 定义参数之外的其他私有变量或方法 var private= \"yyyy\"; o.getProperty = function() &#123; return property; &#125;; o.getPrivate = function() &#123; return private; &#125;; return o;&#125;var obj = MyObject('xxxx');console.log(obj.getProperty()); // 输出\"xxxx\"console.log(obj.getPrivate()); // 输出\"yyyy\"console.log(obj.property); // undefinedconsole.log(obj.private); // undefined二、继承模式1. 原型式继承这种模式的主要思想是借助原型来基于已有的对象创建新对象，同时不必因此创建自定义类型。以下面代码为例，inherit()函数内部创建了一个临时构造函数F，并且F的原型对象指向了传入inherit()的对象obj，表示F类型继承obj类型。这种模式本质上是做了一次浅复制，像下面代码一样，由于obj1被放置到obj2的原型对象的位置上，因此在修改obj2的property1属性时，obj1的属性也跟着变了。这种模式创建出来的新对象可以为其添加新的属性或方法，并且不影响原对象。所以，这种模式适合在构造相似对象，并且为新对象动态添加独有的属性方法时使用。ES5中，Object.create()方法就是实现了这种原型式继承。123456789101112131415161718function inherit(obj) &#123; function F() &#123;&#125; F.prototype = obj; return new F();&#125;var obj1 = &#123; property1 : 'xxxx', property2 : 'yyyy'&#125;;var obj2 = inherit(obj1);console.log(obj2.property1); // 输出\"xxxx\"console.log(obj2.property2); // 输出\"yyyy\"obj2.property1 = 'zzzz';console.log(obj1.property1); // 输出\"zzzz\"obj2.property3 = 'wwww';console.log(obj1.property3); // undefined2. 寄生式继承寄生式继承的思路和寄生构造函数或工厂模式相似，创建一个用于封装继承过程的函数，在该函数中通过某种方式来增强对象实现继承。这种模式与前面的原型式继承一样，适合在不需要自定义类型和构造函数的情况下使用。这种模式也有缺点，在为对象添加函数时，会由于不能做到函数复用而降低效率。以下面代码为例，这种模式下看起来跟前面的原型式继承好像也很类似，不过，这里创建的每个继承对象都会定义func()方法，前面的原型式继承则没有。也就是说，原型式仅仅是继承了父类的属性方法，然后子类对象自己可以随意添加自己特有的属性方法，而寄生式继承则是继承了父类的属性方法之后还有把子类对象共同的属性方法也加上。123456789101112131415function inherit(obj) &#123; function F() &#123;&#125; F.prototype = obj; var o = new F(); o.func = function() &#123; console.log('23333'); &#125;; return o;&#125;var obj1 = &#123; property : 'xxxx'&#125;;var obj2 = inherit(obj1);obj2.func(); // 输出\"23333\"3. 寄生组合式继承在介绍寄生组合式继承之前，我们先回顾一下组合继承。组合继承是JS中最常用的继承模式，但这种模式也存在着自己的问题，这个问题就是无论在什么情况下，都会调用两次父类的构造函数，一次是在创建子类型的时候，另一次是在子类型构造函数的内部。请看下面代码示例，两次调用父类的构造函数，显而易见的缺点就是损失效率，函数调用次数我们希望越少越好。再者，我们仔细观察可以发现，通过这两次调用，子类对象上继承了父类的属性superName，但，子类的原型对象上也存在父类的属性superName，这个属性也会被子类对象上的属性屏蔽，实际上我们希望原型对象只继承父类的函数方法，这就造成了定义多余的属性浪费资源。1234567891011121314151617181920function SuperType(superName) &#123; this.superName = superName;&#125;SuperType.prototype.saySuperName = function() &#123; console.log(this.superName);&#125;;function SubType(superName, subName) &#123; SuperType.call(this, superName); // 继承父类属性，调用SuperType() this.subName = subName;&#125;SubType.prototype = new SuperType(); // 继承父类方法，调用SuperType()SubType.prototype.constructor = SubType;SubType.prototype.saySubName = function() &#123; console.log(this.subName);&#125;;var obj = new SubType('heheheheh', '233333');obj.saySuperName(); // \"heheheheh\"obj.saySubName(); // \"233333\"我们希望仅调用一次父类的构造函数，并且在子类的原型对象上不要定义多余的属性。为了克服组合继承的不足，寄生组合式继承是最好的选择。寄生组合式继承通过借用构造函数来继承属性，通过原型链的混合形式来继承方法，其思路就是：不必为了指定子类型的原型而调用父类的构造函数，而是将父类的原型拷贝一个副本给子类。本质上，就是使用拷贝的方式来继承父类的原型，然后就把结果指定给子类的原型。代码示例如下，inherit()函数的作用是复制父类的原型并指定给子类。寄生组合式继承的高效率体现在它只调用了一次父类的构造函数，并且避免了在子类的原型对象上创建多余的属性，并且，原型链依然保持不变，可以通过instanceof或isPrototypeOf()来判断类型。123456789101112131415161718192021222324252627function inherit(Super, Sub) &#123; // 拷贝父类原型 var prototype = Object(Super.prototype); // 将父类原型副本指定给子类 prototype.constructor = Sub; Sub.prototype = prototype;&#125;function SuperType(superName) &#123; this.superName = superName;&#125;SuperType.prototype.saySuperName = function() &#123; console.log(this.superName);&#125;;function SubType(superName, subName) &#123; SuperType.call(this, superName); // 继承父类属性，调用SuperType() this.subName = subName;&#125;inherit(SuperType, SubType); // 继承父类的原型对象SubType.prototype.saySubName = function() &#123; console.log(this.subName);&#125;;var obj = new SubType('heheheheh', '233333');obj.saySuperName(); // \"heheheheh\"obj.saySubName(); // \"233333\"","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://hongchh.github.io/tags/JavaScript/"}]},{"title":"【贪心算法】区间调度问题总结","slug":"【贪心算法】区间调度问题总结","date":"2016-08-11T08:07:00.000Z","updated":"2017-11-10T12:04:13.456Z","comments":true,"path":"2016/【贪心算法】区间调度问题总结/","link":"","permalink":"https://hongchh.github.io/2016/【贪心算法】区间调度问题总结/","excerpt":"","text":"1. 单区间调度问题问题定义：存在单一资源，有一组以时间区间形式表示的资源请求reqs={req-1, req-2, ..., req-n}，第i个请求希望占用资源一段时间来完成某些任务，这段时间开始于begin(i)终止于end(i)。如果两个请求req-i和req-j在时间区间上没有重叠，则说这两个请求是相容的，求出这组请求的最大相容子集(最优子集)。举个例子：有一间多媒体课室，某一个周末有多个社团想要申请这间课室去举办社团活动，每个社团都有一个对应的申请时间段，比如周六上午8:00-10:00。求出这间课室在这个周末最多能满足几个社团的需求。解决方案：贪心算法，优先选择最早结束的需求，确保资源尽可能早地被释放，把留下来满足其他需求的时间最大化。具体伪代码如下所示，算法结束后集合A中会保留所有相容请求，A的大小即是最大相容数量。12345678初始化R是所有需求的集合，A为空集对R中的需求Ri，根据结束时间从早到晚排序for Ri in R, do if Ri与A中的请求相容 A = A并Ri endIfendForreturn A上述伪代码的C++实现如下，123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int MAX_SIZE = 100;struct Request &#123; int begin, end;&#125; req[MAX_SIZE];bool operator&lt;(const Request&amp; req1, const Request&amp; req2) &#123; return req1.end &lt; req2.end;&#125;int main() &#123; int requestNum; cin &gt;&gt; requestNum; if (requestNum &gt; MAX_SIZE) &#123; cout &lt;&lt; \"请求数量过多\" &lt;&lt; endl; return 0; &#125; for (int i = 0; i &lt; requestNum; ++i) &#123; cin &gt;&gt; req[i].begin &gt;&gt; req[i].end; &#125; sort(req, req + requestNum); vector&lt;Request&gt; rvec; rvec.push_back(req[0]); for (int i = 1; i &lt; requestNum; ++i) &#123; if (rvec[rvec.size() - 1].end &lt;= req[i].begin) &#123; rvec.push_back(req[i]); &#125; &#125; cout &lt;&lt; \"最大兼容量: \" &lt;&lt; rvec.size() &lt;&lt; endl; return 0;&#125;2. 多区间调度问题问题定义：存在多个(或者无限多个)相同的资源，有一组以时间区间形式表示的资源请求reqs={req-1, req-2, ..., req-n}，第i个请求希望占用资源一段时间来完成某些任务，这段时间开始于begin(i)终止于end(i)。如果两个请求req-i和req-j在时间区间上没有重叠，则说这两个请求是相容的，用尽可能少的资源满足所有请求(求最优资源数量)。举个例子：有很多间课室，某个周末有多个社团需要申请课室办活动，每个社团都有一个对应的申请时间，求最少需要多少间课室才能够满足所有社团的需求(在这个问题之中时间重叠的社团需要安排在其他课室，即会使用到多个资源，需要考虑多个资源上的调度安排，故称为多区间调度)。解决方案：贪心算法，将需求按照开始时间的早晚进行排序，然后开始为这些资源打标签，每个标签代表都一个资源，需求req-i被打上标签k表示该请求分配到的资源是k。遍历排序后的需求，如果一个需求与某个已分配资源上的其他安排不冲突，则把该需求也放进该资源的安排考虑中；如果冲突，那么应该要给此需求分配新的资源，已用资源数量加一。具体操作的伪代码如下所示。1234567891011121314151617181920对n个需求按照开始时间从早到晚进行排序假设排序后的需求记为&#123;R1, R2, ..., Rn&#125;初始化tagSize = 1;for i=1 to n, do: tags = &#123;1,2,...,tagSize&#125;; for j = 1 to i-1, do: if Rj与Ri时间区间重叠产生冲突: tags = tags - &#123;Rj的标签&#125;; endIf endFor if tags为空集: tagSize += 1; 将标签tagSize贴在Ri上 EndIf else: 在tags剩下的标签中随便挑一个贴给Ri endElseendFor此时每个请求上都贴有标签，每个标签对应其申请的资源编号，此时的tagSize就是至少需要的资源数量return tagSize;上述伪代码的C++实现如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int MAX_SIZE = 100;struct Request &#123; int begin, end, tag;&#125; req[MAX_SIZE];bool operator&lt;(const Request&amp; req1, const Request&amp; req2) &#123; return req1.begin &lt; req2.begin;&#125;int main() &#123; int requestNum; cin &gt;&gt; requestNum; if (requestNum &gt; MAX_SIZE) &#123; cout &lt;&lt; \"请求数量过多\" &lt;&lt; endl; return 0; &#125; for (int i = 0; i &lt; requestNum; ++i) &#123; cin &gt;&gt; req[i].begin &gt;&gt; req[i].end; &#125; sort(req, req + requestNum); int tagSize = 1; req[0].tag = 0; bool tags[MAX_SIZE]; for (int i = 1; i &lt; requestNum; ++i) &#123; memset(tags, 1, sizeof(tags)); for (int j = 0; j &lt; i; ++j) &#123; if (req[j].end &gt; req[i].begin) &#123; tags[req[j].tag] = false; &#125; &#125; bool isTagsEmpty = true; int tag; for (int j = 0; j &lt; tagSize; ++j) &#123; if (tags[j]) &#123; isTagsEmpty = false; tag = j; break; &#125; &#125; if (isTagsEmpty) &#123; req[i].tag = tagSize; ++tagSize; &#125; else &#123; req[i].tag = tag; &#125; &#125; cout &lt;&lt; \"最小资源使用量: \" &lt;&lt; tagSize &lt;&lt; endl; return 0;&#125;3. 最小延迟调度问题问题定义：存在单一资源和一组资源请求reqs={req-1, req-2, ..., req-n}，与前面两个问题不同，这里的资源从时刻0开始有效(开始接受申请，开始可以被使用)，每个请求req-i都有一个截止时间ddl(i)，每个请求都要占用资源一段连续的时间来完成任务，占用时间为time(i)。每个请求都希望自己能在ddl之前完成任务，不同需求必须被分在不重叠的时间区间(单一资源，同一时刻只能满足一个请求)。假设我们计划满足每个请求，但是允许某些请求延迟(即某个请求在ddl之后完成，延误工期)，确定一种合理的安排，使得所有请求的延期时间中的最大值，是所有可能的时间安排情况中最小的。从时刻0开始，为每个请求req-i分配一个长度time(i)的时间区间，把区间标记为[begin(i), end(i)]，其中end(i) = begin(i) + time(i)。如果end(i) &gt; ddl(i)，则请求req-i被延迟，延迟时间为delay(i) = end(i) - ddl(i)；否则delay(i) = 0。合理安排需求，使得maxDelay = max{delay(1), delay(2), ..., delay(n)}是所有可能的安排中最小的。解决方案：贪心算法，按照截止时间ddl排序，越早截止的任务越早完成。该算法是一个没有空闲的最优调度，即从时刻0开始都有在处理请求，直到最后一个请求执行完释放资源之后才空闲。伪代码如下所示。1234567891011121314将需求按照截止时间进行排序假设排序后的截止时间为ddl[1]&lt;=...&lt;=ddl[n]start = 0;maxDelay = 0;for i = 1 to n, do: begin[i] = start; end[i] = start + time[i]; start = end[i] + time[i]; if maxDelay &lt; end[i] - ddl[i]: L = end[i] - ddl[i]; endIfendFor则每个任务安排的时间区间为[begin[i], end[i]]，所有任务中最大的延迟为maxDelay，maxDelay为所有可能的任务安排中最小的延迟return maxDelay;上述代码的C++实现如下：1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAX_SIZE = 100;struct Request &#123; int time, ddl; int begin, end;&#125; req[MAX_SIZE];bool operator&lt;(const Request&amp; req1, const Request&amp; req2) &#123; return req1.ddl &lt; req2.ddl;&#125;int main() &#123; int requestNum; cin &gt;&gt; requestNum; if (requestNum &gt; MAX_SIZE) &#123; cout &lt;&lt; \"请求数量过多\" &lt;&lt; endl; return 0; &#125; for (int i = 0; i &lt; requestNum; ++i) &#123; cin &gt;&gt; req[i].time &gt;&gt; req[i].ddl; &#125; sort(req, req + requestNum); int start = 0, maxDelay = 0; for (int i = 0; i &lt; requestNum; ++i) &#123; req[i].begin = start; req[i].end = start + req[i].time; start += req[i].time; if (maxDelay &lt; req[i].end - req[i].ddl) &#123; maxDelay = req[i].end - req[i].ddl; &#125; &#125; cout &lt;&lt; \"最小的最大延迟: \" &lt;&lt; maxDelay &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hongchh.github.io/tags/数据结构与算法/"}]},{"title":"JavaScript-OOP常见模式总结","slug":"JavaScript-OOP常见模式总结","date":"2016-08-11T04:00:00.000Z","updated":"2017-11-10T11:58:01.194Z","comments":true,"path":"2016/JavaScript-OOP常见模式总结/","link":"","permalink":"https://hongchh.github.io/2016/JavaScript-OOP常见模式总结/","excerpt":"","text":"一、创建对象模式1. 工厂模式使用一个函数作为工场函数，封装以特定接口创建对象的细节，每次调用工场函数都能生产一个对象。工厂模式的缺点是无法解决对象识别问题(即知道一个对象的类型)，而且每次调用函数，都会创建一个带有属性和方法的对象，也就是说，一些共同的方法会被多次创建，即每个方法都会在每个对象上重新创建一遍。以下面的代码为例，obj1和obj2都分别有各自的setProperty方法，也就是说setProperty方法创建了两次，浪费资源空间。12345678910111213function createObj(property1, property2) &#123; var o = new Object(); o.property1 = property1; o.property2 = property2; o.setProperty = function(val1, vla2) &#123; this.property1 = val1; this.property2 = val2; &#125;; return o;&#125;var obj1 = createObj('xxxx', 'xxxx');var obj2 = createObj('yyyy', 'yyyy');2. 构造函数模式通过创建自定义的构造函数从而定义自定义对象类型的属性和方法。构造函数内没有显式地创建对象，直接将属性和方法赋值给this对象，也没有return语句。在使用new操作符创建对象的时候，会经历以下过程：创建一个新对象，把构造函数的作用域赋值给新对象(即this指向新对象)，执行构造函数中的代码给对象添加属性方法，最后返回新对象的引用，可以结合下面代码中obj3的创建过程理解整个过程。使用这种模式创建的对象，可以用instanceof操作符来判定对象类型，这是相对于工厂模式的优势。但是，这种模式也会出现相同的方法多次创建的情况，像下面的代码一样，setProperty方法被创建了3次，obj1、obj2和obj3都有各自的一个setProperty方法。12345678910111213function MyObject(property1, property2) &#123; this.property1 = property1; this.property2 = property2; this.setProperty = function(val1, val2) &#123; this.property1 = val1; this.property2 = val2; &#125;;&#125;var obj1 = new MyObject('xxxx', 'xxxx');var obj2 = new MyObject('yyyy', 'yyyy');var obj3 = new Object();MyObject.call(obj3, 'zzzz', 'zzzz');3. 原型模式我们创建的每个函数都有一个prototype(原型)属性，该属性是一个指针，指向一个对象。创建自定义一个新函数之后，JavaScript会根据一组特定规则为该函数创建一个prototype属性，指向函数的原型对象。原型对象有一个constructor属性，指向prototype属性所属的函数指针。例如：MyObject.prototype指向MyObject的原型对象，MyObject.prototype.constructor指回MyObject。原型模式的代码示例如下所示。通过原型模式定义的属性和方法将被所有对象实例共享，以下面代码为例，obj1和obj2的property属性是共享的，没有各自创建自己的property，当原型对象上property属性值修改之后obj1和obj2访问到的值也跟着变了。代码执行读取某个对象的属性时，会执行一次搜索，首先从对象实例本身开始，如果找到该属性则返回该属性的值，如果找不到，则通过prototype指针继续在原型对象上进行搜索。基于这种搜索机制，所有创建在原型对象上的属性都是被共享的，因为只要在对象实例上找不到就会到原型对象上找，而对象实例有多个，它们的prototype指针指向的原型对象却都是同一个。当然，只要在对象实例上继续创建属性，该属性与原型对象的属性同名，则可以屏蔽原型对象上的属性。原型模式的缺点是所有属性和方法都共享，这点对于函数非常合适(类似于c++中类的成员函数)，当对于某些属性来说很不合适(类似于c++中类的非静态成员变量)。12345678910111213141516function MyObject() &#123;&#125;MyObject.prototype.property = 'xxxx';MyObject.prototype.getProperty = function () &#123; return this.property;&#125;;MyObject.prototype.setProperty = function(val) &#123; this.property = val&#125;;var obj1 = new MyObject();var obj2 = new MyObject();console.log(obj1.getProperty()); // 输出\"xxxx\"console.log(obj2.getProperty()); // 输出\"xxxx\"MyObject.prototype.property = 'yyyy';console.log(obj1.getProperty()); // 输出\"yyyy\"console.log(obj2.getProperty()); // 输出\"yyyy\"4. 组合模式（构造函数模式+原型模式）结合构造函数模式和原型模式的优点，克服它们的缺点。这种模式下，在构造函数中定义对象各自的私有属性，而共享方法则在原型对象上定义。这样，每个对象实例都有各自的属性变量，而共享原型对象上的函数方法，很好地模拟了类的公有函数和私有变量。这种模式是JavaScript中使用最广泛的一种创建自定义类型的模式。以下面代码为例，obj1和obj2有各自的property属性变量，当修改原型对象上的property属性值时对obj1和obj2没有影响，当obj1的property属性值改变时对obj2也没有影响。123456789101112131415161718function MyObject(property) &#123; this.property = property;&#125;MyObject.prototype.getProperty = function() &#123; return this.property;&#125;;var obj1 = new MyObject('xxxx');var obj2 = new MyObject('yyyy');console.log(obj1.getProperty()); // 输出\"xxxx\"console.log(obj2.getProperty()); // 输出\"yyyy\"MyObject.prototype.property = 'zzzz';console.log(obj1.getProperty()); // 输出\"xxxx\"console.log(obj2.getProperty()); // 输出\"yyyy\"obj1.property = 'zzzz';console.log(obj1.getProperty()); // 输出\"zzzz\"console.log(obj2.getProperty()); // 输出\"yyyy\"二、继承模式1. 原型链模式原型链是实现继承的主要方法，利用原型链让一个引用类型继承另一个引用类型的属性和方法。每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。当我们让原型对象等于另一个类型的实例，此时原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型有事另一个类型的实例，那么上述关系依然成立，如此层层递进就构成了实例与原型的链条，这就是原型链的基本概念。实现的本质是重写原型对象，替换为一个新类型的实例。以下面代码为例，SubType的原型对象变成SuperType的一个实例对象之后，为了叙述方便，我们将此对象称为sobj，也就是说现在SubType的原型对象是sobj，sobj是SuperType的一个实例对象。当我调用getSuperName()方法时候，首先在obj对象上进行搜索，找不到getSuperName方法，接着在obj的原型对象sobj上寻找，也是没找到，而sobj本身也有prototype指针指向SuperType的原型对象，所以会继续在这个原型对象上找，找到了getSuperName方法，搜索停止，执行getSuperName方法。通过实现原型链，本质上扩展了原型搜索机制。原型链实现继承也会存在不少缺点，首先，父类型作为子类型的原型对象，我们前面说过，原型对象上的属性和方法会被所有对象共享，于是子类型会共享所有父类型的属性和方法，这就导致了父类型的属性无法当做私有属性来使用。其次，在创建子类型的实例时，无法向父类型的构造函数传参。基于这两点，在实际应用中很少单独使用原型链。123456789101112131415161718function SuperType() &#123; this.superName = 'SuperType';&#125;SuperType.prototype.getSuperName = function() &#123; return this.superName;&#125;;function SubType() &#123; this.subName = 'SubType';&#125;SubType.prototype = new SuperType(); // 改变子类的prototype指针指向，实现继承SubType.prototype.getSubName = function() &#123; return this.subName;&#125;;var obj = new SubType();console.log(obj.getSuperName()); // 输出\"SuperType\"console.log(obj.getSubName()); // 输出\"SubType\"2. 借用构造函数模式借用构造函数模式的基本思想相当简单，即在子类型构造函数的内部调用超类型的构造函数。通过使用apply()和call()方法在新创建的对象上执行构造函数，从而将父类构造函数执行作用域切换到子类，为子类定义一系列父类的属性方法，如下所示，在创建SubType的实例对象时，在该对象上调用了父类的构造函数，因此会执行父类构造函数中的this.superName = &#39;SuperType&#39;这句代码，此时的this指向的时子类的实例对象obj，所以obj上就有了superName属性。123456789101112function SuperType() &#123; this.superName = 'SuperType';&#125;function SubType() &#123; SuperType.call(this); // 在子类对象上调用父类构造函数 this.subName = 'SubType';&#125;var obj = new SubType();console.log(obj.superName); // 输出\"SuperType\"console.log(obj.subName); // 输出\"SubType\"借用构造函数有一个很大的优势，可以在子类型中向超类型构造函数传参。但此技术也存在缺点，即所有超类型的函数方法必须在构造函数中定义才能被子类继承，而在构造函数中定义函数方法，就会出现前面说的构造函数模式所遇到的问题，这些方法会被多次创建，即在每一个实例对象上都会被创建一遍。因此，借用构造函数模式也很少单独使用。3. 组合继承模式组合继承也叫作伪经典继承，它将原型链和借用构造函数的技术组合起来，发挥二者的优势。使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例属性的继承，这样，既通过在原型上定义的方法实现了函数复用，又能保证每个实例都有自己的属性。组合继承模式避免了原型链和借用构造函数的缺陷，融合了他们的优点，是JavaScript中最常用的继承模式，而且，instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。1234567891011121314151617181920function SuperType(superName) &#123; this.superName = superName;&#125;SuperType.prototype.saySuperName = function() &#123; console.log(this.superName);&#125;;function SubType(superName, subName) &#123; SuperType.call(this, superName); // 使用借用构造函数模式继承父类属性 this.subName = subName;&#125;SubType.prototype = new SuperType(); // 使用原型链模式继承父类方法SubType.prototype.constructor = SubType; // 重置构造子SubType.prototype.saySubName = function() &#123; console.log(this.subName);&#125;;var obj = new SubType('heheheheh', '233333');obj.saySuperName(); // 输出\"heheheheh\"obj.saySubName(); // 输出\"233333\"","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://hongchh.github.io/tags/JavaScript/"}]},{"title":"medrank算法配合B+树实现一个简单预测模型","slug":"medrank算法配合B-树实现一个简单预测模型","date":"2016-07-27T03:04:00.000Z","updated":"2017-11-10T11:44:42.963Z","comments":true,"path":"2016/medrank算法配合B-树实现一个简单预测模型/","link":"","permalink":"https://hongchh.github.io/2016/medrank算法配合B-树实现一个简单预测模型/","excerpt":"","text":"A model for entity predictingdemo的github地址https://github.com/hongchh/predict-entity，欢迎点赞或指正不足之处注1: 如有问题请联系hongchh_sysu@qq.com注2: 本文仅供参考交流，请勿抄袭一、前言实体(entity)是描述一些数据对象区别于其他数据对象的内容，可以理解为一种类型、标签。在实际应用场景中，实体可以是商标、品牌、公司名称等等，类似于搜索引擎中的关键字，但也有所区别。实体过滤(entity filtering)指的是，在某些带有实体标记的数据中，过滤出与查询实体相关的数据。比如：有大量的微博博文数据，将博文内容按照“BMW”、“KFC”、“剑桥大学”、“哈佛大学”等不同实体进行了分类，接着给定一个查询实体“BMW”，则从数据中过滤出与BMW相关的数据出来。实体过滤可以用于调查监控某些品牌或者机构的网络知名度和影响力，为企业战略调整提供参考，及时调整发展方向等等。以上便是我们小组所选择的论文【1】中所做的事情，作者提出一种机器学习的算法，该算法可应用于实体过滤，数据输入之后通过该算法的特殊筛选方式再配合人工打上实体标签，可以快速得到一个带有不同实体标签的数据集。从本质上来看，实体过滤是一个实体到数据的过程，通俗一点讲就是你给我一个实体，我给你一堆跟实体相关的数据供你去做其他分析。论文【1】提出的模型会产生一个带有不同实体标签的数据集，将此数据集仅用于作实体过滤未免有点浪费资源。于是我们小组提出的改进方案是对此模型做一个功能上的改进，增加一个数据到实体的过程，即你给我数据，我来预测该数据可能与哪些实体相关。我们把这个过程称为实体推断，或者实体预测。我们也考虑了增加这个从数据到实体的过程是否有现实意义，最终我们一致认为，增加从数据到实体这个过程是有现实意义的。从小的方面讲，我们可以通过监测社交网络上的某个用户的数据，再将此数据经过我们的模型计算得到其相关的实体，我们统计这些实体之后便可知晓这个用户关注的事物，从而可用于为兴趣分析、爱好推荐等系统提供参考。从大的方面讲，我们可以检测名人机构的社交网络数据来监测他们的关注动向。最后，从实体到数据和从数据到实体这两个过程可能比较难理解清楚，我们打算再给出一个例子用于简要说明实体过滤和实体推断的区别，便于您更进一步了解我们论文所做的事情，该例子也会在后面的实验中被用于检验模型的正确性。例子如下：有红色、黄色、绿色、蓝色、紫色5种颜色大类。拿红色来说，红色下面可以包含品红、朱红、粉红、浅红、猩红等等很多种红，这些颜色的差别就是红的深浅程度不一样，更具体一点说就是RGB颜色值不一样，但他们给人的直观视觉感受就是红色。因此，我们把这种广泛意义上的颜色分类(红色、黄色、绿色等)称为颜色实体，具体的RGB颜色值称为颜色数据，例如“红色”称为颜色实体，“粉红-rgb(255,192,203)”称为颜色数据。实体过滤做的事情就是当查询实体为“红色”时，返回rgb(255,192,203)、rgb(220,20,60)等直观上看起来是红色的具体的颜色数据。而实体推断做的事情就是给定具体的颜色数据，例如rgb(255,192,203)，返回该数据所属的颜色实体“红色”。二、问题定义我们要解决的是实体推断的问题，该问题可以描述为：给定一个已知实体标签的大的数据集和一个未知实体标签的数据集，将前者称为训练集，后者称为查询集。将训练集作为输入经过特定算法处理之后得到一个模型，该模型可以接受来自查询集的输入，并对查询集中的每个数据对象都预测其所属的实体标签。算法的输入为一个训练集(ds)和一个查询集(qs)，训练集的大小为n，查询集合的大小为qn。训练集是一个带有实体标签的数据集，包含多个(大量)数据对象，每个数据对象都用特征向量的形式表示，向量的维度为d，每一个数据对象的格式如下:type dimVal-1 dimVal-2 … dimVal-d其中，type为该数据对象所属的实体类型(实体取值范围有多个，{e1, e2, e3, e4, e5, …, ek})，dimVal为数据对象的特征向量每个维度上的值。查询集是一个普通的数据集，该数据集包含多个数据对象，每一个数据对象都用特征向量的形式表示，向量的维度也是d，并且这些数据对象是未知实体的，即他们所属的实体未知。每一个数据对象格式与训练集一样。由于数据量较大，算法的两个输入均采用文件输入，在使用算法的过程中需要提供训练集的大小n、训练集的数据文件路径ds、查询集的大小qn、查询集的数据文件路径qs、特征向量的维度大小d这5个参数。算法的输出为预测的结果。对于查询集中的每一个数据对象q[i]，预测其可能属于的实体e，将e输出到文件保存。三、算法描述前置知识：空间中向量之间的距离可以使用欧氏距离来衡量，向量v1=(x1, x2, …, xn)和向量v2=(y1, y2, …, yn)之间的欧氏距离为dist=|v1-v2|=sqrt(sum((xi-yi)^2))(i=1, 2, …, n)。本算法默认数据对象都采用特征向量的形式描述，对象之间的距离采用欧氏距离描述。算法的总体思路是从训练集中选出跟查询的数据对象距离最近的N个点，通过计算这N个点所属实体出现的次数，将出现次数最多的实体作为查询的数据对象的预测实体。最简单的办法就是暴力查找，对每一个查询对象，遍历训练集的对象并计算与查询对象的距离，排序之后再取出距离最短的前N个点即可。基于数据量庞大，暴力算法会十分耗费时间和计算性能，是下下之策。我们采取的算法是medrank算法。medrank算法是一种高效的查询大致最近邻点(ANN)的算法，通过选取合理的参数配置能够让其找到真正最近邻点。论文【2】中提出的medrank算法是一种查询一个邻近点的算法，我们对算法进行了改造，使得它能够找到N个邻近点。改造后的算法大致步骤如下(medrank算法的流程在论文【2】中已有详细介绍，篇幅较长，这里不再重复描述，如想要深入理解medrank算法请参考论文【2】，下面只展示我们改进后的medrank算法):在一个d维的向量空间，按照正态分布的规律随机取出m条直线[L1, L1, …, Lm]，每条直线的单位向量为[a1, a2, …, am]。预处理的时候将训练集的向量投影到这m条直线上面去，即每条直线上会有n个投影值。用下面这种形式描述第i条直线上训练集的投影值[vi-1, vi-2, …, vi-j, …, vi-n]，i=1, 2, 3, …, m，j=1, 2, 3, …, n，i表示第几根直线，vi-j表示训练集中第j个对象在第i条直线上的投影。接下来，m条直线将扮演m个投票者的角色。给定一个查询向量，我们将查询向量也投影到m条直线上去得到投影值[q1, q2, …, qm]。对于每一根直线Li，根据训练集在这条直线上的投影值vi-j与查询点在这条直线上的投影值qi的距离大小来进行投票。投票的规则如下，假设第i条直线上训练集的投影值为[vi-1, vi-2, …, vi-n]，查询点的投影值为qi，从第i条直线上训练集的投影值中找出与qi的距离最近的两个投影值vi-hi和vi-li使得vi-hi &lt;= qi &lt;= vi-li，从这两个值开始，每次迭代都投给距离qi最近的点一票，不断向两边展开。以此类推，每根直线都是如此不断循环迭代下去，直到有N个点的票数超过投票者数量的一半，即m/2，则结束算法。这些票数超过一半的点就是我们想要的N个最近邻点。算法的伪代码如下所示，其中MINFREQ是论文【2】里为medrank算法设定的一个参数用于限定算法的结束条件，我们设置它为0.5，代表有N个点票数超过投票者的一半(0.5)就停止算法。向量的投影可以简单由需要投影的向量v跟投影直线的单位向量a作一个向量内积来完成，即投影值p = v * a。12345678910111213141516171819202122232425&lt;medrank&gt;Input: 查询对象qOutput: 训练集中与q最近的N个邻近点for i = 1 to m do qi = ai * q 初始化两个指针hi和li使得vi-hi &lt;= qi &lt;= vi-li且hi和li指向的点离qi最近endS = 空集, f = [0, 0, ..., 0]while S中满足(f &gt; MINFREQ*m)的点的数量小于N do for i = 1 to m do if |vi-hi - qi| &lt; |vi-li - qi| then c = ci-hi; hi = hi - 1; else c = ci-li; li = li + 1; end if S不包含c then 把c加入S并初始化f[c] = 1; else f[c] = f[c] + 1; end endendreturn S中满足(f &gt; MINFREQ*m)的点;我们知道，在信息检索和数据库领域中，处理的数据量都是非常庞大的，经常需要对数据建立索引。B+树索引的查询速度很快，访问的数据量很小，一般只需3-4次IO就能查询出所需的数据。为了更进一步提高程序的性能，我们使用B+树这种数据结构来优化查询效率。在medrank算法中，我们需要找出每条直线上投影值跟qi最近的两个点的指针li和hi，之后才是借由这两个指针向两侧扩展来进行投票。由于训练集数据量庞大，普通的线性查找或者二分查找比较耗时，而且当数据较大无法全部放进内存时，查找效率更是低下。因此，我们在这里可以利用B+树对每一条线上的投影值建立索引，在查找时利用索引进行查找，既能提高查找速度，又能降低数据访问量，一举两得。关于使用B+树索引的伪代码如下所示。1234567891011121314&lt;indexing&gt;Input: m条直线，每条直线上都有n个投影值Output: Nonefor i = 1 to m do 将第i条直线上的n个投影值排序; 使用B+树的bulk-loading方法对排序后的投影值建立索引; 将索引存储至磁盘文件;end&lt;finding&gt;Input: 查询点在第i根直线上的投影值qiOutput: 两个指针hi和li利用B+树的范围查找功能找出两个指针hi和li使得*hi &lt;= qi &lt;= *lireturn hi, li;最后，我们将B+树和medrank算法结合起来之后得到的最终模型的伪代码如下所示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;preprocess&gt;Input: 训练集D的n个数据对象&#123;o1, o2, ..., on&#125;, 投影直线数量mOutput: None利用正态分布生成m个随机单位向量&#123;a1, a2, ..., am&#125;;for j = 1 to m do Lj = 空集endfor i = 1 to n do for j = 1 to m do ci-j = i; vi-j = aj * oi; Lj = Lj 并 (ci-j, vi-j); endendfor j = 1 to m do 将第j条直线上的n个投影值根据vi-j的大小从小到大进行排序; 使用B+树的bulk-loading方法对排序后的投影值建立索引; 将索引存储至磁盘文件;end&lt;medrank&gt;Input: 查询对象qOutput: 训练集中与q最近的N个邻近点for i = 1 to m do qi = ai * q 利用B+树的范围查找初始化两个指针hi和li使得vi-hi &lt;= qi &lt;= vi-li且hi和li指向的点离qi最近endS = 空集, f = [0, 0, ..., 0]while S中满足(f &gt; MINFREQ*m)的点的数量小于N do for i = 1 to m do if |vi-hi - qi| &lt; |vi-li - qi| then c = ci-hi; hi = hi - 1; else c = ci-li; li = li + 1; end if S不包含c then 把c加入S并初始化f[c] = 1; else f[c] = f[c] + 1; end endendreturn S中满足(f &gt; MINFREQ*m)的点;&lt;predict&gt;Input: 查询集Q的n个数据对象&#123;q1, q2, ..., qn&#125;Output: 每个查询对应的实体标签&#123;e1, e2, ..., en&#125;E = 空集for i = 1 to n do 调用medrank算法查找得到N个点points; mark = 空集 for p in points do if mark中包含p.entity then mark[p.entity] = mark[p.entity] + 1; else 将p.entity加入到mark并初始化mark[p.entity] = 1; end end 将mark中值最大的实体标签取出加入到集合E中;endreturn E;算法的主要步骤如上面所示，下面我们将逐个步骤进行描述。预处理部分，预处理主要是将训练集的n个数据对象投影到m条直线上，记录投影值和投影点，即第几个点在第几条直线上的投影值。m条直线的产生，并不需要去确定直线方程，由于在算法中只需要对向量进行投影，因此，我们只需要生成m条直线对应的m个单位向量供投影使用即可。m个单位向量的生成需要满足正太分布，这样做的原因是为了让medrank算法的查询效果更好，具体细节在论文【2】中也有进行解释我们就不在重复赘述。投影完成后我们会得到m条直线，每一条直线上都有n个投影值。对每一条直线上的投影值都建立B+树索引，一共会产生m个索引。将这些索引存入文件，用于为medrank算法提供范围查询。medrank算法部分，这部分基本步骤都跟前面介绍medrank算法时候所说的一致，便不重复赘述。相比之前的改动就只是在初始化指针hi和li的地方采用B+索引进行查询。训练集的数据量很大，这一步改进将显著提高查询速度，为整个算法的时间效率带来极大收益。预测部分，这部分完成的工作是对输入的数据进行实体推断，也是体现我们解决实体推断问题的主要思想的地方。前面我们说到，进行预测需要先找到N个邻近点，再统计这些点所对应的实体标签。具体做法就是，对于输入的数据对象，首先通过调用medrank算法得到N个最邻近点，接着做一个O(N)的循环去统计这些邻近点的实体标签出现的次数，选取出现次数最多的实体标签作为预测结果。四、实验结果我们做了两个实验，第一个实验使用的训练集是从下面5张图中提取出来的每个像素点的RGB颜色值。每一张图片都是一个颜色大类，包含多种RGB颜色。查询集则是随机提取的1000个RGB颜色值。训练集和查询集的每一个颜色值都将使用一个3维的特征向量来描述，代表其RGB颜色值。在demo的/check/img文件夹下可以找到这5张图片。第二个实验使用的数据集为Mnist的数据集，详情可参考数据集的介绍和下载网站http://yann.lecun.com/exdb/mnist/ 。包括一个训练集和一个测试集，其中，训练集有60000个数据对象，测试集有10000个数据对象，每个数据对象都是一个784维的特征向量，每个特征向量都带有一个label。由于数据量庞大，测试时间会比较长，我们只提取了测试集中前300个数据对象作为我们实验的查询集。在demo中我们给出了一个get_mnist_data.cpp文件，有兴趣者请自行去修改里面相关参数来提取Mnist的全部测试数据来进行10000个数据的检验(需要比较暴力算法，暴力算法做10000个查询的时间会很长请耐心等候)。实验的评价标准是检查输出的结果是否正确，是否能够返回正确的实体标签。因此，我们需要一个已知实体标签的查询集作为检验，为了达到这个目的，我们在实验一中采取的做法是在训练集中随机抽取适量的数据出来充当查询集，由于训练集的每个数据对象都是已知实体标签的，我们可以得到一个已知实体标签的查询集。将查询集的实体标签保存起来，再跟实验的输出结果进行比较，计算正确率。实验二中的查询集中每个数据对象都已经带有Mnist官方打上的label，将此标签作为区分对象的实体标签即可。实验过程中，我们还将对比使用b+树配合medrank算法和使用暴力查找算法的查询结果和查询开销，进而探究我们论文所使用的模型的正确性和优越性。我们先来看第一个实验。第一个实验，我们要做的就是对于查询集中的每一个像素点，预测其所属的颜色大类。我们把上面5张图片代表的5种颜色大类分别打上实体标签“1”，“2”，“3”，“4”，“5”。每一个从对应图片中提取出来的像素点都带有其对应的实体标签。例如从红色图片中提取出来的像素点都将带有实体标签“1”。查询集中的每一个点输入之后，输出结果为该点所属的实体标签。比如rgb(255,192,203)为粉红色，输入之后得到的输出应该为“1”。我们收集100个查询点对应的输出，并制作了一个HTML页面用于显示对应的实验结果。实验结果展示请看下面的展示图，从实验结果来看，100个查询点的查询结果都是正确的，每一个点都能得到正确的实体标签来标记其所属的颜色大类。通过HTML页面从肉眼上也可以直观地看到实验结果的正确性。我们进行了查询集大小分别为100、500、1000的实验，最后得到的实验结果如下表所示。item\\size1005001000preprocess1.1783661.2052431.144519medrank(total)0.2195901.2127212.284969medrank(avg)0.0021960.0024250.002285bf(total)0.9182244.5213408.779360bf(avg)0.0091820.0090430.008779medrank prob2.6446002.7375802.847660hit ratio(m)1.0000001.0000001.000000hit ratio(b)1.0000001.0000001.000000统计项:prepreocess: 预处理时间，包括读取训练集数据，向量投影，建立b+树索引的时间(单位: 秒)medrank(total): medrank算法完成n个查询的总时间(单位: 秒)medrank(avg): medrank算法完成1个查询的平均时间(单位: 秒)bf(total): 暴力算法完成n个查询的总时间(单位: 秒)bf(avg): 暴力算法完成1个查询的平均时间(单位: 秒)hit ratio(m): 使用medrank算法查询之后预测实体的正确率hit ratio(b): 使用暴力算法查询之后预测实体的正确率medrank prob: medrank算法平均每棵B+树索引的数据访问量(单位: 页; 页大小: 1KB)从实验结果来看，使用medrank算法或者简单的暴力查找算法都能达到预期的正确率，这说明所使用的算法是合理的可行的，能够正确预测出查询对象所属的实体。并且，两种算法的命中率都是一样的，也就是说，正确性不相上下。我们再来看其他指标。medrank算法的查询时间很少，不管是数据量多大，平均每一个查询的时间都维持在0.0022秒左右，而暴力查找算法的时间则是维持在0.009秒左右。由此可见，medrank平均每个查询的查询速度要比普通的暴力查找算法快4倍左右。可能平均到一个查询的时间差距不大，我们来看总的查询时间，数据量为100的时候，medrank算法的总的查询时间为0.219秒，暴力查找的时间为0.918秒。随着数据量上升，差距逐渐增大，数据量上升到1000的时候，medrank算法的总查询时间为2.285秒，而暴力算法却需要8.779秒。显然，medrank算法具备强大的时间高效性，随着查询量的增加，时间差距累积扩大十分明显。最后一个指标是medrank算法的探测页面数量，我们计算了medrank算法在查找时访问的数据页面数量，发现平均每棵B+树只需访问2.74页，而本实验中一棵B+树索引的总大小为448页，计算一下便可知道，medrank算法在查找时需要访问的数据量仅为0.61%。而暴力算法需要遍历训练集所有数据，数据访问量为100%，使用建立B+树索引的方法显著降低了数据访问量，这也是medrank算法能够快速完成查询的重要原因之一。接下来，我们来看第二个实验。第一个实验很明显是一个面向低维度数据的实验，在实际应用中，像社交网络数据之类的特征向量维度通常都是很高的。因此，我们来进一步检验我们的模型在高维度向量空间中的适用性。实验步骤与实验一类似，不过查询集的数据量变为100、200、300。实验的结果如下面表所示item\\size100200300preprocess20.94363620.97562820.987209medrank(total)5.96490012.66269918.986900medrank(avg)0.0596490.0633130.063290bf(total)21.65046944.14801866.126366bf(avg)0.2165050.2207400.220421medrank prob105.908401104.598846105.550667hit ratio(m)0.9500000.9550000.926667hit ratio(b)0.9600000.9700000.973333实验二的数据维度为784，可以看到，随着数据的维度增大，处理的时间跟随之变长，不过跟实验一有相同的规律。我们可以看到，medrank算法平均处理一个查询的时间为0.06秒左右，而暴力算法则是0.21秒左右，medrank算法比暴力算法快3.5倍(实验一是4，相差不大)。从总的查询时间来看，medrank算法在查询数据量为100时比暴力算法节省时间15.68秒左右，数据量上升到300时节省时间47.14秒左右。随着查询数据量增加，medrank算法带来的时间收益更加显著。medrank算法的平均每一棵B+树索引的页面访问量为105左右，实验二中B+树索引的大小为486页，数据访问量大概为21.6%。虽然相比实验一增加了不少，但还是明显少于暴力算法。最后我们来看一看命中率，medrank算法和暴力算法的命中率都挺高，在这个实验中虽然暴力算法的命中率更高一点点，但也差不了多少，而且预测存在误差也是合理的，用一点点误差换来性能上的大幅度提升，显然是收益远大于损失，而且能够达到92%~95%左右的命中率也是十分理想的。最后，我们对比一下实验一跟实验二的数据访问量，仔细研究过论文【2】便可发现，medrank算法用来投影的m条直线，m的数值是自己合理确定的。在我们的的模型中，我们选择了100条直线来投影，主要目的是确保在高维度向量空间中的正确性(论文【2】中已指出增加投影线数量会增强medrank算法的查找效率)。增加投影线的数量会增加算法的时间开销，因此需要合理取舍选择恰当数量的投影线。经过测试之后我们觉得100根投影线既能确保正确率也能保证有较低的时间开销。显然，100根线，远远超过实验一的向量维度(3维)，这意味着很快就能投票产出合适的近邻点，因此实验一的数据访问量很低，在访问很少的数据量之后便能投票产生结果。而实验二的向量维度有784维，用100根投影线来投票需要循环更多次数，访问更多的数据页面。这也是为什么实验二比实验一的数据访问量高的原因之一。五、总结我们实现了一个实体推断的模型，这个模型的主要思想很简单，只需要找寻合适数量的邻近点再统计出现次数最多的实体便可完成推断。该模型成立的前提条件是数据都可采用特征向量的形式描述并且存在一个已知实体标签的训练集。在整个实验过程中，我们做的大部分工作是在为这个简单的推断过程提高效率并且保持正确性。通过整理实验结果，我们可以得出结论，通过统计邻近点的实体标签来进行实体推断的办法是可行的，该办法的推断结果正确率也很高。在我们的实验一中，正确率达到100%，当然，我们无法保证在任何应用场景下都能够有100%的正确性，就像实验二，但在实际应用中，推断本身也允许存在误差，只要误差在可接受的范围以内，从实验结果来看我们的模型的命中率还是很理想的。其次，b+树是在数据库和信息检索领域常用的数据结构，而medrank则是一种优秀的查询邻近点的算法。使用b+树配合medrank算法可以高效地完成工作，建立b+树索引的方式能够显著降低数据访问量，提高查询效率，使得查询速度非常快，数据访问量很小，从时间和空间上都节省了很多开销。通过本次实践，我们提出了解决实体推断问题的一种可行的方案，并且使用b+树配合medrank算法优化了查询效率，最后，我们通过进行多个实验验证方案的可行性。我们学习到了面对一个问题如何提出一种可行的解决方案，如何优化方案，如何验证方案的可行性。在优化过程中，学会了如何选择算法和数据结构，选取medrank算法之后对medrank算法的改造，使得它能够查询N个近邻点，这一过程也让我们更深入地理解medrank算法，学会了如何从理解算法过渡到将其改造应用到实际的场景中。在验证模型对于低维度和高维度数据的适用性的过程中，我们学会了从多个方面验证结论的科学方法。最后，从训练集中提取部分数据得到一个可验证的查询集，这种验证方法是从论文【1】中学习到的，我们不仅收获多一种验证方式，也学会了从他人的论文中汲取优秀办法。六、参考文献【1】Damiano Spina, Maria-Hendrike Peetz, Maarten de Rijk,《active learning for entity filtering》【2】R. Fagin, R. Kumar, and D. Sivakumar, 《efficient similarity search and classification via rank aggregation》七、附录实验环境:操作系统: MacBook Pro OS X 10.11.5处理器: 2.7 GHz Intel Core i5内存: 16 GB 1867 MHz DDR3运行代码:请使用Makefile编译代码使用下面示例给出的命令启动程序运行demo之后可以根据数据集的entity预测查询集中每个数据对应的entity实验二的数据文件较大无法上传，我将在网站http://yann.lecun.com/exdb/mnist/ 下载的Mnist训练集和测试集合的数据和标签文件，一共四个二进制文件放在data文件夹中，请进入data文件夹下编译执行get_mnist_data.cpp进行提取，提取完数据之后，请确认data文件夹下面是否有生成Mnist-d.txt和Mnist-q.txt两个文件，正确完成之后才可开始实验二1234cd datag++ get_mnist_data.cpp -o get./getcd ..实验一和实验二运行示例:1234567make./predict -n 55344 -d 3 -qn 100 -ds ./data/color-d.txt -qs ./data/color-q.txt./predict -n 55344 -d 3 -qn 500 -ds ./data/color-d.txt -qs ./data/color-q.txt./predict -n 55344 -d 3 -qn 1000 -ds ./data/color-d.txt -qs ./data/color-q.txt./predict -n 60000 -d 784 -qn 100 -ds ./data/Mnist-d.txt -qs ./data/Mnist-q.txt./predict -n 60000 -d 784 -qn 200 -ds ./data/Mnist-d.txt -qs ./data/Mnist-q.txt./predict -n 60000 -d 784 -qn 300 -ds ./data/Mnist-d.txt -qs ./data/Mnist-q.txt参数说明:-n: 数据集的大小-d: 向量的维度-qn: 查询集的大小-ds: 数据集的文件路径-qs: 查询集的文件路径如果要改用其他数据集，请确保数据文件都为文本文件，并且满足以下格式:每个文件中包含若干个对象，每个对象为一个d维的向量type为该向量所属的entity，dimVal-n(n=1,2,…,d)分别为每个维度的值数据集(-ds)每一行的格式为type dimVal-1 dimVal-2 … dimVal-d查询集(-qs)每一行的格式为type dimVal-1 dimVal-2 … dimVal-d实验一的部分实验结果图形化展示:程序运行结束之后将工作目录切换到check文件夹下，编译convert.cpp并执行1234cd checkg++ convert.cpp -o convert./convertcd ..convert运行结束之后，请确认在check文件夹下是否有生成一个color_show.js文件，生成js文件之后直接在浏览器中打开color_show.html即可看到预测结果。预测结果如下图所示实验一输出结果展示:查询集数据量为100时的实验结果查询集数据量为500时的实验结果查询集数据量为1000时的实验结果实验二输出结果展示:查询集数据量为100时的实验结果查询集数据量为200时的实验结果查询集数据量为300时的实验结果demo中各个模块的功能headers.h: 包含demo使用的头文件及相关参数配置DataStructure(.h, .cpp): demo使用到的数据结构的声明定义和实现，包括B+树节点、特征向量、临时缓存3个数据结构BlockFile(.h, .cpp): 按块(页)管理文件的文件管理器，主要功能是为B+树索引文件的读写和查找提供接口服务，是索引文件与程序交互的中间层BTree(.h, .cpp): B+树的声明定义和实现，包含B+树的实现逻辑，主要提供建立索引的bulkload方法和利用索引进行查找的find方法供外部使用MedRank(.h, .cpp): 主要包括medrank算法的实现，提供medrank算法的接口服务，同时提供一个暴力查找的接口服务供外部使用便于对比medrank算法的性能Util(.h, .cpp): 主要为预处理和预测阶段提供一些工具函数，包括生成m条投影线的单位向量、向量投影、调用B+树接口建立索引、读取训练集数据、读取查询集数据、统计实体出现次数进行预测等功能main.cpp: demo的主要逻辑，调用前面的类提供的接口服务完成主要的逻辑过程，包括接收和解析实验参数、分配资源、进行实验、输出实验结果等功能","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"https://hongchh.github.io/tags/其他/"}]},{"title":"编写一个支持jade+sass+livescript开发的gulpfile","slug":"编写一个支持jade-sass-livescript开发的gulpfile","date":"2016-06-28T03:50:00.000Z","updated":"2017-11-10T11:31:34.105Z","comments":true,"path":"2016/编写一个支持jade-sass-livescript开发的gulpfile/","link":"","permalink":"https://hongchh.github.io/2016/编写一个支持jade-sass-livescript开发的gulpfile/","excerpt":"","text":"gulp是一个优秀的前端开发自动化管理工具，今天，我准备分享一个可以支持用jade+sass+livescript开发web前端的gulpfile。OK，废话不多说，直接进入正题。基本文件目录介绍：12345/app : 该目录下存放我们要开发的应用程序文件（jade, sass, ls等文件）/dest : 该目录下存放最终的成品文件（html, css, js等文件）/node_modules : nodejs的各种package/bower_components : 通过bower安装的各种前端框架或组件/gulpfile.js : gulp的执行文件（gulp在nodes环境下运行，在终端输入gulp之后，它会找到目录下的gulp file.js来执行）前端开发的时候，通常需要搭配后台的服务器，为了做到更好的前后端分离，我们在前端开发的过程中，一般没有同时进行后台的开发。为了模拟后台服务器，我们使用browser-sync包来实现。调用browser-sync的init() API可以实例化一个服务器出来。下面以一个简单hello world的例子来进行说明。上面例子中，定义了2个gulp任务，分别为serve和index。第一个任务依赖到第二个任务，即serve会等待index执行完之后才开始执行。每个gulp任务中的function就是那个任务执行的内容。上面index任务将/app文件夹下的index.html文件pipe到目标文件夹/dest中。serve任务创建了一个服务器，其中的参数这里不多做解释，有兴趣可自行查看browser-sync的文档。在终端输入gulp serve，就会执行serve任务和index任务了。浏览器将会呈现index.html的内容（browser-sync默认发送的其实页面为index.html）。有了一个可以跑起来的服务器，下面，我们就要开始搭建jade的开发环境了。gulp有许多插件，功能多样特别方便，要将jade编译成html文件，也只需要一个插件gulp-jade就够了。请看下面的例子：定义一个名为jade的gulp任务，把它加到serve的依赖中去。jade任务主要做的工作是讲/app下的所有jade文件编译成html文件然后pipe到目标文件夹。这里的$是一个gulp-load-plugins对象，gulp-load-plugins可以帮你引入你需要的插件，也是一个很方便的工具，具体使用方法请自行查看文档。在终端输入gulp serve之后，app文件夹下的jade文件都被编译成/dest文件夹下对应的html文件。这里还有一个要注意的，&#39;./app/**/*.jade&#39;是一种通配模式，这种写法可以匹配出/app文件夹下的所有jade文件，不管它在/app下是否嵌进其他文件夹。你可以将其想象为正则表达式，不过它跟正则表达是还是有所区别的。使用on(&#39;error&#39;, ...)的目的是监测错误，然后利用errorHandler将错误信息输出以便debug（eg. 当jade语法不规范时就会输出相关提示）。继续，接下来搭建sass和livescript的开发环境。使用的插件是gulp-sass和gulp-livescript，安装gulp-livescript时还需要安装livescript。在/app目录下随便写几个sass文件和ls文件，执行gulp serve。定义了sass和livescript任务，形式与jade类似，就只有编译的函数不同。执行之后/app文件夹下的文件也都转化为dest文件加下对应的文件。至此，我们的开发环境已经搭建完毕。但事实上，这还未结束。我们只是有了一个能够自动编译代码并正确输出到目标文件夹的环境。大家有没有发现一个问题，我们编译完之后的css和js文件是不是都要没有引入到html文件中去，即在html文件加上&lt;link&gt;和&lt;script&gt;标签把css和js引入。这个过程，如果人工去做的话也是一件很繁琐的事情，尤其是当你的文件数量很多的时候。举个例子，在现代web SPA开发中，我们可能用到很多angularJS以及相关的组件，还有bootstrap等开源框架，当一个应用比较庞大的时候，这些框架的文件加上自己写的文件合起来数量是相当多的，人工去加入标签效率非常低。下面，我们用gulp-inject和wiredep插件来实现自动引入这些文件。在这个例子中，我将所有css和js文件引入到index.html中。定义了一个inject任务，由于是要把编译好的css和js文件引入到index.html中，因此，需要inject需要等待sass和livescript编译完成，所以，我重新调整了一下依赖关系，把sass, livescript任务从serve的依赖列表中搬了下来（jade顺便也拉下来了，好看点~）。使用inject把要引入的文件引入到index.html中去，这里引入的主要是自己写的文件。然后使用wiredep引入那些通过bower安装的前端框架文件。gulp-inject和wiredep的用法也比较简单，官方文档有示例用法，这里我也不作详细介绍了。以上是成功引入之后的截图，css和js文件都自动加入到index.html文件里面了。这样，我们就可以愉快地只顾在/app打代码而不管其他事情了。最后，我们还有两个需求要实现。开发的过程中，经常会修改代码，每一次修改代码都要刷一下浏览器真的很繁琐，有没有办法让我在修改代码之后按下ctrl+s保存时浏览器也跟着自动刷新呢？答案是yes。回到我们刚一开始提及的browser-sync，这个组件提供了reload API，调用之后它机会自动帮你通知浏览器进行刷新。知道这个API之后，就要开始写如何以及何时调用reload了。请看下面例子：定义一个watch任务，这个任务监控/app下的jade,sass,ls和html文件是否发生修改，以及检测是否有通过bower安装或删除一些文件(检测bower.json的目的)。如果有发生改动的话，马上重新执行inject，我们之前的inject需要等待sass，livescript和jade任务，所以这个操作会执行到的任务有4个，也就是重新编译了一遍所有的文件，并重新引入相关的css和js到index.html文件。执行完之后，再执行function里面的browserSync.reload()，刷新浏览器的页面。狂拽酷炫吊炸天，这回真的可以抛开很多杂七杂八的事了。最后一个需求，一次性删除/dest目录下所有内容。在开发时，会不断的迭代过去的版本，文件数量也会随之改变。如果我在/app下面删除了1.ls，执行gulp serve之后虽然那些没有被删除的文件都会重新编译然后写到/dest目录下对应的文件，但是/dest下面的1.js却会一直留在那里。这些琐碎文件有时也是对项目的一种污染，而且文件太过琐碎的话清理起来也是麻烦，最好的方式就是一次性删除/dest下的内容然后重新编译/app里面的东西。所以，我最后实现了一个清除功能，例子如下：看到代码最后的clean任务，这个任务使用了del插件，可以删除对应路径的文件或文件夹。在终端执行gulp clean之后，dest文件夹整个被删除，一点不剩。到这里，整个gulpfile就算是写完了，支持jade+sass+livescript开发环境，可以自动监控文件改动刷新浏览器，一次性清除文件。基本功能算是有了，不过也有不少地方需要完善。本博客只给一个简单例子作为交流，展示一般的gulpfile要怎么写，如果巧妙地利用插件。有兴趣者可以继续完善该gulpfile。比如：这个gulpfile还不能同时支持ls和js混合开发，sass和css混合开发，其次，在watch的时候重新执行inject会做多余的工作，应该检查是文件改动还是文件增删，如果是文件改动，比如我改了某些ls文件，那只需执行livescript任务重新编译livescript即可。如果是文件增删，则需要重新inject引入正确的css和js到index.html~最后附上本文用到的完整的gulpfile.js。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970var gulp = require('gulp');var browserSync = require('browser-sync').create();var gutil = require('gulp-util');var wiredep = require('wiredep').stream;var $ = require('gulp-load-plugins')(&#123; pattern: ['gulp-*', 'del']&#125;);var _ = require('lodash');var dest = './dest';function errorHandler(title) &#123; return function (err) &#123; gutil.log(gutil.colors.red('[' + title + ']'), err.toString()); this.emit('end'); &#125;;&#125;gulp.task('serve', ['inject', 'watch'], function() &#123; browserSync.init(&#123; startPath : '/', server : &#123; baseDir : './dest', routes : &#123; '/bower_components' : 'bower_components' &#125; &#125; &#125;);&#125;);gulp.task('jade', function() &#123; return gulp.src(['./app/**/*.jade']) .pipe($.jade(&#123;pretty : true&#125;)) .on('error', errorHandler('jade')) .pipe(gulp.dest(dest));&#125;);gulp.task('sass', function() &#123; return gulp.src(['./app/**/*.sass']) .pipe($.sass()) .on('error', errorHandler('sass')) .pipe(gulp.dest(dest));&#125;);gulp.task('livescript', function() &#123; return gulp.src(['./app/**/*.ls']) .pipe($.livescript()) .on('error', errorHandler('livescript')) .pipe(gulp.dest(dest));&#125;);gulp.task('inject', ['sass', 'livescript', 'jade'], function() &#123; var injectFiles = gulp.src([dest+'/**/*.js', dest+'/**/*.css'], &#123;read: false&#125;); return gulp.src(['./app/index.html']) .pipe($.inject(injectFiles, &#123;ignorePath : '/dest', addRootSlash: false&#125;)) .on('error', errorHandler('inject')) .pipe(wiredep(_.extend(&#123;&#125;, 'bower_components'))) .pipe(gulp.dest(dest));&#125;);gulp.task('watch', function() &#123; gulp.watch(['./app/**/*.html', './app/**/*.jade', './app/**/*.ls', './app/**/*.sass', 'bower.json'], ['inject', function() &#123; browserSync.reload(); &#125;]);&#125;);gulp.task('clean', function() &#123; return $.del(dest);&#125;);","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://hongchh.github.io/tags/Web/"}]},{"title":"在windows下使用postgreSQL导入tpch的数据表","slug":"在windows下使用postgreSQL导入tpch的数据表","date":"2016-04-03T14:07:00.000Z","updated":"2017-11-10T10:17:49.212Z","comments":true,"path":"2016/在windows下使用postgreSQL导入tpch的数据表/","link":"","permalink":"https://hongchh.github.io/2016/在windows下使用postgreSQL导入tpch的数据表/","excerpt":"","text":"初学数据库，老师要求我们去熟悉postgreSQL，并且要求使用tpch的数据。今天在使用dbgen生成数据以及导入数据到postgre的过程中遇到一些问题，也在网上看了许多资料，几番折腾之后最终也算解决了问题，现在来把今天使用dbgen的流程和遇到的问题以及解决方案总结一下，以便以后需要的时候不用再到处找资料。使用visual studio打开dbgen文件夹下的tpch.sln并生成，生成之后会有一个Debug文件夹下，把该文件夹下的dbgen.exe复制到dbgen文件夹下，运行dbgen.exe生成后缀名为.tbl的文件。在postgre创建数据库tpch，连接到数据库tpch之后创建表，表的定义可以查看dbgen目录下的dss.ddl。使用copy操作来从文件导入数据，这里以生成的.tbl文件里面的lineitem.tbl为例进行说明。具体操作为，COPY LINEITEM FROM &#39;&lt;path&gt;&#39;，&lt;path&gt;为lineitem.tbl所在的位置，具体参考下图。我一开始是放在桌面下，直接运行指令之后报错了，提示permission denied，原来是postgre对桌面目录没有访问权限，于是试着用管理员身份运行SQL shell，还是不行。最后直接把lineitem.tbl复制到postgre的安装目录下了，一举搞定，导入完数据记得再删除这些文件即可。再次运行copy操作，还是报错，这次提示的错误是‘无效的整型输入语法’，一脸懵逼，网上几番查找之后才发现原来是引文分隔符的问题，postgre在copy时默认字段的分隔符是&#39;\\t&#39;，而dbgen生成的数据里面是用&#39;|&#39;字符来分开字段，于是造成字段没能正确区分开。解决方案就是在copy的时候加上参数delimiter指定分隔符号为&#39;|&#39;，具体写法为：COPY LINEITEM FROM &#39;&lt;path&gt;&#39; WITH DELIMITER AS &#39;|&#39;; 再次尝试了一下，这个错误解决了，但却出现了另一个错误，提示‘最后期望字段后有额外数据’，真是贼坑，怎么还有额外数据呢？最后打开lineitem.tbl文件一观文件内容，发现每一行记录的结尾都带有&#39;|&#39;字符，心想会不会是因为这个的影响导致copy按照字段分隔理解为&#39;|&#39;后面还有其他字段。网上查了查也没有查到什么解决方法，倒是看到一篇博客让我恍然大悟。博客链接如下http://www.xuebuyuan.com/845077.html，里面也是讲到导入数据出错的问题，他用的是ms sql server，解决方案是导入数据时加参数rowterminator=‘|\\n’，看到他的解决方案，我就大概明白是怎么一回事了。查阅postgre的文档，却没有发现copy操作有什么指定每一行结束的字符的参数，于是通过加参数的方式看来是行不通了。只能修改tbl文件了。简单写了个c++程序(c++11)，把生成的lineitem.tbl文件里面文本每一行的结尾的&#39;|&#39;字符去掉。最后运行完之后，再次尝试copy，这次终于顺利copy了，把文件中的数据导入到数据库，这也恰好证实了之前的猜测是对的，果然是因为结尾的&#39;|&#39;字符的影响。123456789101112131415161718#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; freopen(\"lineitem.tbl\", \"r\", stdin); freopen(\"tbl/lineitem.tbl\", \"w\", stdout); string line; while (getline(cin, line)) &#123; line.pop_back(); cout &lt;&lt; line &lt;&lt; endl; &#125; return 0;&#125;虽然都只是小问题，不过还是折腾了许久，还好最后解决了还算有所收获。今晚跟同学交流时发现他在linux下也遇到这些问题，把今天的解决方法跟他交流之后也顺利解决了。现在，基本流程和解决方法描述完毕，以上描述应该是可以适用windows和linux系统，其他系统应该也类似。第一次写博客，写得比较粗糙。若有错误或者可以改进的地方还请大神指点。","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://hongchh.github.io/tags/数据库/"}]}]}