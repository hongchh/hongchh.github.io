{"meta":{"title":"洪创煌的博客","subtitle":"好好学习，天天向上！","description":null,"author":"洪创煌","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2017-11-10T03:08:10.000Z","updated":"2017-11-10T03:08:10.923Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Ajax文件上传","slug":"Ajax文件上传","date":"2017-11-09T11:27:23.000Z","updated":"2017-11-09T11:29:33.462Z","comments":true,"path":"2017/11/09/Ajax文件上传/","link":"","permalink":"http://yoursite.com/2017/11/09/Ajax文件上传/","excerpt":"","text":"为了避免在实现简单的异步文件上传功能时候引入一个第三方库文件的尴尬情形（库文件可能造成多余的开销，拉低应用加载速度，尤其是在引入库文件之后仅使用其中一两个功能的情况下，性价比极低），最近了解了一下文件异步上传的实现原理，顺带看了看进度条、图片预览等功能的实现，做一点简单的整理。 文件上传HTML结构如下，一个file input和一个button。当点击“上传”按钮的时候，将file input选中的文件上传到服务器。12&lt;input type=\"file\" name=\"file\" id=\"file\" /&gt;&lt;button id=\"upload\"&gt;上传&lt;/button&gt; 以下是“上传”按钮的点击事件处理器，点击按钮之后通过一个XMLHttpRequest对象来实现发送异步请求。上传的内容为文件，因此还需要用到FormData对象，FormData可以js里面创建表单对象，将file input的文件append到FormData对象中，最后调用XHR对象的send()方法将表单数据发送出去即可。12345678910111213141516171819var file = document.querySelector('#file');var upload = document.querySelector('#upload');var xhr = new XMLHttpRequest();// 点击上传function uploadFile(event) &#123; var formData = new FormData(); formData.append('test-upload', file.files[0]); xhr.onload = uploadSuccess; xhr.open('post', '/upload', true); xhr.send(formData);&#125;// 成功上传function uploadSuccess(event) &#123; if (xhr.readyState === 4) &#123; console.log(xhr.responseText); &#125;&#125; 上传进度在进行文件上传的时候，xhr对象会有一个upload属性，会提供一个progress事件，在相应的事件处理器里面通过事件对象可以知道当前的上传进度，利用这个特点可以很方便地实现进度条或者进度提示。123&lt;input type=\"file\" name=\"file\" id=\"file\" /&gt;&lt;button id=\"upload\"&gt;上传&lt;/button&gt;&lt;span id=\"progress\"&gt;0%&lt;/span&gt; 12345678910111213141516171819var progress = document.querySelector('#progress');// 点击上传function uploadFile(event) &#123; var formData = new FormData(); formData.append('test-upload', file.files[0]); xhr.onload = uploadSuccess; xhr.upload.onprogress = setProgress; xhr.open('post', '/upload', true); xhr.send(formData);&#125;// 进度条function setProgress(event) &#123; if (event.lengthComputable) &#123; var complete = Number.parseInt(event.loaded / event.total * 100); progress.innerHTML = complete + '%'; &#125;&#125; 图片预览上传图片的时候可以利用FileReader对象来实现图片预览。FileReader可以异步读取用户电脑上的文件，将file input选中的文件传给FileReader，读取之后取得文件的URL并设置为image元素的src即可让选中的图片文件显示出来。1234&lt;input type=\"file\" name=\"file\" id=\"file\" /&gt;&lt;button id=\"upload\"&gt;上传&lt;/button&gt;&lt;span id=\"progress\"&gt;0&lt;/span&gt;&lt;img id=\"image\" src=\"\" width=\"200\" /&gt; 1234567891011var file = document.querySelector('#file');file.addEventListener('change', previewImage, false);// 图片预览function previewImage(event) &#123; var reader = new FileReader(); reader.onload = function (event) &#123; image.src = event.target.result; &#125;; reader.readAsDataURL(event.target.files[0]);&#125; 服务端处理使用express搭建一个简单的NodeJS服务端，提供上传文件的接口。express要支持文件上传需要用到中间件，在express官网上有很多介绍。这里我使用的是multer中间件，下面是简单的使用示例。upload.single表示这个接口接受的上传文件数量为1个，’test-upload’限制了上传的表单数据的键为’test-upload’（formData.append(‘test-upload’, file.files[0]);）。经过这个中间件处理之后，通过req.file可以访问到文件的相关信息，上传的文件存放在uploads文件夹中。1234567891011121314151617181920const upload = require('multer')(&#123; dest: 'uploads/' &#125;);app.post('/upload', upload.single('test-upload'), (req, res) =&gt; &#123; // 没有附带文件 if (!req.file) &#123; res.json(&#123; ok: false &#125;); return; &#125; // 输出文件信息 console.log('===================================================='); console.log('fieldname: ' + req.file.fieldname); console.log('originalname: ' + req.file.originalname); console.log('encoding: ' + req.file.encoding); console.log('mimetype: ' + req.file.mimetype); console.log('size: ' + (req.file.size / 1024).toFixed(2) + 'KB'); console.log('destination: ' + req.file.destination); console.log('filename: ' + req.file.filename); console.log('path: ' + req.file.path);&#125;); 由输出可以看到，文件的命名使用一个哈希值表示，并且去除了后缀名，想要保持文件的原有的命名格式，需要再通过fs对文件进行改名。123456789101112131415161718192021222324252627282930app.post('/upload', upload.single('test-upload'), (req, res) =&gt; &#123; // 没有附带文件 if (!req.file) &#123; res.json(&#123; ok: false &#125;); return; &#125; // 输出文件信息 console.log('===================================================='); console.log('fieldname: ' + req.file.fieldname); console.log('originalname: ' + req.file.originalname); console.log('encoding: ' + req.file.encoding); console.log('mimetype: ' + req.file.mimetype); console.log('size: ' + (req.file.size / 1024).toFixed(2) + 'KB'); console.log('destination: ' + req.file.destination); console.log('filename: ' + req.file.filename); console.log('path: ' + req.file.path); // 重命名文件 let oldPath = path.join(__dirname, req.file.path); let newPath = path.join(__dirname, 'uploads/' + req.file.originalname); fs.rename(oldPath, newPath, (err) =&gt; &#123; if (err) &#123; res.json(&#123; ok: false &#125;); console.log(err); &#125; else &#123; res.json(&#123; ok: true &#125;); &#125; &#125;);&#125;); 完整代码ajax异步文件上传、进度显示、图片预览1234&lt;input type=\"file\" name=\"file\" id=\"file\" /&gt;&lt;button id=\"upload\"&gt;上传&lt;/button&gt;&lt;span id=\"progress\"&gt;0&lt;/span&gt;&lt;img id=\"image\" src=\"\" width=\"200\" /&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546(function () &#123; 'use strict'; var file = document.querySelector('#file'); var upload = document.querySelector('#upload'); var progress = document.querySelector('#progress'); var image = document.querySelector('#image'); var xhr = new XMLHttpRequest(); upload.addEventListener('click', uploadFile, false); file.addEventListener('change', previewImage, false); // 点击上传 function uploadFile(event) &#123; var formData = new FormData(); formData.append('test-upload', file.files[0]); xhr.onload = uploadSuccess; xhr.upload.onprogress = setProgress; xhr.open('post', '/upload', true); xhr.send(formData); &#125; // 成功上传 function uploadSuccess(event) &#123; if (xhr.readyState === 4) &#123; console.log(xhr.responseText); &#125; &#125; // 进度条 function setProgress(event) &#123; if (event.lengthComputable) &#123; var complete = Number.parseInt(event.loaded / event.total * 100); progress.innerHTML = complete + '%'; &#125; &#125; // 图片预览 function previewImage(event) &#123; var reader = new FileReader(); reader.onload = function (event) &#123; image.src = event.target.result; &#125;; reader.readAsDataURL(event.target.files[0]); &#125;&#125;)(); express服务器提供文件上传接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const express = require('express');const upload = require('multer')(&#123; dest: 'uploads/' &#125;);const path = require('path');const fs = require('fs');const port = 8080;let app = express();app.set('port', port);// index.html, index.js放在static文件夹中app.use(express.static(path.join(__dirname, 'static')));app.get('*', (req, res) =&gt; &#123; res.redirect('index.html');&#125;);app.post('/upload', upload.single('test-upload'), (req, res) =&gt; &#123; // 没有附带文件 if (!req.file) &#123; res.json(&#123; ok: false &#125;); return; &#125; // 输出文件信息 console.log('===================================================='); console.log('fieldname: ' + req.file.fieldname); console.log('originalname: ' + req.file.originalname); console.log('encoding: ' + req.file.encoding); console.log('mimetype: ' + req.file.mimetype); console.log('size: ' + (req.file.size / 1024).toFixed(2) + 'KB'); console.log('destination: ' + req.file.destination); console.log('filename: ' + req.file.filename); console.log('path: ' + req.file.path); // 重命名文件 let oldPath = path.join(__dirname, req.file.path); let newPath = path.join(__dirname, 'uploads/' + req.file.originalname); fs.rename(oldPath, newPath, (err) =&gt; &#123; if (err) &#123; res.json(&#123; ok: false &#125;); console.log(err); &#125; else &#123; res.json(&#123; ok: true &#125;); &#125; &#125;);&#125;);app.listen(port, () =&gt; &#123; console.log(\"[Server] localhost:\" + port);&#125;);","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript-DOM基础知识总结","slug":"JavaScript-DOM基础知识总结","date":"2016-08-23T07:01:00.000Z","updated":"2017-11-10T13:14:01.963Z","comments":true,"path":"2016/08/23/JavaScript-DOM基础知识总结/","link":"","permalink":"http://yoursite.com/2016/08/23/JavaScript-DOM基础知识总结/","excerpt":"","text":"DOM(文档对象模型)是针对HTML和XML文档的一个API。DOM描绘了一个层次化的节点树，允许开发人员添加、删除和修改页面的某一部分。 一、Node类型DOM1级定义了一个Node接口，该接口将由DOM中的所有节点类型实现。这个Node接口在JavaScript中是作为Node类型实现的。JS中的所有节点类型都继承自Node类型，共享着相同的基本属性和方法。每个节点都有一个nodeType属性表明节点类型，节点类型由下面12个数值常量表示，任何节点必属于其中之一。 Node.ELEMENT_NODE(1); Node.ATTRIBUTE_NODE(2); Node.TEXT_NODE(3); Node.CDATA_SECTION_NODE(4); Node.ENTITY_REFERENCE_NODE(5); Node.ENTITY_NODE(6); Node.PROCESSING_INSTRUCTION_NODE(7); Node.COMMIT_NODE(8); Node.DOCUMENT_NODE(9); Node.DOCUMENT_TYPE_NODE(10); Node.DOCUMENT_FRAGMENT_NODE(11); Node.NOTATION_NODE(12); 通过比较someNode.nodeType与上述某个数值常量是否相等可以确定节点类型。此外，节点除了nodeType属性之外还保存有nodeName和nodeValue属性，这两个属性的值取决于节点类型。举个例子，元素节点的nodeName中保存着元素的标签名而nodeValue的值则为null。 1-节点关系每个加点都有一个childNodes属性，其中保存着一个类数组的NodeList对象用于保存一组有序的子节点。NodeList对象的独特之处在于，它实际上是基于DOM结构动态查询的结果，因此DOM结构的变化能够自动反应到NodeList对象中。访问NodeList中的节点时可以通过方括号向数组一样访问，也可以通过item()方法访问，如以下示例： 12var firstChild = someNode.childNodes[0];var secondChild = someNode.childNodes.item(1); 每个节点都有一个parentNode属性，该属性指向该节点在文档树中的父节点。包含在childNodes列表中的所有节点具有相同的父节点，因此它们的parentNode属性指向同一个节点。此外，包含在ChildNodes列表中的每个节点相互之间都是同胞节点。通过使用列表中每个节点的previousSibling和nextSibling属性，可以访问同一列表中的任何其他节点。列表的第一个节点的previousSibling属性值为null，最后一个节点的nextSibling属性值为null。父节点有firstChild和lastChild属性分别指向其childNodes列表中的第一个和最后一个节点。最后，所有节点都有一个ownerDocument属性，该属性指向表示整个文档的文档节点。 2-操作节点节点关系指针都是只读的，因此DOM提供了一些操作节点的方法。下面介绍几个常用的操作方法： appendChild(node)：用于向childNodes列表的末尾添加一个节点。添加节点后，childNodes的新增节点、父节点以及最后一个子节点的关系指针会得到相应更新。更新之后，appendChild()返回新增的节点。如果传入appendChild()的节点已经是文档的一部分了，那么结果就是将该节点从原来的位置转移到新的位置。任何DOM节点不能同时出现在文档中的多个位置上。 1234567var returnedNode = someNode.appendChild(newNode);console.log(returnedNode == newNode); // trueconsole.log(someNode.lastChild == newNode); // truereturnedNode = someNode.appendChild(someNode.firstChild); // 插入已存在的节点console.log(returnedNode == someNode.firstChild); // falseconsole.log(returnedNode == someNode.lastChild); // true insertBefore(node1, node2)：该方法接受两个参数，要插入的节点与参考节点。插入节点会变成参考节点的前一个同胞节点(previousSibling)同时被返回。如果参考节点为null，那么将与appendChild()执行同样的操作。 1234// 插入到倒数第二个位置returnedNode = someNode.insertBefore(newNode, someNode.lastChild);// 插入到最后一个位置returnedNode = someNode.insertBrfoer(newNode, null); replaceChild(node1, node2)：该方法接受两个参数，要插入的节点和被替换的节点。替换节点将从文档树中被移除，同时插入节点占据其位置。从技术上讲，被替换节点仍然存在文档中，但它在文档树中已经没了自己的位置。 removeChild(node)：用于将某个节点从文档树种移除。 cloneChild(node)：克隆某个节点。该方法可以接受一个布尔值参数，表示是否执行深复制。执行深复制时，除了克隆当前节点之外还会将其整个子节点树也克隆。若是浅复制，则仅复制当前节点。复制后返回的节点副本属于文档所有，但是没有为其制定父节点，需要通过appendChild()等方法将其添加到文档树中。cloneNode()不会复制DOM节点的JS属性，例如事件处理程序等。 normalize()：处理文档树种的文本节点。由于解析器的实现或者DOM操作等原因，可能会出现文本节点不包含文本，或者接连出现两个文本节点的情况。当在某个节点上调用这个方法时，就会在该节点的后代节点中查找符合上述两种情况的文本节点，找到空文本节点则删除它，找到连续的文本节点则合并为一个文本节点。 二、Document类型JS通过Document类型表示文档。document对象是HTMLDocument(继承自Document类型)的一个实例。Document节点具有以下特征： nodeType: 9 nodeName: “#document” nodeValue: null parentNode: null ownerDocument: null 1-文档的子节点Document节点的子节点可以是DocumentType、Element、ProcessingInstruction或Comment。document对象有内置的快速访问某些特殊元素的属性，如下所示： document.documentElement：该属性始终指向页面中的&lt; html&gt;元素 document.body：指向&lt; body&gt;元素 document.doctype：取得对&lt; !DOCTYPE&gt;的引用 2-文档信息document对象提供了一些属性用于获取所表现的网页的一些信息，主要有下列几个属性： document.title：&lt; title&gt;元素中的文本，修改该属性可惜修改网页标题 document.URL：网页完整的URL，即浏览器地址栏中显示的URL document.domain：网页的域名 document.referrer：链接到当前页面的那个页面的URL 3-查找元素document.getElementById()：该方法接受一个参数，即要获取元素的ID。找到相应的元素则返回该元素，否则返回null。如果存在多个相同ID的元素，则返回文档中第一次出现的元素 document.getElementsByTagName()：该方法接受一个参数，即要获取元素的标签名。返回一个HTMLCollection对象，包含所有符合查找标签名的元素，可以通过方括号或item()方法访问每一个项。HTMLCollection对象还有一个namedItem()方法可以通过元素的name特性取得集合中的项，而且，对命名的项也可以使用方括号语法来访问。给该方法传入参数&quot;*&quot;可以获取文档中所有元素。下面给出代码示例 12345678&lt;img src=\"img-1.jpg\" name=\"img-1\"&gt;&lt;img src=\"img-2.jpg\"&gt;&lt;script&gt; var images = document.getElementsByTagName(\"img\"); // 获取所有img元素 var img1 = images.namedItem(\"img-1\"); // 获取命名为img-1的图片元素 var img1 = images[\"img-1\"]; // 另一种等价的访问方式 var all = document.getElementsByTagName(\"*\"); // 获取文档中所有元素&lt;/script&gt; document.getElementsByName()：该方法接受一个参数，查找名称。与getElementsByTagName()方法类似，该方法也返回一个HTMLCollection对象，返回所有带有给定name特性的元素 4-特殊集合除了属性和方法之外，document对象还有一些特殊的集合。这些集合都是HTMLCollection对象，为访问文档常用的部分提供快捷方式。 document.anchors：文档中所有带name特性的&lt; a&gt;元素 document.forms：文档中所有&lt; form&gt;元素 document.images：文档中所有&lt; img&gt;元素 document.links：文档中所有带href特性的&lt; a&gt;元素 三、Element类型Element类型用于表现XML或HTML元素，提供了对元素标签名、子节点及特性的访问。Element节点具有以下特征： nodeType: 值为1 nodeName: 元素标签名 nodeValue: null parentNode: 可能是Document或Element 子节点可能是Element、Text、Comment、ProcessingInstruction、CDATASection或EntityReference要想访问元素的标签名，可以使用nodeName属性，也可以使用tagName属性。在HTML中，标签名始终以大写表示，而在XML则会与源代码一致，因此，可能会出现如下代码所示的问题： 123456var div = document.getElementById(\"myDiv\");console.log(div.tagName); // 输出\"DIV\"// 如果需要执行某些判断，使用下面的写法更好，适用于多种文档if (div.tagName.toLowerCase() == \"div\") &#123; // do something&#125; 1-HTML元素所有HTML元素都由HTMLElement类型表示，HTMLElement类型继承自Element类型并添加了一些属性，添加的属性分别对应每个HTML元素中都存在的下列标准特性： id：元素在文档中的唯一标识符 title：有关元素的附加说明信息 lang：元素内容的语言代码，很少使用 dir：语言的方向，值为”ltr”(从左到右)或”rtl”(从右到左) className：元素的class特性，即CSS类名 通过给以上属性赋值可以修改相应元素特性的值，如以下代码示例： 12345// 假设存在&lt;div id=\"myDiv\" class=\"bd\" title=\"a div\" lang=\"en\" dir=\"ltr\"&gt;&lt;/div&gt;var div = document.getElementById(\"myDiv\");console.log(div.id); // 输出\"myDiv\"console.log(div.title); // 输出\"a div\"div.className = \"ft\"; // 类名变为\"ft\" 2-获取和操作特性getAttribute()：该函数接受一个参数，用于获取某个特性的值。传递的参数要与实际的也姓名相同，因此当获取类名的时候要传入&quot;class&quot;而不是&quot;className&quot;，特性不区分大小写。下面给出代码示例: 12var div = document.getElementById(\"myDiv\");console.log(div.getAttribute(\"id\")); // 输出\"myDiv\" setAttribute()：该函数接受两个参数，要设置的特性名和值。通过setAttribute()方法既可以操作HTML特性也可以操作自定义特性。请看下面代码示例 12div.setAttribute(\"class\", \"ft\");div.setAttribute(\"mycolor\", \"red\"); removeAttribute()：该方法接受一个参数，用于删除特性 3-attributes属性Element类型是使用attributes属性的唯一一个DOM节点类型。attributes属性中包含一个NamedNodeMap对象，元素的每一个特性都有一个Attr节点表示，每个节点都保存在NamedNodeMap对象中，该对象拥有以下方法。attributes属性中包含一系列节点，每个节点的nodeName就是特性的名称，nodeValue就是特性的值。 getNamedItem(name)：返回nodeName属性等于name的节点 removeNamedItem(name)：删除nodeName属性等于name的节点 setNamedItem(node)：向列表中添加节点，以节点的nodeName属性为索引 item(pos)：返回位于数字pos位置处的节点 关于attributes如何使用请看下面代码示例： 12345// 获取某个div元素的id的值的两种方式var id = div.attributes.getNamedItem(\"id\").nodeValue;id = div.attributes[\"id\"].nodeValue;// 设置id的值div.attributes[\"id\"].nodeValue = \"xxx\"; 4-创建元素使用document.createElement()方法可以创建新元素。该方法接受一个参数，即要创建的元素的标签名。创建元素之后可通过属性设置相关的特性，通过appendChild()等方法添加到文档树中。 5-元素的子节点元素可以有任意数目的子节点和后代节点。元素的childNodes属性中包含了它的所有子节点。如果想要通过特定的标签名获取子节点或后代节点，可以通过元素调用getElementsByTagName()方法，这种调用方式除了搜索起点是当前元素之外，其他方面都跟通过document调用这个方法相同。请看以下代码示例： 1234// 获取div元素下的img元素var img = div.getElementsByTagName(\"img\");// 获取整个文档中的img元素var allImg = document.getElementsByTagName(\"img\"); 四、Text类型文本节点由Text类型表示，可以通过noveValue或data属性访问Text节点中包含的文本。文本节点作为元素节点的子节点，只要元素开始与结束标签之间存在内容，就会创建一个文本节点。在JS中，也可以直接使用document.createTextNode(text)创建文本节点。在JS中创建文本节点可能会使得一个父节点下面存在连续的多个文本节点，可以直接在父元素上调用normalize()方法将多个文本节点合并称为一个。使用下列方法可以操作节点中的文本。 appendData(text)：将text添加到节点的末尾 deleteData(offset, count)：从offset指定的位置开始删除count个字符 insertData(offset, text)：从offset指定的位置开始初入text replaceData(offset, count, text)：用text替换从offset指定位置开始到offset+count为止处的文本 splitText(offset)：从offset指定的位置将当前文本节点分成两个文本节点 substringData(offset, count)：提取从offset位置开始到offset+count为止处的字符串 五、Comment类型文档中的注释在DOM中由Comment类型表示，它与Text类型继承自相同的基类，拥有除splitText()之外的所有字符串操作方法。与Text类型相似，可通过nodeValue或data属性来获取注释内容。浏览器不会识别位于&lt;html&gt;标签后面的注释，如果要访问注释节点，一定要保证它是&lt;html&gt;元素的后代。 六、CDATASection类型该类型只针对基于XML的文档，表示CDATA区域。 七、DocumentType类型该类型包含与文档的doctype相关的所有信息 八、DocumentFragment类型在所有的节点类型中只有DocumentFragment在文档中没有对应的标记。DOM规定文档片段是一种”轻量级”的文档，可以包含和控制节点，但不会像完整的文档那样占用额外的资源。不能把文档片段直接添加到文档中，但可以将它作为一个仓库来使用，在里面保存将来可能添加到文档中的节点。创建文档片段的方法如下： 1var fragment = document.createDocumentFragment(); 如果将文档中的节点添加到文档片段中，就会从文档树中移除该节点，浏览器中也不再显示这些节点。添加到文档片段中的新节点同样也不属于文档树。可以通过appendChild()或insertBefore()将文档片段中的内容添加到文档中。在将文档片段作为参数传递给这两个方法时，实际上只会将文档片段的所有子节点添加到相应的位置上，文档片段本身永远不会成为文档树的一部分。以下面代码为例，如果逐个地添加列表项，将导致浏览器反复渲染新信息，使用一个文档片段来保存创建的列表项，最后一次性地将它们添加到文档中，就可以完美地避开反复渲染的问题。 123456789var fragment = document.createDocumentFragment();var ul = document.getElementById(\"myList\");var li = null;for (var i = 0; i &lt; 10; ++i) &#123; li = document.createElement(\"li\"); li.appendChild(document.createTextNode(\"Item \" + (i+1))); fragment.appendChild(li); // 添加新元素到文档片段中&#125;ul.appendChild(fragment); // 一次性将文档片段中的内容添加到文档 九、Attr类型该类型用于表示元素的特性，由于有getAttribute()等方法，因此很少使用这个类型来操作元素特性。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"【分治策略】逆序对问题总结","slug":"【分治策略】逆序对问题总结","date":"2016-08-18T08:41:00.000Z","updated":"2017-11-10T12:59:04.211Z","comments":true,"path":"2016/08/18/【分治策略】逆序对问题总结/","link":"","permalink":"http://yoursite.com/2016/08/18/【分治策略】逆序对问题总结/","excerpt":"","text":"一、逆序对1. 问题背景假如有一组电影集合，包括n部电影。某个人对这n部电影的喜欢程度各有高低，根据其喜欢程度对这n部电影进行排名，按照从1到n的方式进行标记，这就形成了一个关于电影的排名表。假设你和一个陌生人各有自己对于这n部电影的排名表。现在想要比较你跟这个陌生人的“品味”差别，看看你们俩是否有“类似”的爱好。一个很自然的办法就是对比两个人各自的排名表，看看两个排名表的排名状况是否相似。如果两张排名表上的电影顺序非常接近，就表示两个人的”品味”非常接近，反之则两个人的”品味”差距较大。 2. 问题的具体描述给定一个序列包含n个数据{a1, a2, ..., an}，我们假设所有的数都是不相同的，我们想定义一个度量，它将告诉我们这个序列跟处于上升顺序的序列相差多远。如果a1 &lt; a2 &lt; ... &lt; an，那么这个度量的值应该为0，表示与上升顺序基本一致。如果数变得更加杂乱时这个度量也就相应增大，表示与上升顺序相差较大。把这个概念量化的一种自然方式是计算序列中的逆序对的个数。逆序对的判断标准如下，当i &lt; j且ai &gt; aj时，这两个元素构成一个逆序对。举个例子，序列{2，4，1，3，5}中有3个逆序对(2,1)，(4,1)，(4,3)，所以该序列与上升顺序的序列之间的不相似度为3。 3. 逆序对的应用继续考虑背景介绍中提出的问题，我们可以把任意两个人的排名表，其中一个作为上升顺序表来参考，然后计算另一个排名表中的逆序对个数。逆序对越多，则两个排名表的差别越大，说明两个人的爱好品味差别越大。逆序对如果很接近0，说明两个人的爱好品味都很接近。这种计算可以用于许多方面，比如书本、电影、餐厅等等，对用户的嗜好进行匹配，进而知道哪些用户跟哪些用户的兴趣爱好更为接近，这些计算结果可以用于许多应用软件的推荐服务。 4. 计算逆序对的算法显然，存在一个时间复杂度为O(n^2)的暴力算法，遍历所有可能的数据对(ai, aj)，计算出其中的逆序对的个数。这种算法比较简单便不多做阐述，这里介绍的是一种更高效的算法，它的时间复杂度只有O(nlogn)。 这个算法的思想跟归并排序很是类似，也是一个分治算法。它的基本思想如下：把要统计逆序对个数的序列C沿着中间位置切分成两个子序列A和B，递归地计算子序列A和子序列B中逆序对的个数并排序，然后合并两个子序列，合并的同时计算所有(ai,aj)的数对中逆序对的个数(ai在子序列A，aj在子序列B)。这个算法的关键过程是合并计数这个环节，假设我们已经递归地排序好了这个序列的两个子序列并计算好了子序列的逆序对个数，我们要如何计算总的逆序对个数呢？由于子序列A和B是已经排好序的，在把A和B合并到C时，按照归并排序的合并过程，每次都挑选两个子序列中最小的元素加入到C中。每次A中的元素ai被加到C中，不会遇到新的逆序，因为ai小于子序列B中剩下的每个元素，并且ai出现在B中元素的前面(子序列A为原序列的前半部分)。但每次B中的元素bj被加到C中，说明它比子序列A中剩下的元素都小，由于B中所有元素本来都排在A后面，所以bj就与A中剩下的所有元素都构成逆序对，此时A中剩下的元素个数就是与bj构成的逆序对的个数。理解这个过程之后，我们就可以很容易地在合并过程中计算逆序对个数了，合并计数过程的伪代码如下：12345678910111213141516171819mergeAndCount(A, B)初始化count= 0，C = 空while A和B都不为空 令ai和bj分别为A和B中的首元素 if ai &lt;= bj 把ai加入到输出表C中 A = A - &#123;ai&#125; else 把bj加入到输出表C中 B = B - &#123;bj&#125; count += A中剩下的元素 endIfendWhileif A 为空 把B中剩下元素加入到Celse 把A中剩下元素加入到CendIfreturn 合并结果C和逆序对个数count 整个合并计数过程如以上所示，理解了合并计数过程之后再来理解整个计算逆序对个数的算法就简单多了，整个算法流程的伪代码如下：12345678910sortAndCount(C)if L只有1个元素 没有逆序,c1 = c2 = c3 = 0else 把这个表C均分成两半，A和B (c1, A) = sortAndCount(A) (c2, B) = sortAndCount(B) (c3, C) = mergeAndCount(A, B)endIfreturn (c1 + c2 + c3, C) 5. C++代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;using namespace std;class Array &#123;public: Array(const int&amp; size): size(size) &#123; entry = new int[size]; &#125; ~Array() &#123; if (entry != NULL) &#123; delete [] entry; &#125; &#125; int operator[](int i) const &#123; return entry[i%size]; &#125; int&amp; operator[](int i) &#123; return entry[i%size]; &#125; int count() &#123; int* tmp = new int[size]; int c = sortAndCount(entry, tmp, 0, size-1, true); delete [] tmp; return c; &#125;private: int sortAndCount(int* arr, int* tmp, int beg, int end, bool inArr) &#123; if (beg &lt; end) &#123; int mid = (beg + end) / 2; int c1 = sortAndCount(arr, tmp, beg, mid, !inArr); int c2 = sortAndCount(arr, tmp, mid+1, end, !inArr); int c3 = 0; if (inArr) &#123; c3 = mergeAndCount(arr, tmp, beg, mid, end); &#125; else &#123; c3 = mergeAndCount(tmp, arr, beg, mid, end); &#125; return c1 + c2 + c3; &#125; else &#123; if (!inArr) tmp[beg] = arr[beg]; return 0; &#125; &#125; int mergeAndCount(int* arr1, int* arr2, int beg, int mid, int end) &#123; int i = beg, j = mid+1, k = beg, c = 0; while (i != mid+1 &amp;&amp; j != end+1) &#123; if (arr2[i] &lt; arr2[j]) &#123; arr1[k++] = arr2[i++]; &#125; else &#123; arr1[k++] = arr2[j++]; c += mid - i + 1; &#125; &#125; while (i != mid+1) arr1[k++] = arr2[i++]; while (j != end+1) arr1[k++] = arr2[j++]; return c; &#125; int* entry; int size;&#125;;int main() &#123; int size; cin &gt;&gt; size; Array arr(size); for (int i = 0; i &lt; size; ++i) &#123; cin &gt;&gt; arr[i]; &#125; cout &lt;&lt; \"逆序对个数: \" &lt;&lt; arr.count() &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/数据结构与算法/"}]},{"title":"JavaScript-window、location对象基础知识整理","slug":"JavaScript-window、location对象基础知识整理","date":"2016-08-18T02:43:00.000Z","updated":"2017-11-10T12:54:01.321Z","comments":true,"path":"2016/08/18/JavaScript-window、location对象基础知识整理/","link":"","permalink":"http://yoursite.com/2016/08/18/JavaScript-window、location对象基础知识整理/","excerpt":"","text":"一、window对象window是BOM的核心对象，表示浏览器的一个实例。在浏览器中，window对象有双重角色，它是通过JS访问浏览器窗口的一个接口，也是Global对象。任何在全局作用域中声明的变量和函数都会变成window对象的属性和方法。 虽然全局变量也是window对象的属性，但是与直接在window上定义的属性也是有点不同。全局变量不能通过delete操作符删除，而直接在window上定义的属性则可以。另外，直接访问未声明的变量会抛出错误，而通过window对象访问则不会，只是返回undefined。123456789var p1 = 'p1';window.p2 = 'p2';delete window.p1; // 无法删除delete window.p2;console.log(window.p1); // 输出'p1'console.log(window.p2); // undefinedconsole.log(window.p3); // undefinedconsole.log(p3); // 出错 如果页面中包含框架(frame)，则每个框架都有自己的window对象，并且保存在frames集合中，可以通过数值索引或者框架名称来访问相应的window对象。举个例子，对于下面代码，可以使用window.frames[0]或者window.frames[&quot;top&quot;]来访问名字为”top”的框架。123456789101112&lt;html&gt; &lt;head&gt; &lt;title&gt;Frames&lt;/title&gt; &lt;/head&gt; &lt;frameset rows=\"160, *\"&gt; &lt;frame src=\"top-frame.html\" name=\"top\"&gt;&lt;/frame&gt; &lt;frameset cols=\"50%, 50%\"&gt; &lt;frame src=\"left-frame.html\" name=\"left\"&gt;&lt;/frame&gt; &lt;frame src=\"right-frame.html\" name=\"right\"&gt;&lt;/frame&gt; &lt;/frameset&gt; &lt;/frameset&gt;&lt;/html&gt; 通过window对象的属性可以获取和调节窗口位置。使用下面代码可以跨浏览器获取窗口左边和上边的位置。使用moveTo和moveBy方法可以移动窗口调节位置，moveTo接受的参数是新位置的坐标，moveBy接受的参数是水平和垂直方向上的偏移量。(移动窗口的方法在某些浏览器中可能被禁用；这两个方法不适用于框架)12345var leftPos = (typeof window.screenLeft == \"number\") ? window.screenLeft : window.screenX;var topPos = (typeof window.screenTop == \"number\") ? window.screenTop : window.screenY;window.moveTo(0, 0); // 移动到屏幕左上角window.moveBy(0, 100); // 向下移动100像素 通过window对象的属性可以获取和调节窗口大小。使用resizeTo和resizeBy方法可以调节窗口大小，resizeTo接受的参数是窗口的新宽度和高度，resizeBy接受的参数是新宽度高度与原来的宽度高度的差值。 超时调用window对象的setTimeout方法用于超时调用，它接受两个参数：需要执行的代码和以毫秒为单位的时间数值。执行代码可以以字符串或函数的形式进行传参。这个方法的运行效果是使得传入参数的执行代码会在经过一段时间之后才开始执行。传递字符串可能导致性能损失，因此应该尽量以函数的形式传递需要执行的代码。另外，JS是一个单线程的解释器，一定时间内只能执行一段代码，为了控制要执行的代码，就有一个JS任务队列。这些任务会按照它们被添加到队列的顺序执行。setTimeout的第二个参数实际上是告诉JS再过多久之后把当前任务添加到任务队列，如果队列是空的，那么添加后任务就会马上执行，否则还需要等待队列前面的代码执行完之后才执行setTimeout第一个参数里面的任务。也就是说，即便我第二个参数指定为1秒，但是1秒过后任务不一定会准时执行。123456// 以字符串形式传入需要执行的代码，1000毫秒后输出'23333'setTimeout(\"console.log('23333')\", 1000);// 以函数形式传入需要执行的代码，2000毫秒后输出'hehe~'setTimeout(function() &#123; console.log('hehe~');&#125;, 2000); 超时调用其他注意点：调用setTimeout之后会返回一个数值ID，通过这个ID可以来取消某个对应的超时调用。调用clearTimeout，将ID作为参数传入，即可取消该ID所对应的超时调用。超时调用的代码都是在全局作用域中执行，this的值在非严格模式下指向window对象，严格模式下为undefined。 间歇调用间歇调用与超时调用类似，只不过它是按照指定的时间间隔重复执行代码，知道间歇调用被取消或者页面被卸载。设置间歇调用的方法是setInterval，接受的参数与setTimeout相同。setInterval方法也会返回一个ID，对应一个特定的间歇调用。取消间歇调用时，通过clearInterval方法即可完成。间歇调用也是在全局作用域中执行，this的值与超时调用一样。123456789var num = 1;var ID = null;ID = setInterval(function() &#123; console.log(num); num += 1; if (num == 5) &#123; clearInterval(ID); &#125;&#125;, 500); 一般认为，使用超时调用模拟间歇调用是一种最佳模式，如以下代码示例。在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动，而使用超时调用，则可以完全避开这个缺点，保证先后顺序。123456789var num = 1;function func() &#123; console.log(num); num += 1; if (num &lt; 5) &#123; setTimeout(func, 500); &#125;&#125;setTimeout(func, 500); 二、location对象location对象提供了与当前窗口中加载的文档有关的信息，还提供一些导航功能。location对象既是window对象的属性，也是document对象的属性，也就是说，window.location和document.location引用的是同一个对象。location对象可以将URL解析为独立的片段，让开发人员可以通过不同的的属性访问这些片段。下表列出location对象的所有属性并给出例子说明。 属性名 例子 说明 hash “#contents” URL中的hash(#号后面跟着的字符串，锚) host “www.wrox.com:80” 服务器名称和端口号 hostname “www.wrox.com” 服务器名称 href “http://www.wrox.com“ 完整的URL pathname “/WileyCDA” URL中的路径名 port “80” 端口号 protocol “http” 协议 search “?q=javascript” 查询字符串 查询字符串：通过search属性可以获取查询字符串，但search属性返回的是从问号到URL结尾的所有内容，因此不能很好地方便我们访问查询字符串中的属性。在使用search属性获取查询字符串之后还需要再对其进行解析，然后才可以获取我们想要获得的属性和属性值。可以使用如下代码来解析查询字符串： 123456789101112131415function getQueryStringArgs() &#123; var qs = (location.search.length &gt; 0 ? location.search.substring(1) : \"\"); var args = &#123;&#125;; var items = qs.length ? qs.split(\"&amp;\") : []; var item = null, name = null, value = null; for (var i = 0; i &lt; items.length; ++i) &#123; item = items[i].split(\"=\"); name = decodeURIComponent(item[0]); // 查询字符串一般是被编码过的，所以这里需要解码 value = decodeURIComponent(item[1]); if (name.length) &#123; args[name] = value; &#125; &#125; return args;&#125; 位置操作：使用location对象可以改变浏览器的位置。下面给出代码示例。每次修改location的属性(hash属性除外)，页面都会以新的URL重新加载，页面刷新后浏览器的历史记录中会生成一条新纪录。如果想要仅跳转页面但是不产生历史记录，可以通过replace方法来实现。最后，location还有一个与位置相关的方法，reload，重新加载页面。 1234567891011121314location.assign(\"http://www.wrox.com\");window.location = \"http://www.wrox.com\";location.href = \"http://www.wrox.com\";// 上面3种示例都是直接修改整个URL，下面给出只修改URL中的某个部分来改变位置的例子location.hash = \"#section1\";location.search = \"?q=javascript\";location.hostname = \"www.yahoo.com\";location.pathname = \"mydir\";location.port = 8080;// 使用replace不产生历史记录location.replace(\"http://www.wrox.com\");// 重新加载页面location.reload(); // 从服务器或浏览器缓存中重新加载location.reload(true); // 从服务器重新加载","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"【分治策略】归并排序算法总结","slug":"【分治策略】归并排序算法总结","date":"2016-08-17T04:41:00.000Z","updated":"2017-11-10T12:45:36.338Z","comments":true,"path":"2016/08/17/【分治策略】归并排序算法总结/","link":"","permalink":"http://yoursite.com/2016/08/17/【分治策略】归并排序算法总结/","excerpt":"","text":"归并排序思想归并排序的思想很简单，拿到一个无序的序列，先从序列的中间位置将其切分成两个子序列，然后对两个子序列递归地进行归并排序，最后，将排好序的子序列合并成一个完整的有序序列。归并排序算法的伪代码如下：123456序列seq = [s1, s1, s3, ..., sn]归并排序： 将seq切分成两个部分seq1, seq2; 对seq1进行归并排序; 对seq2进行归并排序; 把seq1和seq1合并称为一个完整的序列seq; 数组归并排序对数组进行归并排序，需要开一个临时数组以便合并时可以使用。在普通的数组归并排序实现中，空间开销可能会达到O(nlogn)或者更差的复杂度，这里介绍另外一种方式，在O(n)的空间开销内完成数组的归并排序。C++代码实现如下所示，以下面代码为例，在归并排序时，开了两个数组arr和tmp，通过不断交换两个数组来实现空间的高效利用。假如归并当前这一层需要将元素存在arr中，那么下一层就反过来将元素存在tmp中，就这样不断轮替，就不用再每一层的合并操作里都开临时数组去辅助实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;using namespace std;class SortingArray &#123;public: SortingArray(const int&amp; size): size(size) &#123; entry = new int[size]; &#125; ~SortingArray() &#123; if (entry != NULL) &#123; delete [] entry; &#125; &#125; int operator[](int i) const &#123; return entry[i%size]; &#125; int&amp; operator[](int i) &#123; return entry[i%size]; &#125; void sort() &#123; int* tmp = new int[size]; // 临时数组 mergeSort(entry, tmp, 0, size-1, true); delete [] tmp; &#125;private: void mergeSort(int* arr, int* tmp, int beg, int end, bool inArr) &#123; if (beg &lt; end) &#123; int mid = (beg + end) / 2; mergeSort(arr, tmp, beg, mid, !inArr); mergeSort(arr, tmp, mid+1, end, !inArr); // arr和tmp轮替 if (inArr) &#123; merge(arr, tmp, beg, mid, end); &#125; else &#123; merge(tmp, arr, beg, mid, end); &#125; &#125; else &#123; // 如果到最后一层需要考虑这层的元素是否需要转移到tmp上 if (!inArr) tmp[beg] = arr[beg]; &#125; &#125; void merge(int* arr1, int* arr2, int beg, int mid, int end) &#123; int i = beg, j = mid+1, k = beg; while (i != mid+1 &amp;&amp; j != end+1) &#123; if (arr2[i] &lt; arr2[j]) arr1[k++] = arr2[i++]; else arr1[k++] = arr2[j++]; &#125; while (i != mid+1) arr1[k++] = arr2[i++]; while (j != end+1) arr1[k++] = arr2[j++]; &#125; int* entry; int size;&#125;;int main() &#123; int size; cin &gt;&gt; size; SortingArray sa(size); for (int i = 0; i &lt; size; ++i) &#123; cin &gt;&gt; sa[i]; &#125; sa.sort(); for (int i = 0; i &lt; size; ++i) &#123; cout &lt;&lt; sa[i] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; return 0;&#125; 链表归并排序对链表进行归并排序就比较简单且高效了，不仅时间复杂度只有O(nlogn)，而且空间复杂度仅为O(1)。主要流程还是一样，切分，排序，合并。不过，在对链表沿着中间点切分成两部分可能要麻烦点，我这里采取的方法是常见的链表切分方法，快慢指针法。具体的C++代码实现如下所示，切分链表时，定义两个指针，一个快指针和一个慢指针，快指针一次移动2步，慢指针一次移动1步，当快指针到达链表末尾时，慢指针的位置就是链表中点。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;iostream&gt;using namespace std;struct Node &#123; Node(int entry = 0, Node* next = NULL): entry(entry), next(next) &#123;&#125; int entry; Node* next;&#125;;class SortingList &#123;public: SortingList(): head(NULL), last(NULL) &#123;&#125; ~SortingList() &#123; while (head != NULL) &#123; Node* tmp = head; head = head-&gt;next; delete tmp; &#125; &#125; void push(const int&amp; e) &#123; if (head == NULL) &#123; head = new Node(e); last = head; &#125; else &#123; last-&gt;next = new Node(e); last = last-&gt;next; &#125; &#125; void sort() &#123; // 排序可能使得头尾节点产生变化，注意重新调整 head = mergeSort(head); last = head; while (last != NULL &amp;&amp; last-&gt;next != NULL) last = last-&gt;next; &#125; int pop() &#123; int e = head-&gt;entry; Node* tmp = head; head = head-&gt;next; delete tmp; return e; &#125;private: // 需要注意排序使得结点顺序改变可能导致头指针发生变化，因此需要返回新的头指针 Node* mergeSort(Node* subList) &#123; if (subList != NULL &amp;&amp; subList-&gt;next != NULL) &#123; Node* mid = divideIntoTwoList(subList); subList = mergeSort(subList); mid = mergeSort(mid); subList = merge(subList, mid); &#125; return subList; &#125; // 快慢指针法切分链表 Node* divideIntoTwoList(Node* subList) &#123; Node* fast = subList-&gt;next; Node* slow = subList; while (fast != NULL) &#123; fast = fast-&gt;next; if (fast != NULL) &#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; &#125; fast = slow-&gt;next; slow-&gt;next = NULL; return fast; &#125; // 合并两个链表，空间开销O(1) Node* merge(Node* list1, Node* list2) &#123; Node fakeHead; Node* last = &amp;fakeHead; while (list1 != NULL &amp;&amp; list2 != NULL) &#123; if (list1-&gt;entry &lt; list2-&gt;entry) &#123; last-&gt;next = list1; list1 = list1-&gt;next; &#125; else &#123; last-&gt;next = list2; list2 = list2-&gt;next; &#125; last = last-&gt;next; &#125; if (list1 != NULL) last-&gt;next = list1; else last-&gt;next = list2; return fakeHead.next; &#125; Node* head; Node* last;&#125;;int main() &#123; int n, e; cin &gt;&gt; n; SortingList sl; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; e; sl.push(e); &#125; sl.sort(); for (int i = 0; i &lt; n; ++i) &#123; cout &lt;&lt; sl.pop() &lt;&lt; ' '; &#125; cout &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/数据结构与算法/"}]},{"title":"JavaScript模仿块级作用域与私有变量","slug":"JavaScript模仿块级作用域与私有变量","date":"2016-08-17T01:53:00.000Z","updated":"2017-11-10T12:41:57.801Z","comments":true,"path":"2016/08/17/JavaScript模仿块级作用域与私有变量/","link":"","permalink":"http://yoursite.com/2016/08/17/JavaScript模仿块级作用域与私有变量/","excerpt":"","text":"一、块级作用域JS没有块级作用域的概念，定义在块语句中的变量，实际上是在包含函数中而非语句中创建的，如下面例子，变量i和j创建之后即便离开了块语句，只要还在包含函数func中，就可以访问到这两个变量。必须等到函数func执行完毕销毁作用域之后，变量i和j才会被销毁。123456789101112function func(count) &#123; for (var i = 0; i &lt; count; ++i) &#123; console.log(i); &#125; console.log(i); // 可以访问到i，输出5 &#123; var j = '2333'; &#125; console.log(j); // 可以访问到j，输出2333&#125;func(5); 使用一个匿名立即调用函数就可以解决这个问题，模拟出块级作用域的效果。具体的语法如下，将块级作用域的内容放在这个匿名函数的函数体中，在这个匿名函数中定义的变量在函数执行完毕之后都会销毁，因此，外部访问不到块级作用域中的变量。这种技术经常在全局作用域中被用在函数外部，避免向全局作用域中添加过多的变量和函数。在多人协作开发的项目中，过多的全局变量和函数名常常会导致命名冲突，通过这种技术可以创建自己的私有作用域，不用再担心变量的命名，也不会搞乱全局作用域。123(function() &#123; // 模拟块级作用域&#125;)(); 二、私有变量JS没有私有成员的概念，所有对象的属性都是公有的，外部都可以访问到。不过倒是有私有变量的概念，例如函数中定义的变量都可以被认为是私有变量，因为只能在函数内部访问到这些变量。下面介绍几种JS中创建私有变量常用的模式。 1. 构造函数内构建闭包通过在函数内部创建闭包，那么闭包通过自己的作用域链可以访问这些私有变量，利用闭包，创建用于访问私有变量的公有方法(特权方法)。如下面代码示例，privateVar和privateFunc都位于闭包函数publicFunc的作用域链上，外部访问不到，只能通过publicFunc函数来访问。这种在构造函数中定义特权方法的方式有一个缺点，这个缺点就是构造函数模式下，每次创建对象的时候构造函数中的每个方法(无论公有或私有)都会被重新创建一遍。123456789101112131415161718function MyObject() &#123; // 私有变量和函数 var privateVar = 1; function privateFunc() &#123; return true; &#125; // 特权方法 this.publicFunc = function() &#123; privateVar += 1; // 访问私有变量 if (privateFunc()) &#123; // 调用私有方法 console.log(privateVar); &#125; &#125;;&#125;var obj = new MyObject();obj.publicFunc(); // 输出2 2. 静态私有变量这种模式创建了一个私有作用域，并在其中封装了一个构造函数及相应的方法。在私有作用域中定义了私有变量和私有函数，然后定义构造函数和公有方法，公有方法在原型上定义。定义构造函数时不使用函数声明，而是直接使用函数表达式，并且不使用var关键字定义，目的是为了让构造函数变成一个全局函数，在私有作用域之外可以访问到构造函数，这样我们才可以创建对象。(严格模式下不允许给未经声明的变量赋值，因此不能使用这种方法)。这种模式下，特权方法在原型上定义，因此所有实例都使用同一个函数，这个特权方法作为一个闭包也总是引用私有作用域中的函数和变量，因此，这种模式下私有变量与函数都是有实例共享的，解决了构造函数模式下的多次创建问题。12345678910111213141516171819// 私有作用域(function() &#123; // 静态私有成员和方法 var staticPrivateVar = '2333'; function staticPrivateFunc() &#123; console.log('static'); &#125; // 构造函数 MyObject = function() &#123;&#125; // 公有方法 MyObject.prototype.publicFunc = function() &#123; console.log(staticPrivateVar); // 访问私有变量 staticPrivateFunc(); // 调用私有方法 &#125;&#125;)();// 全局作用域var obj = new MyObject();obj.publicFunc(); // 输出\"2333\"和\"static\" 3. 模块模式模块模式的存在是为了给单例创建私有变量和方法使单例得到增强，这种模式的语法如下，使用一个返回对象的匿名立即调用函数，在这个函数内部，首先定义了私有变量和函数，然后将一个对象字面量作为函数的返回值返回。返回的对象字面量中仅包含可以公开的属性方法。如果需要创建一个对象并对某些数据进行初始化，同时还要公开一些能够访问私有数据的方法，那么就可以使用模块模式。通过这种模式创建的对象都是Object的实例，没有特定属于某一种类型，因此不适用与instanceof之类的操作符。12345678910111213141516171819var singleton = (function() &#123; // 私有变量和函数 var privateVar = '2333'; function privateFunc() &#123; return true; &#125; // 公有变量和函数 return &#123; publicVar: 'hehe~', publicFunc: function() &#123; if (privateFunc()) &#123; // 调用私有函数 console.log(privateVar); // 访问私有变量 &#125; &#125; &#125;;&#125;)();singleton.publicFunc(); // 输出'2333'console.log(singleton.publicVar); // 输出'hehe~' 4. 增强的模块模式这种模式解决了上面说到的模块模式无法检查类型的问题，具体做法就是使用某种类型的实例，然后在匿名立即调用函数返回之前给对象加入属性方法，具体语法如下。这种模式创建的单例对象属于某种特定的类型，可以使用instanceof操作进行检测。123456789101112131415161718192021222324// 某种自定义类型function SomeType() &#123;&#125;var singleton = (function() &#123; // 私有变量和函数 var privateVar = '2333'; function privateFunc() &#123; return true; &#125; // 创建对象 var object = new SomeType(); // 公有变量和函数 object.publicVar = 'hehe~'; object.publicFunc = function() &#123; if (privateFunc()) &#123; // 调用私有函数 console.log(privateVar); // 访问私有变量 &#125; &#125; // 返回对象 return object;&#125;)();singleton.publicFunc(); // 输出'2333'console.log(singleton.publicVar); // 输出'hehe~'console.log(singleton instanceof SomeType); // 检测类型，输出'true'","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript闭包的原理与缺陷","slug":"JavaScript闭包的原理与缺陷","date":"2016-08-16T08:37:00.000Z","updated":"2017-11-10T12:36:00.874Z","comments":true,"path":"2016/08/16/JavaScript闭包的原理与缺陷/","link":"","permalink":"http://yoursite.com/2016/08/16/JavaScript闭包的原理与缺陷/","excerpt":"","text":"闭包的原理闭包是指有权访问另一个函数作用域中的变量的函数。根据下面的代码示例来理解什么是闭包，在add函数内部的匿名函数中，访问到外部函数的变量outerArg，在执行add(10)之后外部函数返回了，并且将内部的匿名函数赋值给了变量addTen，此时通过addTen调用函数，依然可以访问到outerArg，也就是10。这个闭包中的变量，只能通过调用addTen函数访问，无法通过其他渠道访问到，下面代码最后一行通过输出属性的方式尝试访问结果是输出undefined。outerArg是属于add函数的作用域中的变量，addTen有权访问add函数作用域中的变量，因此addTen是一个闭包。闭包产生的本质是：在一个函数(外部函数)内部定义的函数(内部函数)会将外部函数作用域中的活动对象添加到自己的作用域链中，下面代码中inner函数将add函数的outerArg添加到自己的作用域链上。在add函数执行完之后，其执行环境会被销毁，但由于inner函数还在引用outerArg，所以outerArg不会被销毁，依然保留在inner函数的作用域链中。直到inner函数(addTen函数)被销毁之后，outerArg才会跟着其作用域链一起被销毁。由于闭包变量是位于作用域链上，因此必须调用闭包函数进入其作用域之后才能访问到闭包变量。123456789101112function add(outerArg) &#123; function inner(innerArg) &#123; return innerArg + outerArg; &#125; return inner;&#125;var addTen = add(10);console.log(addTen(1)); // 输出11console.log(addTen(2)); // 输出12console.log(addTen(3)); // 输出13console.log(addTen.outerArg); // undefined 闭包的缺陷首先，闭包会将外部函数的活动对象都添加到自己的作用域链中，因此相对于普通的函数会更加耗费内存。 其次，闭包只能获取到外部函数中任何变量的最后一个值。如下面代码所示，在for循环中的匿名函数可以访问到闭包变量i，但是由于闭包所保存的是整个变量对象，因此所有闭包函数中访问到的变量i其实就是同一个变量i(Outer函数的变量i)，而Outer函数在执行完毕后，其变量i的值为5，所以5个闭包函数访问到的值都是5。12345678910111213141516function Outer() &#123; var arr = new Array(); for (var i = 0; i &lt; 5; ++i) &#123; arr[i] = function() &#123; return i; &#125;; &#125; return arr;&#125;var arr = Outer();console.log(arr[0]()); // 输出5console.log(arr[1]()); // 输出5console.log(arr[2]()); // 输出5console.log(arr[3]()); // 输出5console.log(arr[4]()); // 输出5 最后，this对象的指向可能与预期的不一致。以下面代码为例，getName的执行结果是输出Window而不是someObj，原因就是getNameFunc函数返回之后，它的执行环境会被销毁，返回的函数赋值给getName，当我执行getName的时候执行环境实在全局环境下，this指向的对象是window，this.name引用到的是全局作用域下的name，也就是&#39;Window&#39;。1234567891011var name = 'Window';var someObj = &#123; name: 'someObj', getNameFunc: function() &#123; return function() &#123; return this.name; &#125; &#125;&#125;;var getName = someObj.getNameFunc();console.log(getName()); // 输出'Window' 闭包缺陷的解决方案对于闭包只能获取到外部函数中任何变量的最后一个值问题，可通过定义一个立即执行函数(IIFE)来解决。这种方法的原理其实是在执行立即调用函数时，传入变量i作为参数，而i是按值传递的，相当于复制了一次i的值，所以5次循环调用了5次函数复制了5个不同的i的值创建了5个值不同的变量num，而内部函数(这里指代码中注释inner处的函数)的闭包变量不在是引用i，而是引用了变量num。每个内部函数都有其对应的闭包变量num，这个时候闭包函数的行为就符合我们的预期效果了。12345678910111213141516171819function Outer() &#123; var arr = new Array(); for (var i = 0; i &lt; 5; ++i) &#123; arr[i] = function(num) &#123; // inner return function() &#123; return num; &#125; &#125;(i); &#125; return arr;&#125;var arr = Outer();console.log(arr[0]()); // 输出0console.log(arr[1]()); // 输出1console.log(arr[2]()); // 输出2console.log(arr[3]()); // 输出3console.log(arr[4]()); // 输出4 对于this对象问题，可以通过避免直接使用this对象的方式来解决。这种方式其实是给this对象起了个别名，用that指向外部函数作用域的this对象，然后在内部函数中引用that，将其加入到闭包中，这样就可以正确地访问到外部函数作用域的this对象了。123456789101112var name = 'Window';var someObj = &#123; name: 'someObj', getNameFunc: function() &#123; var that = this; // 别名 return function() &#123; return that.name; &#125; &#125;&#125;;var getName = someObj.getNameFunc();console.log(getName()); // 输出'someObj' 最后，分享一个实用的闭包内存优化技巧。闭包会引用外部函数的整个活动对象，这种机制可能会导致保存多余的变量而造成内存浪费，以下面代码为例，内部函数仅仅引用了obj对象的id属性，而闭包会把整个obj对象都保存下来，如果该对象上有很多耗费内存的属性，那么这种简单的引用方式会导致产生一个很大的闭包。优化方式如AnotherOuter函数的写法所示，关键在于把需要引用的变量保存下来，然后通过把obj对象设置为null让它丢失引用以便被自动内存回收机制回收处理，这样，闭包函数引用的就只有id这个变量了。123456789101112131415161718192021function Outer() &#123; var obj = &#123;&#125;; obj.id = '12345678'; obj.name = 'aha'; // ... 假设经过很多处理过程，最后obj上带有很多属性 return function() &#123; return obj.id; &#125;;&#125;function AnotherOuter() &#123; var obj = &#123;&#125;; obj.id = '12345678'; obj.name = 'aha'; // ... 假设经过很多处理过程，最后obj上带有很多属性 var id = obj.id; obj = null; return function() &#123; return id; &#125;;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"【贪心算法】Huffman编码","slug":"【贪心算法】Huffman编码","date":"2016-08-16T03:04:00.000Z","updated":"2017-11-10T12:27:40.188Z","comments":true,"path":"2016/08/16/【贪心算法】Huffman编码/","link":"","permalink":"http://yoursite.com/2016/08/16/【贪心算法】Huffman编码/","excerpt":"","text":"问题描述有一组字符集{c1, c2, ..., cn}，在使用这组字符集的过程中，通过统计发现每个字符都有其相应的出现频率，假设对应的频率为{f1, f2, ..., fn}。现在需要对这些字符进行二进制编码，我们希望的编码结果如下：每个字符都有其独一无二的编码；编码长度是变长的，频率大的字符使用更少的二进制位进行编码，频率小的字符则使用比较多的二进制位进行编码，使得最终的平均编码长度达到最短；每个字符的编码都有特定的前缀，一个字符的编码不可能会是另一个字符的前缀，这样我们可以在读取编码时，当读取的二进制位可以对应一个字符时，就读取出该字符。举个例子，假如我们有字符集{&#39;a&#39;, &#39;b&#39;, &#39;c&#39;}，字符&#39;a&#39;的编码为001，字符&#39;b&#39;的编码为010，那么此时c的编码不能为00或者01，这样我们才能识别&#39;a&#39;和&#39;c&#39;或者&#39;b&#39;和&#39;c&#39;。 算法描述上述问题可以使用Huffman编码来解决，Huffman编码实际上是一个贪心算法。在这个算法中，使用二叉树来表示前缀码，每个字符都是树的叶子结点，非叶子结点则不代表任何字符。将每个字符构造成结点形成结点集S，每次都从结点集S中选出频率最低的两个结点x和y作为子节点进行建树，为这两个子结点构造一个父节点，父节点不保存任何字符，父节点的频率为两个子节点频率之和，将两个子节点从S中移走，将父节点加入S中。不断迭代下去，直到S只剩一个结点时，这个结点就是树的根节点。这样我们就得到了一棵Huffman树，整个过程就是一个自底向上的建树过程。由于从根节点到每个叶子节点有且仅有一条路径，所以，每个叶子的路径都是不一样的，唯一的。我们把从根节点到叶子节点的路径记录下来，便可作为叶子节点上字符的编码。初始化编码为空，从根节点开始，往左走则编码加0，往右走则编码加1，具体展示图如下所示： 建树过程的伪代码如下：123456789101112给定字符集C=&#123;c1,c2,...,cn&#125;，每个字符ci都有相应的频率fi根据字符集构建结点集S=&#123;s1,s2,...,sn&#125;，每个结点si保存有字符ci和频率fi的信息while |S| != 1 do 取出S中频率最小的两个结点x和y; 构造父节点z; z.f = x.f + y.f; z.c = undefined; z.left = x; z.right = y; 将x和y从S中移走，将z加入S;endWhile此时S[0]就是根节点，返回根节点 最后整个Huffman编码过程的C++实现如下(建树+编码)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;/* Huffman树的节点 */struct Node &#123; Node() &#123;&#125; Node(int frequency, char ch, Node* left, Node* right) &#123; this-&gt;frequency = frequency; this-&gt;ch = ch; this-&gt;left = left; this-&gt;right = right; &#125; int frequency; char ch; Node* left; Node* right;&#125;;class HuffmanCode &#123;public: HuffmanCode() &#123;&#125; ~HuffmanCode() &#123; if (nvec.size() &gt; 0) clear(nvec[0]); &#125; /* 建树 */ void buildTree(const char* ch, const int* fq, const int&amp; size) &#123; for (int i = 0; i &lt; size; ++i) &#123; Node* node = new Node(fq[i], ch[i], NULL, NULL); nvec.push_back(node); &#125; while (nvec.size() != 1) &#123; Node* x = getMinNodeAndRemoveIt(); Node* y = getMinNodeAndRemoveIt(); Node* z = new Node(x-&gt;frequency + y-&gt;frequency, '\\0', x, y); nvec.push_back(z); &#125; &#125; /* 编码 */ void buildCode() &#123; buildCodeByDFS(nvec[0], \"\"); &#125; /* 获取特定字符的编码 */ string getCode(char ch) &#123; return code[ch]; &#125;private: /* 清空Huffman树，释放资源 */ void clear(Node* root) &#123; if (root != NULL) &#123; clear(root-&gt;left); clear(root-&gt;right); delete root; &#125; &#125; /* 获取结点集中频率最小的结点并将其移出结点集 */ Node* getMinNodeAndRemoveIt() &#123; int min = 0; for (int i = 1; i &lt; nvec.size(); ++i) &#123; if (nvec[i]-&gt;frequency &lt; nvec[min]-&gt;frequency) &#123; min = i; &#125; &#125; Node* tmp = nvec[nvec.size() - 1]; nvec[nvec.size() - 1] = nvec[min]; nvec[min] = tmp; tmp = nvec[nvec.size() - 1]; nvec.pop_back(); return tmp; &#125; /* 遍历Huffman树进行编码 */ void buildCodeByDFS(Node* r, string str) &#123; if (r-&gt;left == NULL &amp;&amp; r-&gt;right == NULL) code[r-&gt;ch] = str; if (r-&gt;left != NULL) buildCodeByDFS(r-&gt;left, str + \"0\"); if (r-&gt;right != NULL) buildCodeByDFS(r-&gt;right, str + \"1\"); &#125; vector&lt;Node*&gt; nvec; // 结点集 map&lt;char, string&gt; code; // 字符编码&#125;;int main() &#123; char ch[100]; int fq[100], size; cin &gt;&gt; size; if (size &lt;= 0 || size &gt; 100) &#123; cout &lt;&lt; \"字符集大小不合适\" &lt;&lt; endl; return -1; &#125; for (int i = 0; i &lt; size; ++i) &#123; cin &gt;&gt; ch[i] &gt;&gt; fq[i]; &#125; HuffmanCode hfmc; hfmc.buildTree(ch, fq, size); hfmc.buildCode(); string code; for (int i = 0; i &lt; size; ++i) &#123; code = hfmc.getCode(ch[i]); cout &lt;&lt; ch[i] &lt;&lt; \": \" &lt;&lt; code &lt;&lt; endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/数据结构与算法/"}]},{"title":"【贪心算法】Kruskal算法的实现与应用","slug":"【贪心算法】Kruskal算法的实现与应用","date":"2016-08-14T05:56:00.000Z","updated":"2017-11-10T12:23:20.305Z","comments":true,"path":"2016/08/14/【贪心算法】Kruskal算法的实现与应用/","link":"","permalink":"http://yoursite.com/2016/08/14/【贪心算法】Kruskal算法的实现与应用/","excerpt":"","text":"问题背景假设我们有n个位置的集合V={v1, v2, ..., vn}，我们想在它们顶部建立一个通信网络，网络应该是连通的，即任何两个位置vi和vj之间至少存在一条路径可以相互到达。对于确定的两个位置(vi,vj)，假设在这两个位置之间建立网络连接的费用为c(i,j)，c(i,j) &gt; 0。将上述问题抽象成一个无向图G=(V,E)，用图来表示可能被建立的链接的集合，图的每个结点代表每个位置，图的每条边e的长度表示该边连接的两个结点vi和vj之间建立网络连接的费用c(i,j)。为了求得最小的建造费用，只需要找到n-1条边将n个结点连接起来并确保图的连通性，然后这n-1条边的权值尽可能小。抽象为图之后上述问题可以用最小生成树模型来解决。 算法描述Kruskal算法是用于解决最小生成树问题的一种优秀的算法，其主要思路是，先将原图G的所有边按照权值大小进行排序，同时假定我们有一个n个结点，但是还没有边的子图T。每次都从G的边中取出权值最小的边e并尝试加入到子图T中，加入e时需要保持子图T中不能产生环，如果加入e之后会产生环则放弃该边，否则把边e加入子图T。重复这样的操作，直到子图T变成一个连通图时结束算法，对于一个有n个结点的图，等价于在得到n-1条边时就可以结束算法了。Kruskal算法的过程展示图如下所示： 算法实现要实现kruskal算法，先来了解一些背景知识，【图的连通分支】，一个图被分成几个小块，每个小块都是连通的。小块与小块之间不连通，那么每个小块称为一个连通分支。一个孤立结点也算一个连通分支。 下面，还要需要了解一种数据结构，这里我暂且将它称为MergeQuery数据结构。在Kruskal算法中，当考虑一条边e = (u, v)时，我们需要有效地找出包含结点u和v的连通分支。如果两个连通分支不同，u和v位于不同的连通分支，不存在连接结点u和v的路径，此时边e可以加入到最小生成树中。如果连通分支相同，那么u和v处于同一个连通分支中，也就是已经存在一条从u到v路径，此时边e不能加入最小生成树(加入的话会产生环)。接着，我们在考虑如果一条边e连接的结点u和v位于不同的连通分支可以加入的情况，此时将边e加入之后，u和v就连通了，原本u和v所在的两个连通分支也将合并称为一个连通分支。MergeQuery数据结构将用于支持Kruskal算法的相关操作，该数据结构维护不相交的集合(即图的连通分支)，对于一个结点u，操作query(u)返回包含u的集合的名字。若query(u) == query(v)则说明u和v位于同一连通分支。此外还有一个操作merge(A, B)，用于将两个集合合并为一个集合(两个连通分支合并)。在Kruskal算法中，选取权值最小的边e = (u, v)之后，先使用query操作检测u和v是否位于同一连通分支，若是则放弃这条边，如果不是，则加入边e，使用merge(A, B)将u和v所在的两个连通分支合并。 实现MergeQuery的一种简单的数据结构：维护一个数组component，假设图有n个结点{1, 2, ..., n}，创建一个长度为n的component数组，初始化component[i] = i。查找操作query(u)可以用O(1)的时间给出一个结点u所属的集合，合并操作merge(A, B)则需要O(n)的时间来合并两个集合。merge(A, B)的实现如下，任意选择一个保留的集合名，比如选到A，对于另一个集合B中的所有元素i都令component[i] = A。 最后，基于kruskal算法的特点，我们存储一个图的方式将不会使用邻接表或者邻接矩阵，而是直接存储边，具体的数据结构如下所示，重载小于操作符的目的是为了方便对边进行排序。123456789101112struct Edge &#123; Edge(int vertex1 = 0, int vertex2 = 0, int weight = 0) &#123; this-&gt;vertex1 = vertex1; this-&gt;vertex2 = vertex2; this-&gt;weight = weight; &#125; int vertex1, vertex2, weight;&#125;;bool operator&lt;(const Edge&amp; e1, const Edge&amp; e2) &#123; return e1.weight &lt; e2.weight;&#125; 最后，kruskal算法的整个算法流程的伪代码实现如下所示：12345678910111213输入为n个结点m条边的图，每条边都带有一个权值w对所有边按照权值大小进行排序，排序结果为&#123;e1,e2,...,em&#125;初始化MergeQuery数据结构mq，结点数量为nminimalSpanningTree = &#123;&#125;;for i=1 to m, do A = mq.query(ei.u); B = mq.query(ei.v); if A != B mq.merge(A, B, ei); 将边ei加入minimalSpanningTree; endIfendForreturn minimalSpanningTree; 整个算法的C++实现如下，下面代码运行之后会输出一个连通图，该图为原图的最小生成树。同时还会输出最小生成树所有边的权值的和。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAX_VERTEX_NUM = 10;struct Edge &#123; Edge(int vertex1 = 0, int vertex2 = 0, int weight = 0) &#123; this-&gt;vertex1 = vertex1; this-&gt;vertex2 = vertex2; this-&gt;weight = weight; &#125; int vertex1, vertex2, weight;&#125;;bool operator&lt;(const Edge&amp; e1, const Edge&amp; e2) &#123; return e1.weight &lt; e2.weight;&#125;class MergeQuery &#123;public: MergeQuery(const int&amp; vertexNum): vertexNum(vertexNum) &#123; component = new int[vertexNum]; for (int i = 0; i &lt; vertexNum; ++i) &#123; component[i] = i; &#125; &#125; ~MergeQuery() &#123; if (component != NULL) delete [] component; &#125; int query(const int&amp; vertex) const &#123; return component[vertex]; &#125; void merge(int A, int B) &#123; for (int i = 0; i &lt; vertexNum; ++i) &#123; if (component[i] == B) component[i] = A; &#125; &#125;private: int vertexNum; int* component;&#125;;class Kruskal &#123;public: Kruskal(const int&amp; vertexNum, const int&amp; edgeNum) &#123; this-&gt;vertexNum = vertexNum; this-&gt;edgeNum = edgeNum; mq = new MergeQuery(vertexNum); edges = new Edge[edgeNum]; minimalSpanningTree = new int[vertexNum-1]; &#125; ~Kruskal() &#123; if (mq != NULL) delete mq; if (edges != NULL) delete [] edges; &#125; void getEdge() &#123; for (int i = 0; i &lt; edgeNum; ++i) &#123; cin &gt;&gt; edges[i].vertex1 &gt;&gt; edges[i].vertex2 &gt;&gt; edges[i].weight; &#125; &#125; void minimalSpanning() &#123; sort(edges, edges + edgeNum); int treeEdgeNum = 0; for (int i = 0; i &lt; edgeNum; ++i) &#123; int A = mq-&gt;query(edges[i].vertex1); int B = mq-&gt;query(edges[i].vertex2); if (A != B) &#123; mq-&gt;merge(A, B); minimalSpanningTree[treeEdgeNum++] = i; &#125; &#125; &#125; void getTree() &#123; int weightSum = 0; cout &lt;&lt; \"最小生成树: (v1, v2, weight)\" &lt;&lt; endl; for (int i = 0; i &lt; vertexNum-1; ++i) &#123; weightSum += edges[minimalSpanningTree[i]].weight; cout &lt;&lt; edges[minimalSpanningTree[i]].vertex1 &lt;&lt; ' ' &lt;&lt; edges[minimalSpanningTree[i]].vertex2 &lt;&lt; ' ' &lt;&lt; edges[minimalSpanningTree[i]].weight &lt;&lt; endl; &#125; cout &lt;&lt; \"最小生成树边权值总和为: \" &lt;&lt; weightSum &lt;&lt; endl; &#125;private: int vertexNum; int edgeNum; int* minimalSpanningTree; MergeQuery* mq; Edge* edges;&#125;;int main() &#123; int vertexNum, edgeNum; cin &gt;&gt; vertexNum &gt;&gt; edgeNum; if (vertexNum &gt; MAX_VERTEX_NUM) &#123; cout &lt;&lt; \"结点数量过多\" &lt;&lt; endl; return -1; &#125; Kruskal k(vertexNum, edgeNum); k.getEdge(); // 输入图的所有边 k.minimalSpanning(); // kruskal最小生成树算法 k.getTree(); // 输出结果 return 0;&#125; Kruskal算法的其他应用—聚类最大间隔聚类：给定集合U = {p1, p2, ..., pn}，对于每对个体pi和pj，d(pi, pj)表示两个个体之间的距离，规定d(pi, pi)=0，d(pi, pj) &gt; 0(i != j)，并且d(pi, pj) = d(pj, pi)。给定参数k(k &lt;= n)，将U中的个体划分称为k组，则一个U的k聚类是把U分成k个非空集合C1, C2, ..., Ck的划分。我们希望每个聚类内部的点都尽可能地聚集，密集程度尽可能高，而位于两个不同聚类中的点尽可能地相互远离，寻找具有最大可能间隔的k聚类。在此，我们定义一个k聚类的间隔是处在两个不同聚类中的任何一对点之间的距离的最小值，简单点说就是k个聚类里面任意两个聚类之间的距离的最小值，我们希望这个最小值是所有可能的划分中最大的，这样，k个聚类就能最大程度地远离彼此。 最大间隔聚类问题可以使用kruskal算法来解决。把集合U中的个体看成结点，个体之间的距离看成边，在集合U上生成一个具有k个连通分支的图，这k个连通分支就是k个聚类。在生成图的过程中都将邻近点尽可能地一起带入同一个聚类中。通过对前面kruskal算法的理解我们可以知道，算法开始会初始化n个连通分支，然后每次加入一条边就相当于合并两个连通分支，知道最后剩下一个连通分支时就是最小生成树了。那，我们把终止条件修改一下，在使用Kruskal最小生成树算法时，一旦得到k个连通分支就停止算法，由于Kruskal算法每次加入新边时都是考虑权值最小的边，因此，当得到K个连通分支时，还未加入的k-1条边中其实就是最小生成树中距离最大的k-1条边，因此，当去掉这最长的k-1条边时得到的这k个聚类的间隔也是最大的。若图有n个结点，那么最小生成树有n-1边，要在加入最小生成树的最后k-1边时结束算法，那么最后得到的k个连通分支一共有n-k条边，也就是算法在加入n-k条边之后即可停止了。最后算法的伪代码如下所示：123456789101112131415输入n个结点m条边的图，每条边都带有一个权值w对所有边按照权值大小进行排序，排序结果为&#123;e1,e2,...,em&#125;初始化MergeQuery数据结构mq，结点数量为nKCluster = &#123;&#125;;edgeNum = 0;for i=1 to m &amp;&amp; edgeNum != n-k, do A = mq.query(ei.u); B = mq.query(ei.v); if A != B mq.merge(A, B, ei); 将边ei加入KCluster; edgeNum = edgeNum + 1; endIfendForreturn KCluster; 可以回顾上面的kruskal算法流程图，假如我们要聚出3个类，那么在进行到(d)这一步即可停止算法了，此时的3个连通分支就是3个最大间隔聚类，{v1, v3}，{v2, v5}，{v4, v6}。 上述伪代码的C++实现如下，下面代码运行之后输出结果为一个包含k个连通分支的图，每个连通分支代表一个聚类。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAX_VERTEX_NUM = 10;struct Edge &#123; Edge(int vertex1 = 0, int vertex2 = 0, int weight = 0) &#123; this-&gt;vertex1 = vertex1; this-&gt;vertex2 = vertex2; this-&gt;weight = weight; &#125; int vertex1, vertex2, weight;&#125;;bool operator&lt;(const Edge&amp; e1, const Edge&amp; e2) &#123; return e1.weight &lt; e2.weight;&#125;class MergeQuery &#123;public: MergeQuery(const int&amp; vertexNum): vertexNum(vertexNum) &#123; component = new int[vertexNum]; for (int i = 0; i &lt; vertexNum; ++i) &#123; component[i] = i; &#125; &#125; ~MergeQuery() &#123; if (component != NULL) delete [] component; &#125; int query(const int&amp; vertex) const &#123; return component[vertex]; &#125; void merge(int A, int B) &#123; for (int i = 0; i &lt; vertexNum; ++i) &#123; if (component[i] == B) component[i] = A; &#125; &#125;private: int vertexNum; int* component;&#125;;class Kruskal &#123;public: Kruskal(const int&amp; vertexNum, const int&amp; edgeNum, const int&amp; KCluster) &#123; this-&gt;vertexNum = vertexNum; this-&gt;edgeNum = edgeNum; this-&gt;KCluster = KCluster; mq = new MergeQuery(vertexNum); edges = new Edge[edgeNum]; minimalSpanningTree = new int[vertexNum-KCluster]; &#125; ~Kruskal() &#123; if (mq != NULL) delete mq; if (edges != NULL) delete [] edges; &#125; void getEdge() &#123; for (int i = 0; i &lt; edgeNum; ++i) &#123; cin &gt;&gt; edges[i].vertex1 &gt;&gt; edges[i].vertex2 &gt;&gt; edges[i].weight; &#125; &#125; void minimalSpanning() &#123; sort(edges, edges + edgeNum); int treeEdgeNum = 0; for (int i = 0; i &lt; edgeNum &amp;&amp; treeEdgeNum &lt; vertexNum-KCluster; ++i) &#123; int A = mq-&gt;query(edges[i].vertex1); int B = mq-&gt;query(edges[i].vertex2); if (A != B) &#123; mq-&gt;merge(A, B); minimalSpanningTree[treeEdgeNum++] = i; &#125; &#125; &#125; void getTree() &#123; int weightSum = 0; cout &lt;&lt; \"K聚类-结果图: (v1, v2, weight)\" &lt;&lt; endl; for (int i = 0; i &lt; vertexNum-KCluster; ++i) &#123; cout &lt;&lt; edges[minimalSpanningTree[i]].vertex1 &lt;&lt; ' ' &lt;&lt; edges[minimalSpanningTree[i]].vertex2 &lt;&lt; ' ' &lt;&lt; edges[minimalSpanningTree[i]].weight &lt;&lt; endl; &#125; &#125;private: int vertexNum; int edgeNum; int KCluster; int* minimalSpanningTree; MergeQuery* mq; Edge* edges;&#125;;int main() &#123; int vertexNum, edgeNum, KCluster; cin &gt;&gt; vertexNum &gt;&gt; edgeNum &gt;&gt; KCluster; if (vertexNum &gt; MAX_VERTEX_NUM) &#123; cout &lt;&lt; \"结点数量过多\" &lt;&lt; endl; return -1; &#125; if (KCluster &gt; vertexNum) &#123; cout &lt;&lt; \"聚类数量过大，超过结点数量\" &lt;&lt; endl; return -1; &#125; Kruskal k(vertexNum, edgeNum, KCluster); k.getEdge(); // 输入边 k.minimalSpanning(); // kruskal最小生成树算法 k.getTree(); // 输出结果 return 0;&#125;","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/数据结构与算法/"}]},{"title":"JavaScript-OOP常见模式总结（二）","slug":"JavaScript-OOP常见模式总结（二）","date":"2016-08-12T04:12:00.000Z","updated":"2017-11-10T12:11:48.182Z","comments":true,"path":"2016/08/12/JavaScript-OOP常见模式总结（二）/","link":"","permalink":"http://yoursite.com/2016/08/12/JavaScript-OOP常见模式总结（二）/","excerpt":"","text":"前言：之前我总结了JavaScript OOP常见的几种模式，今天继续把剩下的几种模式整理总结一遍。这几种模式相对于之前的工厂模式，构造函数模式等基础模式来说算是进阶版，有兴趣可以先看之前那篇博文熟悉一下几种基础的OOP模式，《JavaScript OOP常见模式总结》一、创建对象模式1. 动态原型模式该模式将所有信息都封装在构造函数中，可以在构造函数中初始化原型，并且保持了同时使用构造函数和原型的优点。在执行构造函数时，会通过检验某个应该存在的方法是否有效再决定是否需要初始化原型对象。以下面代码为例，所有信息都封装在了构造函数中，并且，为了避免多次初始化原型对象，使用了if条件语句来判断getProperty()方法是否存在。所以，仅在第一次调用构造函数时会初始化原型对象，创建obj1时初始化了原型对象，后面创建obj2对象时就仅执行添加属性部分的代码。这种模式的好处就是可以把属性和方法的定义都全部写到一起(都封装在构造函数中)，不用独立去写构造函数和原型。本质上和组合模式没有什么区别。123456789101112131415function MyObject(property) &#123; // 添加属性 this.property = property; // 添加方法 if (typeof this.getProperty != \"function\") &#123; MyObject.prototype.getProperty = function() &#123; return this.property; &#125;; &#125;&#125;var obj1 = new MyObject('xxxx');var obj2 = new MyObject('yyyy');console.log(obj1.getProperty()); // 输出\"xxxx\"console.log(obj2.getProperty()); // 输出\"yyyy\" 2. 寄生构造函数模式这种模式的基本思想是创建一个函数用于封装创建对象的代码，然后返回新创建的对象。表面上看起来跟工厂模式没什么区别，就只是在创建对象时使用了new操作符。寄生模式返回得到对象跟构造函数或构造函数原型之间没有任何关系，工厂模式存在的弊病在这种模式下也存在。1234567891011function MyObject(property) &#123; var o = new Object(); o.property = property; o.getProperty = function() &#123; return this.property; &#125;; return o;&#125;var obj = new MyObject('xxxx'); // 使用new操作符创建对象，工厂模式则是直接调用工厂函数console.log(obj.getProperty()); // 输出\"xxxx\" 3. 稳妥构造函数模式首先介绍一个概念，稳妥对象(durable object)，没有公共属性，其方法也不引用this对象，这种对象就称为稳妥对象。稳妥构造函数模式与寄生构造函数模式相似，不同的是，创建对象的实例方法不引用this，不适用new操作符调用构造函数。以下面代码为例，构造函数中的方法都没有引用this对象，变量obj中保存的是一个稳妥对象，除了通过getProperty()和getPrivate()方法访问对象的属性之外，没有其他办法能够访问到property和private属性，这两个属性就相当于C++中类的私有成员变量一样。这种模式本质上是构建了闭包，让私有变量存在于对象上某个函数的闭包中，只有通过调用对象上特定的函数才能访问到它闭包中的变量。这样做的好处就是防止数据被其他程序改动，保证安全性。此模式适合在一些安全性要求较高的执行环境中使用。123456789101112131415161718function MyObject(property) &#123; var o = new Object(); // 定义参数之外的其他私有变量或方法 var private= \"yyyy\"; o.getProperty = function() &#123; return property; &#125;; o.getPrivate = function() &#123; return private; &#125;; return o;&#125;var obj = MyObject('xxxx');console.log(obj.getProperty()); // 输出\"xxxx\"console.log(obj.getPrivate()); // 输出\"yyyy\"console.log(obj.property); // undefinedconsole.log(obj.private); // undefined 二、继承模式1. 原型式继承这种模式的主要思想是借助原型来基于已有的对象创建新对象，同时不必因此创建自定义类型。以下面代码为例，inherit()函数内部创建了一个临时构造函数F，并且F的原型对象指向了传入inherit()的对象obj，表示F类型继承obj类型。这种模式本质上是做了一次浅复制，像下面代码一样，由于obj1被放置到obj2的原型对象的位置上，因此在修改obj2的property1属性时，obj1的属性也跟着变了。这种模式创建出来的新对象可以为其添加新的属性或方法，并且不影响原对象。所以，这种模式适合在构造相似对象，并且为新对象动态添加独有的属性方法时使用。ES5中，Object.create()方法就是实现了这种原型式继承。123456789101112131415161718function inherit(obj) &#123; function F() &#123;&#125; F.prototype = obj; return new F();&#125;var obj1 = &#123; property1 : 'xxxx', property2 : 'yyyy'&#125;;var obj2 = inherit(obj1);console.log(obj2.property1); // 输出\"xxxx\"console.log(obj2.property2); // 输出\"yyyy\"obj2.property1 = 'zzzz';console.log(obj1.property1); // 输出\"zzzz\"obj2.property3 = 'wwww';console.log(obj1.property3); // undefined 2. 寄生式继承寄生式继承的思路和寄生构造函数或工厂模式相似，创建一个用于封装继承过程的函数，在该函数中通过某种方式来增强对象实现继承。这种模式与前面的原型式继承一样，适合在不需要自定义类型和构造函数的情况下使用。这种模式也有缺点，在为对象添加函数时，会由于不能做到函数复用而降低效率。以下面代码为例，这种模式下看起来跟前面的原型式继承好像也很类似，不过，这里创建的每个继承对象都会定义func()方法，前面的原型式继承则没有。也就是说，原型式仅仅是继承了父类的属性方法，然后子类对象自己可以随意添加自己特有的属性方法，而寄生式继承则是继承了父类的属性方法之后还有把子类对象共同的属性方法也加上。123456789101112131415function inherit(obj) &#123; function F() &#123;&#125; F.prototype = obj; var o = new F(); o.func = function() &#123; console.log('23333'); &#125;; return o;&#125;var obj1 = &#123; property : 'xxxx'&#125;;var obj2 = inherit(obj1);obj2.func(); // 输出\"23333\" 3. 寄生组合式继承在介绍寄生组合式继承之前，我们先回顾一下组合继承。组合继承是JS中最常用的继承模式，但这种模式也存在着自己的问题，这个问题就是无论在什么情况下，都会调用两次父类的构造函数，一次是在创建子类型的时候，另一次是在子类型构造函数的内部。请看下面代码示例，两次调用父类的构造函数，显而易见的缺点就是损失效率，函数调用次数我们希望越少越好。再者，我们仔细观察可以发现，通过这两次调用，子类对象上继承了父类的属性superName，但，子类的原型对象上也存在父类的属性superName，这个属性也会被子类对象上的属性屏蔽，实际上我们希望原型对象只继承父类的函数方法，这就造成了定义多余的属性浪费资源。1234567891011121314151617181920function SuperType(superName) &#123; this.superName = superName;&#125;SuperType.prototype.saySuperName = function() &#123; console.log(this.superName);&#125;;function SubType(superName, subName) &#123; SuperType.call(this, superName); // 继承父类属性，调用SuperType() this.subName = subName;&#125;SubType.prototype = new SuperType(); // 继承父类方法，调用SuperType()SubType.prototype.constructor = SubType;SubType.prototype.saySubName = function() &#123; console.log(this.subName);&#125;;var obj = new SubType('heheheheh', '233333');obj.saySuperName(); // \"heheheheh\"obj.saySubName(); // \"233333\" 我们希望仅调用一次父类的构造函数，并且在子类的原型对象上不要定义多余的属性。为了克服组合继承的不足，寄生组合式继承是最好的选择。寄生组合式继承通过借用构造函数来继承属性，通过原型链的混合形式来继承方法，其思路就是：不必为了指定子类型的原型而调用父类的构造函数，而是将父类的原型拷贝一个副本给子类。本质上，就是使用拷贝的方式来继承父类的原型，然后就把结果指定给子类的原型。代码示例如下，inherit()函数的作用是复制父类的原型并指定给子类。寄生组合式继承的高效率体现在它只调用了一次父类的构造函数，并且避免了在子类的原型对象上创建多余的属性，并且，原型链依然保持不变，可以通过instanceof或isPrototypeOf()来判断类型。123456789101112131415161718192021222324252627function inherit(Super, Sub) &#123; // 拷贝父类原型 var prototype = Object(Super.prototype); // 将父类原型副本指定给子类 prototype.constructor = Sub; Sub.prototype = prototype;&#125;function SuperType(superName) &#123; this.superName = superName;&#125;SuperType.prototype.saySuperName = function() &#123; console.log(this.superName);&#125;;function SubType(superName, subName) &#123; SuperType.call(this, superName); // 继承父类属性，调用SuperType() this.subName = subName;&#125;inherit(SuperType, SubType); // 继承父类的原型对象SubType.prototype.saySubName = function() &#123; console.log(this.subName);&#125;;var obj = new SubType('heheheheh', '233333');obj.saySuperName(); // \"heheheheh\"obj.saySubName(); // \"233333\"","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"【贪心算法】区间调度问题总结","slug":"【贪心算法】区间调度问题总结","date":"2016-08-11T08:07:00.000Z","updated":"2017-11-10T12:04:13.456Z","comments":true,"path":"2016/08/11/【贪心算法】区间调度问题总结/","link":"","permalink":"http://yoursite.com/2016/08/11/【贪心算法】区间调度问题总结/","excerpt":"","text":"1. 单区间调度问题问题定义：存在单一资源，有一组以时间区间形式表示的资源请求reqs={req-1, req-2, ..., req-n}，第i个请求希望占用资源一段时间来完成某些任务，这段时间开始于begin(i)终止于end(i)。如果两个请求req-i和req-j在时间区间上没有重叠，则说这两个请求是相容的，求出这组请求的最大相容子集(最优子集)。举个例子：有一间多媒体课室，某一个周末有多个社团想要申请这间课室去举办社团活动，每个社团都有一个对应的申请时间段，比如周六上午8:00-10:00。求出这间课室在这个周末最多能满足几个社团的需求。 解决方案：贪心算法，优先选择最早结束的需求，确保资源尽可能早地被释放，把留下来满足其他需求的时间最大化。具体伪代码如下所示，算法结束后集合A中会保留所有相容请求，A的大小即是最大相容数量。12345678初始化R是所有需求的集合，A为空集对R中的需求Ri，根据结束时间从早到晚排序for Ri in R, do if Ri与A中的请求相容 A = A并Ri endIfendForreturn A 上述伪代码的C++实现如下，123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int MAX_SIZE = 100;struct Request &#123; int begin, end;&#125; req[MAX_SIZE];bool operator&lt;(const Request&amp; req1, const Request&amp; req2) &#123; return req1.end &lt; req2.end;&#125;int main() &#123; int requestNum; cin &gt;&gt; requestNum; if (requestNum &gt; MAX_SIZE) &#123; cout &lt;&lt; \"请求数量过多\" &lt;&lt; endl; return 0; &#125; for (int i = 0; i &lt; requestNum; ++i) &#123; cin &gt;&gt; req[i].begin &gt;&gt; req[i].end; &#125; sort(req, req + requestNum); vector&lt;Request&gt; rvec; rvec.push_back(req[0]); for (int i = 1; i &lt; requestNum; ++i) &#123; if (rvec[rvec.size() - 1].end &lt;= req[i].begin) &#123; rvec.push_back(req[i]); &#125; &#125; cout &lt;&lt; \"最大兼容量: \" &lt;&lt; rvec.size() &lt;&lt; endl; return 0;&#125; 2. 多区间调度问题问题定义：存在多个(或者无限多个)相同的资源，有一组以时间区间形式表示的资源请求reqs={req-1, req-2, ..., req-n}，第i个请求希望占用资源一段时间来完成某些任务，这段时间开始于begin(i)终止于end(i)。如果两个请求req-i和req-j在时间区间上没有重叠，则说这两个请求是相容的，用尽可能少的资源满足所有请求(求最优资源数量)。举个例子：有很多间课室，某个周末有多个社团需要申请课室办活动，每个社团都有一个对应的申请时间，求最少需要多少间课室才能够满足所有社团的需求(在这个问题之中时间重叠的社团需要安排在其他课室，即会使用到多个资源，需要考虑多个资源上的调度安排，故称为多区间调度)。 解决方案：贪心算法，将需求按照开始时间的早晚进行排序，然后开始为这些资源打标签，每个标签代表都一个资源，需求req-i被打上标签k表示该请求分配到的资源是k。遍历排序后的需求，如果一个需求与某个已分配资源上的其他安排不冲突，则把该需求也放进该资源的安排考虑中；如果冲突，那么应该要给此需求分配新的资源，已用资源数量加一。具体操作的伪代码如下所示。1234567891011121314151617181920对n个需求按照开始时间从早到晚进行排序假设排序后的需求记为&#123;R1, R2, ..., Rn&#125;初始化tagSize = 1;for i=1 to n, do: tags = &#123;1,2,...,tagSize&#125;; for j = 1 to i-1, do: if Rj与Ri时间区间重叠产生冲突: tags = tags - &#123;Rj的标签&#125;; endIf endFor if tags为空集: tagSize += 1; 将标签tagSize贴在Ri上 EndIf else: 在tags剩下的标签中随便挑一个贴给Ri endElseendFor此时每个请求上都贴有标签，每个标签对应其申请的资源编号，此时的tagSize就是至少需要的资源数量return tagSize; 上述伪代码的C++实现如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int MAX_SIZE = 100;struct Request &#123; int begin, end, tag;&#125; req[MAX_SIZE];bool operator&lt;(const Request&amp; req1, const Request&amp; req2) &#123; return req1.begin &lt; req2.begin;&#125;int main() &#123; int requestNum; cin &gt;&gt; requestNum; if (requestNum &gt; MAX_SIZE) &#123; cout &lt;&lt; \"请求数量过多\" &lt;&lt; endl; return 0; &#125; for (int i = 0; i &lt; requestNum; ++i) &#123; cin &gt;&gt; req[i].begin &gt;&gt; req[i].end; &#125; sort(req, req + requestNum); int tagSize = 1; req[0].tag = 0; bool tags[MAX_SIZE]; for (int i = 1; i &lt; requestNum; ++i) &#123; memset(tags, 1, sizeof(tags)); for (int j = 0; j &lt; i; ++j) &#123; if (req[j].end &gt; req[i].begin) &#123; tags[req[j].tag] = false; &#125; &#125; bool isTagsEmpty = true; int tag; for (int j = 0; j &lt; tagSize; ++j) &#123; if (tags[j]) &#123; isTagsEmpty = false; tag = j; break; &#125; &#125; if (isTagsEmpty) &#123; req[i].tag = tagSize; ++tagSize; &#125; else &#123; req[i].tag = tag; &#125; &#125; cout &lt;&lt; \"最小资源使用量: \" &lt;&lt; tagSize &lt;&lt; endl; return 0;&#125; 3. 最小延迟调度问题问题定义：存在单一资源和一组资源请求reqs={req-1, req-2, ..., req-n}，与前面两个问题不同，这里的资源从时刻0开始有效(开始接受申请，开始可以被使用)，每个请求req-i都有一个截止时间ddl(i)，每个请求都要占用资源一段连续的时间来完成任务，占用时间为time(i)。每个请求都希望自己能在ddl之前完成任务，不同需求必须被分在不重叠的时间区间(单一资源，同一时刻只能满足一个请求)。假设我们计划满足每个请求，但是允许某些请求延迟(即某个请求在ddl之后完成，延误工期)，确定一种合理的安排，使得所有请求的延期时间中的最大值，是所有可能的时间安排情况中最小的。从时刻0开始，为每个请求req-i分配一个长度time(i)的时间区间，把区间标记为[begin(i), end(i)]，其中end(i) = begin(i) + time(i)。如果end(i) &gt; ddl(i)，则请求req-i被延迟，延迟时间为delay(i) = end(i) - ddl(i)；否则delay(i) = 0。合理安排需求，使得maxDelay = max{delay(1), delay(2), ..., delay(n)}是所有可能的安排中最小的。 解决方案：贪心算法，按照截止时间ddl排序，越早截止的任务越早完成。该算法是一个没有空闲的最优调度，即从时刻0开始都有在处理请求，直到最后一个请求执行完释放资源之后才空闲。伪代码如下所示。1234567891011121314将需求按照截止时间进行排序假设排序后的截止时间为ddl[1]&lt;=...&lt;=ddl[n]start = 0;maxDelay = 0;for i = 1 to n, do: begin[i] = start; end[i] = start + time[i]; start = end[i] + time[i]; if maxDelay &lt; end[i] - ddl[i]: L = end[i] - ddl[i]; endIfendFor则每个任务安排的时间区间为[begin[i], end[i]]，所有任务中最大的延迟为maxDelay，maxDelay为所有可能的任务安排中最小的延迟return maxDelay; 上述代码的C++实现如下：1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAX_SIZE = 100;struct Request &#123; int time, ddl; int begin, end;&#125; req[MAX_SIZE];bool operator&lt;(const Request&amp; req1, const Request&amp; req2) &#123; return req1.ddl &lt; req2.ddl;&#125;int main() &#123; int requestNum; cin &gt;&gt; requestNum; if (requestNum &gt; MAX_SIZE) &#123; cout &lt;&lt; \"请求数量过多\" &lt;&lt; endl; return 0; &#125; for (int i = 0; i &lt; requestNum; ++i) &#123; cin &gt;&gt; req[i].time &gt;&gt; req[i].ddl; &#125; sort(req, req + requestNum); int start = 0, maxDelay = 0; for (int i = 0; i &lt; requestNum; ++i) &#123; req[i].begin = start; req[i].end = start + req[i].time; start += req[i].time; if (maxDelay &lt; req[i].end - req[i].ddl) &#123; maxDelay = req[i].end - req[i].ddl; &#125; &#125; cout &lt;&lt; \"最小的最大延迟: \" &lt;&lt; maxDelay &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/数据结构与算法/"}]},{"title":"JavaScript-OOP常见模式总结","slug":"JavaScript-OOP常见模式总结","date":"2016-08-11T04:00:00.000Z","updated":"2017-11-10T11:58:01.194Z","comments":true,"path":"2016/08/11/JavaScript-OOP常见模式总结/","link":"","permalink":"http://yoursite.com/2016/08/11/JavaScript-OOP常见模式总结/","excerpt":"","text":"一、创建对象模式1. 工厂模式使用一个函数作为工场函数，封装以特定接口创建对象的细节，每次调用工场函数都能生产一个对象。工厂模式的缺点是无法解决对象识别问题(即知道一个对象的类型)，而且每次调用函数，都会创建一个带有属性和方法的对象，也就是说，一些共同的方法会被多次创建，即每个方法都会在每个对象上重新创建一遍。以下面的代码为例，obj1和obj2都分别有各自的setProperty方法，也就是说setProperty方法创建了两次，浪费资源空间。12345678910111213function createObj(property1, property2) &#123; var o = new Object(); o.property1 = property1; o.property2 = property2; o.setProperty = function(val1, vla2) &#123; this.property1 = val1; this.property2 = val2; &#125;; return o;&#125;var obj1 = createObj('xxxx', 'xxxx');var obj2 = createObj('yyyy', 'yyyy'); 2. 构造函数模式通过创建自定义的构造函数从而定义自定义对象类型的属性和方法。构造函数内没有显式地创建对象，直接将属性和方法赋值给this对象，也没有return语句。在使用new操作符创建对象的时候，会经历以下过程：创建一个新对象，把构造函数的作用域赋值给新对象(即this指向新对象)，执行构造函数中的代码给对象添加属性方法，最后返回新对象的引用，可以结合下面代码中obj3的创建过程理解整个过程。使用这种模式创建的对象，可以用instanceof操作符来判定对象类型，这是相对于工厂模式的优势。但是，这种模式也会出现相同的方法多次创建的情况，像下面的代码一样，setProperty方法被创建了3次，obj1、obj2和obj3都有各自的一个setProperty方法。12345678910111213function MyObject(property1, property2) &#123; this.property1 = property1; this.property2 = property2; this.setProperty = function(val1, val2) &#123; this.property1 = val1; this.property2 = val2; &#125;;&#125;var obj1 = new MyObject('xxxx', 'xxxx');var obj2 = new MyObject('yyyy', 'yyyy');var obj3 = new Object();MyObject.call(obj3, 'zzzz', 'zzzz'); 3. 原型模式我们创建的每个函数都有一个prototype(原型)属性，该属性是一个指针，指向一个对象。创建自定义一个新函数之后，JavaScript会根据一组特定规则为该函数创建一个prototype属性，指向函数的原型对象。原型对象有一个constructor属性，指向prototype属性所属的函数指针。例如：MyObject.prototype指向MyObject的原型对象，MyObject.prototype.constructor指回MyObject。原型模式的代码示例如下所示。通过原型模式定义的属性和方法将被所有对象实例共享，以下面代码为例，obj1和obj2的property属性是共享的，没有各自创建自己的property，当原型对象上property属性值修改之后obj1和obj2访问到的值也跟着变了。代码执行读取某个对象的属性时，会执行一次搜索，首先从对象实例本身开始，如果找到该属性则返回该属性的值，如果找不到，则通过prototype指针继续在原型对象上进行搜索。基于这种搜索机制，所有创建在原型对象上的属性都是被共享的，因为只要在对象实例上找不到就会到原型对象上找，而对象实例有多个，它们的prototype指针指向的原型对象却都是同一个。当然，只要在对象实例上继续创建属性，该属性与原型对象的属性同名，则可以屏蔽原型对象上的属性。原型模式的缺点是所有属性和方法都共享，这点对于函数非常合适(类似于c++中类的成员函数)，当对于某些属性来说很不合适(类似于c++中类的非静态成员变量)。12345678910111213141516function MyObject() &#123;&#125;MyObject.prototype.property = 'xxxx';MyObject.prototype.getProperty = function () &#123; return this.property;&#125;;MyObject.prototype.setProperty = function(val) &#123; this.property = val&#125;;var obj1 = new MyObject();var obj2 = new MyObject();console.log(obj1.getProperty()); // 输出\"xxxx\"console.log(obj2.getProperty()); // 输出\"xxxx\"MyObject.prototype.property = 'yyyy';console.log(obj1.getProperty()); // 输出\"yyyy\"console.log(obj2.getProperty()); // 输出\"yyyy\" 4. 组合模式（构造函数模式+原型模式）结合构造函数模式和原型模式的优点，克服它们的缺点。这种模式下，在构造函数中定义对象各自的私有属性，而共享方法则在原型对象上定义。这样，每个对象实例都有各自的属性变量，而共享原型对象上的函数方法，很好地模拟了类的公有函数和私有变量。这种模式是JavaScript中使用最广泛的一种创建自定义类型的模式。以下面代码为例，obj1和obj2有各自的property属性变量，当修改原型对象上的property属性值时对obj1和obj2没有影响，当obj1的property属性值改变时对obj2也没有影响。123456789101112131415161718function MyObject(property) &#123; this.property = property;&#125;MyObject.prototype.getProperty = function() &#123; return this.property;&#125;;var obj1 = new MyObject('xxxx');var obj2 = new MyObject('yyyy');console.log(obj1.getProperty()); // 输出\"xxxx\"console.log(obj2.getProperty()); // 输出\"yyyy\"MyObject.prototype.property = 'zzzz';console.log(obj1.getProperty()); // 输出\"xxxx\"console.log(obj2.getProperty()); // 输出\"yyyy\"obj1.property = 'zzzz';console.log(obj1.getProperty()); // 输出\"zzzz\"console.log(obj2.getProperty()); // 输出\"yyyy\" 二、继承模式1. 原型链模式原型链是实现继承的主要方法，利用原型链让一个引用类型继承另一个引用类型的属性和方法。每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。当我们让原型对象等于另一个类型的实例，此时原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型有事另一个类型的实例，那么上述关系依然成立，如此层层递进就构成了实例与原型的链条，这就是原型链的基本概念。实现的本质是重写原型对象，替换为一个新类型的实例。以下面代码为例，SubType的原型对象变成SuperType的一个实例对象之后，为了叙述方便，我们将此对象称为sobj，也就是说现在SubType的原型对象是sobj，sobj是SuperType的一个实例对象。当我调用getSuperName()方法时候，首先在obj对象上进行搜索，找不到getSuperName方法，接着在obj的原型对象sobj上寻找，也是没找到，而sobj本身也有prototype指针指向SuperType的原型对象，所以会继续在这个原型对象上找，找到了getSuperName方法，搜索停止，执行getSuperName方法。通过实现原型链，本质上扩展了原型搜索机制。原型链实现继承也会存在不少缺点，首先，父类型作为子类型的原型对象，我们前面说过，原型对象上的属性和方法会被所有对象共享，于是子类型会共享所有父类型的属性和方法，这就导致了父类型的属性无法当做私有属性来使用。其次，在创建子类型的实例时，无法向父类型的构造函数传参。基于这两点，在实际应用中很少单独使用原型链。123456789101112131415161718function SuperType() &#123; this.superName = 'SuperType';&#125;SuperType.prototype.getSuperName = function() &#123; return this.superName;&#125;;function SubType() &#123; this.subName = 'SubType';&#125;SubType.prototype = new SuperType(); // 改变子类的prototype指针指向，实现继承SubType.prototype.getSubName = function() &#123; return this.subName;&#125;;var obj = new SubType();console.log(obj.getSuperName()); // 输出\"SuperType\"console.log(obj.getSubName()); // 输出\"SubType\" 2. 借用构造函数模式借用构造函数模式的基本思想相当简单，即在子类型构造函数的内部调用超类型的构造函数。通过使用apply()和call()方法在新创建的对象上执行构造函数，从而将父类构造函数执行作用域切换到子类，为子类定义一系列父类的属性方法，如下所示，在创建SubType的实例对象时，在该对象上调用了父类的构造函数，因此会执行父类构造函数中的this.superName = &#39;SuperType&#39;这句代码，此时的this指向的时子类的实例对象obj，所以obj上就有了superName属性。123456789101112function SuperType() &#123; this.superName = 'SuperType';&#125;function SubType() &#123; SuperType.call(this); // 在子类对象上调用父类构造函数 this.subName = 'SubType';&#125;var obj = new SubType();console.log(obj.superName); // 输出\"SuperType\"console.log(obj.subName); // 输出\"SubType\" 借用构造函数有一个很大的优势，可以在子类型中向超类型构造函数传参。但此技术也存在缺点，即所有超类型的函数方法必须在构造函数中定义才能被子类继承，而在构造函数中定义函数方法，就会出现前面说的构造函数模式所遇到的问题，这些方法会被多次创建，即在每一个实例对象上都会被创建一遍。因此，借用构造函数模式也很少单独使用。 3. 组合继承模式组合继承也叫作伪经典继承，它将原型链和借用构造函数的技术组合起来，发挥二者的优势。使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例属性的继承，这样，既通过在原型上定义的方法实现了函数复用，又能保证每个实例都有自己的属性。组合继承模式避免了原型链和借用构造函数的缺陷，融合了他们的优点，是JavaScript中最常用的继承模式，而且，instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。1234567891011121314151617181920function SuperType(superName) &#123; this.superName = superName;&#125;SuperType.prototype.saySuperName = function() &#123; console.log(this.superName);&#125;;function SubType(superName, subName) &#123; SuperType.call(this, superName); // 使用借用构造函数模式继承父类属性 this.subName = subName;&#125;SubType.prototype = new SuperType(); // 使用原型链模式继承父类方法SubType.prototype.constructor = SubType; // 重置构造子SubType.prototype.saySubName = function() &#123; console.log(this.subName);&#125;;var obj = new SubType('heheheheh', '233333');obj.saySuperName(); // 输出\"heheheheh\"obj.saySubName(); // 输出\"233333\"","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"medrank算法配合B+树实现一个简单预测模型","slug":"medrank算法配合B-树实现一个简单预测模型","date":"2016-07-27T03:04:00.000Z","updated":"2017-11-10T11:44:42.963Z","comments":true,"path":"2016/07/27/medrank算法配合B-树实现一个简单预测模型/","link":"","permalink":"http://yoursite.com/2016/07/27/medrank算法配合B-树实现一个简单预测模型/","excerpt":"","text":"A model for entity predictingdemo的github地址https://github.com/hongchh/predict-entity，欢迎点赞或指正不足之处注1: 如有问题请联系hongchh_sysu@qq.com注2: 本文仅供参考交流，请勿抄袭一、前言实体(entity)是描述一些数据对象区别于其他数据对象的内容，可以理解为一种类型、标签。在实际应用场景中，实体可以是商标、品牌、公司名称等等，类似于搜索引擎中的关键字，但也有所区别。实体过滤(entity filtering)指的是，在某些带有实体标记的数据中，过滤出与查询实体相关的数据。比如：有大量的微博博文数据，将博文内容按照“BMW”、“KFC”、“剑桥大学”、“哈佛大学”等不同实体进行了分类，接着给定一个查询实体“BMW”，则从数据中过滤出与BMW相关的数据出来。实体过滤可以用于调查监控某些品牌或者机构的网络知名度和影响力，为企业战略调整提供参考，及时调整发展方向等等。以上便是我们小组所选择的论文【1】中所做的事情，作者提出一种机器学习的算法，该算法可应用于实体过滤，数据输入之后通过该算法的特殊筛选方式再配合人工打上实体标签，可以快速得到一个带有不同实体标签的数据集。 从本质上来看，实体过滤是一个实体到数据的过程，通俗一点讲就是你给我一个实体，我给你一堆跟实体相关的数据供你去做其他分析。论文【1】提出的模型会产生一个带有不同实体标签的数据集，将此数据集仅用于作实体过滤未免有点浪费资源。于是我们小组提出的改进方案是对此模型做一个功能上的改进，增加一个数据到实体的过程，即你给我数据，我来预测该数据可能与哪些实体相关。我们把这个过程称为实体推断，或者实体预测。我们也考虑了增加这个从数据到实体的过程是否有现实意义，最终我们一致认为，增加从数据到实体这个过程是有现实意义的。从小的方面讲，我们可以通过监测社交网络上的某个用户的数据，再将此数据经过我们的模型计算得到其相关的实体，我们统计这些实体之后便可知晓这个用户关注的事物，从而可用于为兴趣分析、爱好推荐等系统提供参考。从大的方面讲，我们可以检测名人机构的社交网络数据来监测他们的关注动向。 最后，从实体到数据和从数据到实体这两个过程可能比较难理解清楚，我们打算再给出一个例子用于简要说明实体过滤和实体推断的区别，便于您更进一步了解我们论文所做的事情，该例子也会在后面的实验中被用于检验模型的正确性。例子如下：有红色、黄色、绿色、蓝色、紫色5种颜色大类。拿红色来说，红色下面可以包含品红、朱红、粉红、浅红、猩红等等很多种红，这些颜色的差别就是红的深浅程度不一样，更具体一点说就是RGB颜色值不一样，但他们给人的直观视觉感受就是红色。因此，我们把这种广泛意义上的颜色分类(红色、黄色、绿色等)称为颜色实体，具体的RGB颜色值称为颜色数据，例如“红色”称为颜色实体，“粉红-rgb(255,192,203)”称为颜色数据。实体过滤做的事情就是当查询实体为“红色”时，返回rgb(255,192,203)、rgb(220,20,60)等直观上看起来是红色的具体的颜色数据。而实体推断做的事情就是给定具体的颜色数据，例如rgb(255,192,203)，返回该数据所属的颜色实体“红色”。 二、问题定义我们要解决的是实体推断的问题，该问题可以描述为：给定一个已知实体标签的大的数据集和一个未知实体标签的数据集，将前者称为训练集，后者称为查询集。将训练集作为输入经过特定算法处理之后得到一个模型，该模型可以接受来自查询集的输入，并对查询集中的每个数据对象都预测其所属的实体标签。 算法的输入为一个训练集(ds)和一个查询集(qs)，训练集的大小为n，查询集合的大小为qn。 训练集是一个带有实体标签的数据集，包含多个(大量)数据对象，每个数据对象都用特征向量的形式表示，向量的维度为d，每一个数据对象的格式如下: type dimVal-1 dimVal-2 … dimVal-d 其中，type为该数据对象所属的实体类型(实体取值范围有多个，{e1, e2, e3, e4, e5, …, ek})，dimVal为数据对象的特征向量每个维度上的值。 查询集是一个普通的数据集，该数据集包含多个数据对象，每一个数据对象都用特征向量的形式表示，向量的维度也是d，并且这些数据对象是未知实体的，即他们所属的实体未知。每一个数据对象格式与训练集一样。 由于数据量较大，算法的两个输入均采用文件输入，在使用算法的过程中需要提供训练集的大小n、训练集的数据文件路径ds、查询集的大小qn、查询集的数据文件路径qs、特征向量的维度大小d这5个参数。 算法的输出为预测的结果。对于查询集中的每一个数据对象q[i]，预测其可能属于的实体e，将e输出到文件保存。 三、算法描述前置知识：空间中向量之间的距离可以使用欧氏距离来衡量，向量v1=(x1, x2, …, xn)和向量v2=(y1, y2, …, yn)之间的欧氏距离为dist=|v1-v2|=sqrt(sum((xi-yi)^2))(i=1, 2, …, n)。本算法默认数据对象都采用特征向量的形式描述，对象之间的距离采用欧氏距离描述。 算法的总体思路是从训练集中选出跟查询的数据对象距离最近的N个点，通过计算这N个点所属实体出现的次数，将出现次数最多的实体作为查询的数据对象的预测实体。最简单的办法就是暴力查找，对每一个查询对象，遍历训练集的对象并计算与查询对象的距离，排序之后再取出距离最短的前N个点即可。基于数据量庞大，暴力算法会十分耗费时间和计算性能，是下下之策。我们采取的算法是medrank算法。 medrank算法是一种高效的查询大致最近邻点(ANN)的算法，通过选取合理的参数配置能够让其找到真正最近邻点。论文【2】中提出的medrank算法是一种查询一个邻近点的算法，我们对算法进行了改造，使得它能够找到N个邻近点。改造后的算法大致步骤如下(medrank算法的流程在论文【2】中已有详细介绍，篇幅较长，这里不再重复描述，如想要深入理解medrank算法请参考论文【2】，下面只展示我们改进后的medrank算法): 在一个d维的向量空间，按照正态分布的规律随机取出m条直线[L1, L1, …, Lm]，每条直线的单位向量为[a1, a2, …, am]。预处理的时候将训练集的向量投影到这m条直线上面去，即每条直线上会有n个投影值。用下面这种形式描述第i条直线上训练集的投影值[vi-1, vi-2, …, vi-j, …, vi-n]，i=1, 2, 3, …, m，j=1, 2, 3, …, n，i表示第几根直线，vi-j表示训练集中第j个对象在第i条直线上的投影。接下来，m条直线将扮演m个投票者的角色。给定一个查询向量，我们将查询向量也投影到m条直线上去得到投影值[q1, q2, …, qm]。对于每一根直线Li，根据训练集在这条直线上的投影值vi-j与查询点在这条直线上的投影值qi的距离大小来进行投票。投票的规则如下，假设第i条直线上训练集的投影值为[vi-1, vi-2, …, vi-n]，查询点的投影值为qi，从第i条直线上训练集的投影值中找出与qi的距离最近的两个投影值vi-hi和vi-li使得vi-hi &lt;= qi &lt;= vi-li，从这两个值开始，每次迭代都投给距离qi最近的点一票，不断向两边展开。以此类推，每根直线都是如此不断循环迭代下去，直到有N个点的票数超过投票者数量的一半，即m/2，则结束算法。这些票数超过一半的点就是我们想要的N个最近邻点。算法的伪代码如下所示，其中MINFREQ是论文【2】里为medrank算法设定的一个参数用于限定算法的结束条件，我们设置它为0.5，代表有N个点票数超过投票者的一半(0.5)就停止算法。向量的投影可以简单由需要投影的向量v跟投影直线的单位向量a作一个向量内积来完成，即投影值p = v * a。 12345678910111213141516171819202122232425&lt;medrank&gt;Input: 查询对象qOutput: 训练集中与q最近的N个邻近点for i = 1 to m do qi = ai * q 初始化两个指针hi和li使得vi-hi &lt;= qi &lt;= vi-li且hi和li指向的点离qi最近endS = 空集, f = [0, 0, ..., 0]while S中满足(f &gt; MINFREQ*m)的点的数量小于N do for i = 1 to m do if |vi-hi - qi| &lt; |vi-li - qi| then c = ci-hi; hi = hi - 1; else c = ci-li; li = li + 1; end if S不包含c then 把c加入S并初始化f[c] = 1; else f[c] = f[c] + 1; end endendreturn S中满足(f &gt; MINFREQ*m)的点; 我们知道，在信息检索和数据库领域中，处理的数据量都是非常庞大的，经常需要对数据建立索引。B+树索引的查询速度很快，访问的数据量很小，一般只需3-4次IO就能查询出所需的数据。为了更进一步提高程序的性能，我们使用B+树这种数据结构来优化查询效率。在medrank算法中，我们需要找出每条直线上投影值跟qi最近的两个点的指针li和hi，之后才是借由这两个指针向两侧扩展来进行投票。由于训练集数据量庞大，普通的线性查找或者二分查找比较耗时，而且当数据较大无法全部放进内存时，查找效率更是低下。因此，我们在这里可以利用B+树对每一条线上的投影值建立索引，在查找时利用索引进行查找，既能提高查找速度，又能降低数据访问量，一举两得。关于使用B+树索引的伪代码如下所示。 1234567891011121314&lt;indexing&gt;Input: m条直线，每条直线上都有n个投影值Output: Nonefor i = 1 to m do 将第i条直线上的n个投影值排序; 使用B+树的bulk-loading方法对排序后的投影值建立索引; 将索引存储至磁盘文件;end&lt;finding&gt;Input: 查询点在第i根直线上的投影值qiOutput: 两个指针hi和li利用B+树的范围查找功能找出两个指针hi和li使得*hi &lt;= qi &lt;= *lireturn hi, li; 最后，我们将B+树和medrank算法结合起来之后得到的最终模型的伪代码如下所示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;preprocess&gt;Input: 训练集D的n个数据对象&#123;o1, o2, ..., on&#125;, 投影直线数量mOutput: None利用正态分布生成m个随机单位向量&#123;a1, a2, ..., am&#125;;for j = 1 to m do Lj = 空集endfor i = 1 to n do for j = 1 to m do ci-j = i; vi-j = aj * oi; Lj = Lj 并 (ci-j, vi-j); endendfor j = 1 to m do 将第j条直线上的n个投影值根据vi-j的大小从小到大进行排序; 使用B+树的bulk-loading方法对排序后的投影值建立索引; 将索引存储至磁盘文件;end&lt;medrank&gt;Input: 查询对象qOutput: 训练集中与q最近的N个邻近点for i = 1 to m do qi = ai * q 利用B+树的范围查找初始化两个指针hi和li使得vi-hi &lt;= qi &lt;= vi-li且hi和li指向的点离qi最近endS = 空集, f = [0, 0, ..., 0]while S中满足(f &gt; MINFREQ*m)的点的数量小于N do for i = 1 to m do if |vi-hi - qi| &lt; |vi-li - qi| then c = ci-hi; hi = hi - 1; else c = ci-li; li = li + 1; end if S不包含c then 把c加入S并初始化f[c] = 1; else f[c] = f[c] + 1; end endendreturn S中满足(f &gt; MINFREQ*m)的点;&lt;predict&gt;Input: 查询集Q的n个数据对象&#123;q1, q2, ..., qn&#125;Output: 每个查询对应的实体标签&#123;e1, e2, ..., en&#125;E = 空集for i = 1 to n do 调用medrank算法查找得到N个点points; mark = 空集 for p in points do if mark中包含p.entity then mark[p.entity] = mark[p.entity] + 1; else 将p.entity加入到mark并初始化mark[p.entity] = 1; end end 将mark中值最大的实体标签取出加入到集合E中;endreturn E; 算法的主要步骤如上面所示，下面我们将逐个步骤进行描述。 预处理部分，预处理主要是将训练集的n个数据对象投影到m条直线上，记录投影值和投影点，即第几个点在第几条直线上的投影值。m条直线的产生，并不需要去确定直线方程，由于在算法中只需要对向量进行投影，因此，我们只需要生成m条直线对应的m个单位向量供投影使用即可。m个单位向量的生成需要满足正太分布，这样做的原因是为了让medrank算法的查询效果更好，具体细节在论文【2】中也有进行解释我们就不在重复赘述。投影完成后我们会得到m条直线，每一条直线上都有n个投影值。对每一条直线上的投影值都建立B+树索引，一共会产生m个索引。将这些索引存入文件，用于为medrank算法提供范围查询。 medrank算法部分，这部分基本步骤都跟前面介绍medrank算法时候所说的一致，便不重复赘述。相比之前的改动就只是在初始化指针hi和li的地方采用B+索引进行查询。训练集的数据量很大，这一步改进将显著提高查询速度，为整个算法的时间效率带来极大收益。 预测部分，这部分完成的工作是对输入的数据进行实体推断，也是体现我们解决实体推断问题的主要思想的地方。前面我们说到，进行预测需要先找到N个邻近点，再统计这些点所对应的实体标签。具体做法就是，对于输入的数据对象，首先通过调用medrank算法得到N个最邻近点，接着做一个O(N)的循环去统计这些邻近点的实体标签出现的次数，选取出现次数最多的实体标签作为预测结果。 四、实验结果我们做了两个实验，第一个实验使用的训练集是从下面5张图中提取出来的每个像素点的RGB颜色值。每一张图片都是一个颜色大类，包含多种RGB颜色。查询集则是随机提取的1000个RGB颜色值。训练集和查询集的每一个颜色值都将使用一个3维的特征向量来描述，代表其RGB颜色值。在demo的/check/img文件夹下可以找到这5张图片。 第二个实验使用的数据集为Mnist的数据集，详情可参考数据集的介绍和下载网站http://yann.lecun.com/exdb/mnist/ 。包括一个训练集和一个测试集，其中，训练集有60000个数据对象，测试集有10000个数据对象，每个数据对象都是一个784维的特征向量，每个特征向量都带有一个label。由于数据量庞大，测试时间会比较长，我们只提取了测试集中前300个数据对象作为我们实验的查询集。在demo中我们给出了一个get_mnist_data.cpp文件，有兴趣者请自行去修改里面相关参数来提取Mnist的全部测试数据来进行10000个数据的检验(需要比较暴力算法，暴力算法做10000个查询的时间会很长请耐心等候)。 实验的评价标准是检查输出的结果是否正确，是否能够返回正确的实体标签。因此，我们需要一个已知实体标签的查询集作为检验，为了达到这个目的，我们在实验一中采取的做法是在训练集中随机抽取适量的数据出来充当查询集，由于训练集的每个数据对象都是已知实体标签的，我们可以得到一个已知实体标签的查询集。将查询集的实体标签保存起来，再跟实验的输出结果进行比较，计算正确率。实验二中的查询集中每个数据对象都已经带有Mnist官方打上的label，将此标签作为区分对象的实体标签即可。实验过程中，我们还将对比使用b+树配合medrank算法和使用暴力查找算法的查询结果和查询开销，进而探究我们论文所使用的模型的正确性和优越性。 我们先来看第一个实验。第一个实验，我们要做的就是对于查询集中的每一个像素点，预测其所属的颜色大类。我们把上面5张图片代表的5种颜色大类分别打上实体标签“1”，“2”，“3”，“4”，“5”。每一个从对应图片中提取出来的像素点都带有其对应的实体标签。例如从红色图片中提取出来的像素点都将带有实体标签“1”。查询集中的每一个点输入之后，输出结果为该点所属的实体标签。比如rgb(255,192,203)为粉红色，输入之后得到的输出应该为“1”。我们收集100个查询点对应的输出，并制作了一个HTML页面用于显示对应的实验结果。实验结果展示请看下面的展示图，从实验结果来看，100个查询点的查询结果都是正确的，每一个点都能得到正确的实体标签来标记其所属的颜色大类。通过HTML页面从肉眼上也可以直观地看到实验结果的正确性。我们进行了查询集大小分别为100、500、1000的实验，最后得到的实验结果如下表所示。 item\\size 100 500 1000 preprocess 1.178366 1.205243 1.144519 medrank(total) 0.219590 1.212721 2.284969 medrank(avg) 0.002196 0.002425 0.002285 bf(total) 0.918224 4.521340 8.779360 bf(avg) 0.009182 0.009043 0.008779 medrank prob 2.644600 2.737580 2.847660 hit ratio(m) 1.000000 1.000000 1.000000 hit ratio(b) 1.000000 1.000000 1.000000 统计项: prepreocess: 预处理时间，包括读取训练集数据，向量投影，建立b+树索引的时间(单位: 秒) medrank(total): medrank算法完成n个查询的总时间(单位: 秒) medrank(avg): medrank算法完成1个查询的平均时间(单位: 秒) bf(total): 暴力算法完成n个查询的总时间(单位: 秒) bf(avg): 暴力算法完成1个查询的平均时间(单位: 秒) hit ratio(m): 使用medrank算法查询之后预测实体的正确率 hit ratio(b): 使用暴力算法查询之后预测实体的正确率 medrank prob: medrank算法平均每棵B+树索引的数据访问量(单位: 页; 页大小: 1KB) 从实验结果来看，使用medrank算法或者简单的暴力查找算法都能达到预期的正确率，这说明所使用的算法是合理的可行的，能够正确预测出查询对象所属的实体。并且，两种算法的命中率都是一样的，也就是说，正确性不相上下。我们再来看其他指标。medrank算法的查询时间很少，不管是数据量多大，平均每一个查询的时间都维持在0.0022秒左右，而暴力查找算法的时间则是维持在0.009秒左右。由此可见，medrank平均每个查询的查询速度要比普通的暴力查找算法快4倍左右。可能平均到一个查询的时间差距不大，我们来看总的查询时间，数据量为100的时候，medrank算法的总的查询时间为0.219秒，暴力查找的时间为0.918秒。随着数据量上升，差距逐渐增大，数据量上升到1000的时候，medrank算法的总查询时间为2.285秒，而暴力算法却需要8.779秒。显然，medrank算法具备强大的时间高效性，随着查询量的增加，时间差距累积扩大十分明显。最后一个指标是medrank算法的探测页面数量，我们计算了medrank算法在查找时访问的数据页面数量，发现平均每棵B+树只需访问2.74页，而本实验中一棵B+树索引的总大小为448页，计算一下便可知道，medrank算法在查找时需要访问的数据量仅为0.61%。而暴力算法需要遍历训练集所有数据，数据访问量为100%，使用建立B+树索引的方法显著降低了数据访问量，这也是medrank算法能够快速完成查询的重要原因之一。 接下来，我们来看第二个实验。第一个实验很明显是一个面向低维度数据的实验，在实际应用中，像社交网络数据之类的特征向量维度通常都是很高的。因此，我们来进一步检验我们的模型在高维度向量空间中的适用性。实验步骤与实验一类似，不过查询集的数据量变为100、200、300。实验的结果如下面表所示 item\\size 100 200 300 preprocess 20.943636 20.975628 20.987209 medrank(total) 5.964900 12.662699 18.986900 medrank(avg) 0.059649 0.063313 0.063290 bf(total) 21.650469 44.148018 66.126366 bf(avg) 0.216505 0.220740 0.220421 medrank prob 105.908401 104.598846 105.550667 hit ratio(m) 0.950000 0.955000 0.926667 hit ratio(b) 0.960000 0.970000 0.973333 实验二的数据维度为784，可以看到，随着数据的维度增大，处理的时间跟随之变长，不过跟实验一有相同的规律。我们可以看到，medrank算法平均处理一个查询的时间为0.06秒左右，而暴力算法则是0.21秒左右，medrank算法比暴力算法快3.5倍(实验一是4，相差不大)。从总的查询时间来看，medrank算法在查询数据量为100时比暴力算法节省时间15.68秒左右，数据量上升到300时节省时间47.14秒左右。随着查询数据量增加，medrank算法带来的时间收益更加显著。medrank算法的平均每一棵B+树索引的页面访问量为105左右，实验二中B+树索引的大小为486页，数据访问量大概为21.6%。虽然相比实验一增加了不少，但还是明显少于暴力算法。最后我们来看一看命中率，medrank算法和暴力算法的命中率都挺高，在这个实验中虽然暴力算法的命中率更高一点点，但也差不了多少，而且预测存在误差也是合理的，用一点点误差换来性能上的大幅度提升，显然是收益远大于损失，而且能够达到92%~95%左右的命中率也是十分理想的。 最后，我们对比一下实验一跟实验二的数据访问量，仔细研究过论文【2】便可发现，medrank算法用来投影的m条直线，m的数值是自己合理确定的。在我们的的模型中，我们选择了100条直线来投影，主要目的是确保在高维度向量空间中的正确性(论文【2】中已指出增加投影线数量会增强medrank算法的查找效率)。增加投影线的数量会增加算法的时间开销，因此需要合理取舍选择恰当数量的投影线。经过测试之后我们觉得100根投影线既能确保正确率也能保证有较低的时间开销。显然，100根线，远远超过实验一的向量维度(3维)，这意味着很快就能投票产出合适的近邻点，因此实验一的数据访问量很低，在访问很少的数据量之后便能投票产生结果。而实验二的向量维度有784维，用100根投影线来投票需要循环更多次数，访问更多的数据页面。这也是为什么实验二比实验一的数据访问量高的原因之一。 五、总结我们实现了一个实体推断的模型，这个模型的主要思想很简单，只需要找寻合适数量的邻近点再统计出现次数最多的实体便可完成推断。该模型成立的前提条件是数据都可采用特征向量的形式描述并且存在一个已知实体标签的训练集。在整个实验过程中，我们做的大部分工作是在为这个简单的推断过程提高效率并且保持正确性。 通过整理实验结果，我们可以得出结论，通过统计邻近点的实体标签来进行实体推断的办法是可行的，该办法的推断结果正确率也很高。在我们的实验一中，正确率达到100%，当然，我们无法保证在任何应用场景下都能够有100%的正确性，就像实验二，但在实际应用中，推断本身也允许存在误差，只要误差在可接受的范围以内，从实验结果来看我们的模型的命中率还是很理想的。其次，b+树是在数据库和信息检索领域常用的数据结构，而medrank则是一种优秀的查询邻近点的算法。使用b+树配合medrank算法可以高效地完成工作，建立b+树索引的方式能够显著降低数据访问量，提高查询效率，使得查询速度非常快，数据访问量很小，从时间和空间上都节省了很多开销。 通过本次实践，我们提出了解决实体推断问题的一种可行的方案，并且使用b+树配合medrank算法优化了查询效率，最后，我们通过进行多个实验验证方案的可行性。我们学习到了面对一个问题如何提出一种可行的解决方案，如何优化方案，如何验证方案的可行性。在优化过程中，学会了如何选择算法和数据结构，选取medrank算法之后对medrank算法的改造，使得它能够查询N个近邻点，这一过程也让我们更深入地理解medrank算法，学会了如何从理解算法过渡到将其改造应用到实际的场景中。在验证模型对于低维度和高维度数据的适用性的过程中，我们学会了从多个方面验证结论的科学方法。最后，从训练集中提取部分数据得到一个可验证的查询集，这种验证方法是从论文【1】中学习到的，我们不仅收获多一种验证方式，也学会了从他人的论文中汲取优秀办法。 六、参考文献【1】Damiano Spina, Maria-Hendrike Peetz, Maarten de Rijk,《active learning for entity filtering》 【2】R. Fagin, R. Kumar, and D. Sivakumar, 《efficient similarity search and classification via rank aggregation》 七、附录实验环境: 操作系统: MacBook Pro OS X 10.11.5 处理器: 2.7 GHz Intel Core i5 内存: 16 GB 1867 MHz DDR3 运行代码: 请使用Makefile编译代码 使用下面示例给出的命令启动程序 运行demo之后可以根据数据集的entity预测查询集中每个数据对应的entity 实验二的数据文件较大无法上传，我将在网站http://yann.lecun.com/exdb/mnist/ 下载的Mnist训练集和测试集合的数据和标签文件，一共四个二进制文件放在data文件夹中，请进入data文件夹下编译执行get_mnist_data.cpp进行提取，提取完数据之后，请确认data文件夹下面是否有生成Mnist-d.txt和Mnist-q.txt两个文件，正确完成之后才可开始实验二 1234cd datag++ get_mnist_data.cpp -o get./getcd .. 实验一和实验二运行示例: 1234567make./predict -n 55344 -d 3 -qn 100 -ds ./data/color-d.txt -qs ./data/color-q.txt./predict -n 55344 -d 3 -qn 500 -ds ./data/color-d.txt -qs ./data/color-q.txt./predict -n 55344 -d 3 -qn 1000 -ds ./data/color-d.txt -qs ./data/color-q.txt./predict -n 60000 -d 784 -qn 100 -ds ./data/Mnist-d.txt -qs ./data/Mnist-q.txt./predict -n 60000 -d 784 -qn 200 -ds ./data/Mnist-d.txt -qs ./data/Mnist-q.txt./predict -n 60000 -d 784 -qn 300 -ds ./data/Mnist-d.txt -qs ./data/Mnist-q.txt 参数说明: -n: 数据集的大小 -d: 向量的维度 -qn: 查询集的大小 -ds: 数据集的文件路径 -qs: 查询集的文件路径 如果要改用其他数据集，请确保数据文件都为文本文件，并且满足以下格式: 每个文件中包含若干个对象，每个对象为一个d维的向量 type为该向量所属的entity，dimVal-n(n=1,2,…,d)分别为每个维度的值 数据集(-ds)每一行的格式为 type dimVal-1 dimVal-2 … dimVal-d 查询集(-qs)每一行的格式为 type dimVal-1 dimVal-2 … dimVal-d 实验一的部分实验结果图形化展示: 程序运行结束之后将工作目录切换到check文件夹下，编译convert.cpp并执行 1234cd checkg++ convert.cpp -o convert./convertcd .. convert运行结束之后，请确认在check文件夹下是否有生成一个color_show.js文件，生成js文件之后直接在浏览器中打开color_show.html即可看到预测结果。预测结果如下图所示 实验一输出结果展示: 查询集数据量为100时的实验结果 查询集数据量为500时的实验结果 查询集数据量为1000时的实验结果 实验二输出结果展示: 查询集数据量为100时的实验结果 查询集数据量为200时的实验结果 查询集数据量为300时的实验结果 demo中各个模块的功能 headers.h: 包含demo使用的头文件及相关参数配置 DataStructure(.h, .cpp): demo使用到的数据结构的声明定义和实现，包括B+树节点、特征向量、临时缓存3个数据结构 BlockFile(.h, .cpp): 按块(页)管理文件的文件管理器，主要功能是为B+树索引文件的读写和查找提供接口服务，是索引文件与程序交互的中间层 BTree(.h, .cpp): B+树的声明定义和实现，包含B+树的实现逻辑，主要提供建立索引的bulkload方法和利用索引进行查找的find方法供外部使用 MedRank(.h, .cpp): 主要包括medrank算法的实现，提供medrank算法的接口服务，同时提供一个暴力查找的接口服务供外部使用便于对比medrank算法的性能 Util(.h, .cpp): 主要为预处理和预测阶段提供一些工具函数，包括生成m条投影线的单位向量、向量投影、调用B+树接口建立索引、读取训练集数据、读取查询集数据、统计实体出现次数进行预测等功能 main.cpp: demo的主要逻辑，调用前面的类提供的接口服务完成主要的逻辑过程，包括接收和解析实验参数、分配资源、进行实验、输出实验结果等功能","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/其他/"}]},{"title":"编写一个支持jade+sass+livescript开发的gulpfile","slug":"编写一个支持jade-sass-livescript开发的gulpfile","date":"2016-06-28T03:50:00.000Z","updated":"2017-11-10T11:31:34.105Z","comments":true,"path":"2016/06/28/编写一个支持jade-sass-livescript开发的gulpfile/","link":"","permalink":"http://yoursite.com/2016/06/28/编写一个支持jade-sass-livescript开发的gulpfile/","excerpt":"","text":"gulp是一个优秀的前端开发自动化管理工具，今天，我准备分享一个可以支持用jade+sass+livescript开发web前端的gulpfile。OK，废话不多说，直接进入正题。 基本文件目录介绍：12345/app : 该目录下存放我们要开发的应用程序文件（jade, sass, ls等文件）/dest : 该目录下存放最终的成品文件（html, css, js等文件）/node_modules : nodejs的各种package/bower_components : 通过bower安装的各种前端框架或组件/gulpfile.js : gulp的执行文件（gulp在nodes环境下运行，在终端输入gulp之后，它会找到目录下的gulp file.js来执行） 前端开发的时候，通常需要搭配后台的服务器，为了做到更好的前后端分离，我们在前端开发的过程中，一般没有同时进行后台的开发。为了模拟后台服务器，我们使用browser-sync包来实现。调用browser-sync的init() API可以实例化一个服务器出来。下面以一个简单hello world的例子来进行说明。 上面例子中，定义了2个gulp任务，分别为serve和index。第一个任务依赖到第二个任务，即serve会等待index执行完之后才开始执行。每个gulp任务中的function就是那个任务执行的内容。上面index任务将/app文件夹下的index.html文件pipe到目标文件夹/dest中。serve任务创建了一个服务器，其中的参数这里不多做解释，有兴趣可自行查看browser-sync的文档。在终端输入gulp serve，就会执行serve任务和index任务了。浏览器将会呈现index.html的内容（browser-sync默认发送的其实页面为index.html）。 有了一个可以跑起来的服务器，下面，我们就要开始搭建jade的开发环境了。gulp有许多插件，功能多样特别方便，要将jade编译成html文件，也只需要一个插件gulp-jade就够了。请看下面的例子： 定义一个名为jade的gulp任务，把它加到serve的依赖中去。jade任务主要做的工作是讲/app下的所有jade文件编译成html文件然后pipe到目标文件夹。这里的$是一个gulp-load-plugins对象，gulp-load-plugins可以帮你引入你需要的插件，也是一个很方便的工具，具体使用方法请自行查看文档。在终端输入gulp serve之后，app文件夹下的jade文件都被编译成/dest文件夹下对应的html文件。这里还有一个要注意的，&#39;./app/**/*.jade&#39;是一种通配模式，这种写法可以匹配出/app文件夹下的所有jade文件，不管它在/app下是否嵌进其他文件夹。你可以将其想象为正则表达式，不过它跟正则表达是还是有所区别的。使用on(&#39;error&#39;, ...)的目的是监测错误，然后利用errorHandler将错误信息输出以便debug（eg. 当jade语法不规范时就会输出相关提示）。 继续，接下来搭建sass和livescript的开发环境。使用的插件是gulp-sass和gulp-livescript，安装gulp-livescript时还需要安装livescript。在/app目录下随便写几个sass文件和ls文件，执行gulp serve。 定义了sass和livescript任务，形式与jade类似，就只有编译的函数不同。执行之后/app文件夹下的文件也都转化为dest文件加下对应的文件。 至此，我们的开发环境已经搭建完毕。但事实上，这还未结束。我们只是有了一个能够自动编译代码并正确输出到目标文件夹的环境。大家有没有发现一个问题，我们编译完之后的css和js文件是不是都要没有引入到html文件中去，即在html文件加上&lt;link&gt;和&lt;script&gt;标签把css和js引入。这个过程，如果人工去做的话也是一件很繁琐的事情，尤其是当你的文件数量很多的时候。举个例子，在现代web SPA开发中，我们可能用到很多angularJS以及相关的组件，还有bootstrap等开源框架，当一个应用比较庞大的时候，这些框架的文件加上自己写的文件合起来数量是相当多的，人工去加入标签效率非常低。下面，我们用gulp-inject和wiredep插件来实现自动引入这些文件。在这个例子中，我将所有css和js文件引入到index.html中。 定义了一个inject任务，由于是要把编译好的css和js文件引入到index.html中，因此，需要inject需要等待sass和livescript编译完成，所以，我重新调整了一下依赖关系，把sass, livescript任务从serve的依赖列表中搬了下来（jade顺便也拉下来了，好看点~）。使用inject把要引入的文件引入到index.html中去，这里引入的主要是自己写的文件。然后使用wiredep引入那些通过bower安装的前端框架文件。gulp-inject和wiredep的用法也比较简单，官方文档有示例用法，这里我也不作详细介绍了。 以上是成功引入之后的截图，css和js文件都自动加入到index.html文件里面了。这样，我们就可以愉快地只顾在/app打代码而不管其他事情了。 最后，我们还有两个需求要实现。开发的过程中，经常会修改代码，每一次修改代码都要刷一下浏览器真的很繁琐，有没有办法让我在修改代码之后按下ctrl+s保存时浏览器也跟着自动刷新呢？答案是yes。回到我们刚一开始提及的browser-sync，这个组件提供了reload API，调用之后它机会自动帮你通知浏览器进行刷新。知道这个API之后，就要开始写如何以及何时调用reload了。请看下面例子： 定义一个watch任务，这个任务监控/app下的jade,sass,ls和html文件是否发生修改，以及检测是否有通过bower安装或删除一些文件(检测bower.json的目的)。如果有发生改动的话，马上重新执行inject，我们之前的inject需要等待sass，livescript和jade任务，所以这个操作会执行到的任务有4个，也就是重新编译了一遍所有的文件，并重新引入相关的css和js到index.html文件。执行完之后，再执行function里面的browserSync.reload()，刷新浏览器的页面。狂拽酷炫吊炸天，这回真的可以抛开很多杂七杂八的事了。 最后一个需求，一次性删除/dest目录下所有内容。在开发时，会不断的迭代过去的版本，文件数量也会随之改变。如果我在/app下面删除了1.ls，执行gulp serve之后虽然那些没有被删除的文件都会重新编译然后写到/dest目录下对应的文件，但是/dest下面的1.js却会一直留在那里。这些琐碎文件有时也是对项目的一种污染，而且文件太过琐碎的话清理起来也是麻烦，最好的方式就是一次性删除/dest下的内容然后重新编译/app里面的东西。所以，我最后实现了一个清除功能，例子如下： 看到代码最后的clean任务，这个任务使用了del插件，可以删除对应路径的文件或文件夹。在终端执行gulp clean之后，dest文件夹整个被删除，一点不剩。 到这里，整个gulpfile就算是写完了，支持jade+sass+livescript开发环境，可以自动监控文件改动刷新浏览器，一次性清除文件。基本功能算是有了，不过也有不少地方需要完善。本博客只给一个简单例子作为交流，展示一般的gulpfile要怎么写，如果巧妙地利用插件。有兴趣者可以继续完善该gulpfile。比如：这个gulpfile还不能同时支持ls和js混合开发，sass和css混合开发，其次，在watch的时候重新执行inject会做多余的工作，应该检查是文件改动还是文件增删，如果是文件改动，比如我改了某些ls文件，那只需执行livescript任务重新编译livescript即可。如果是文件增删，则需要重新inject引入正确的css和js到index.html~ 最后附上本文用到的完整的gulpfile.js。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970var gulp = require('gulp');var browserSync = require('browser-sync').create();var gutil = require('gulp-util');var wiredep = require('wiredep').stream;var $ = require('gulp-load-plugins')(&#123; pattern: ['gulp-*', 'del']&#125;);var _ = require('lodash');var dest = './dest';function errorHandler(title) &#123; return function (err) &#123; gutil.log(gutil.colors.red('[' + title + ']'), err.toString()); this.emit('end'); &#125;;&#125;gulp.task('serve', ['inject', 'watch'], function() &#123; browserSync.init(&#123; startPath : '/', server : &#123; baseDir : './dest', routes : &#123; '/bower_components' : 'bower_components' &#125; &#125; &#125;);&#125;);gulp.task('jade', function() &#123; return gulp.src(['./app/**/*.jade']) .pipe($.jade(&#123;pretty : true&#125;)) .on('error', errorHandler('jade')) .pipe(gulp.dest(dest));&#125;);gulp.task('sass', function() &#123; return gulp.src(['./app/**/*.sass']) .pipe($.sass()) .on('error', errorHandler('sass')) .pipe(gulp.dest(dest));&#125;);gulp.task('livescript', function() &#123; return gulp.src(['./app/**/*.ls']) .pipe($.livescript()) .on('error', errorHandler('livescript')) .pipe(gulp.dest(dest));&#125;);gulp.task('inject', ['sass', 'livescript', 'jade'], function() &#123; var injectFiles = gulp.src([dest+'/**/*.js', dest+'/**/*.css'], &#123;read: false&#125;); return gulp.src(['./app/index.html']) .pipe($.inject(injectFiles, &#123;ignorePath : '/dest', addRootSlash: false&#125;)) .on('error', errorHandler('inject')) .pipe(wiredep(_.extend(&#123;&#125;, 'bower_components'))) .pipe(gulp.dest(dest));&#125;);gulp.task('watch', function() &#123; gulp.watch(['./app/**/*.html', './app/**/*.jade', './app/**/*.ls', './app/**/*.sass', 'bower.json'], ['inject', function() &#123; browserSync.reload(); &#125;]);&#125;);gulp.task('clean', function() &#123; return $.del(dest);&#125;);","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"}]},{"title":"在windows下使用postgreSQL导入tpch的数据表","slug":"在windows下使用postgreSQL导入tpch的数据表","date":"2016-04-03T14:07:00.000Z","updated":"2017-11-10T10:17:49.212Z","comments":true,"path":"2016/04/03/在windows下使用postgreSQL导入tpch的数据表/","link":"","permalink":"http://yoursite.com/2016/04/03/在windows下使用postgreSQL导入tpch的数据表/","excerpt":"","text":"初学数据库，老师要求我们去熟悉postgreSQL，并且要求使用tpch的数据。今天在使用dbgen生成数据以及导入数据到postgre的过程中遇到一些问题，也在网上看了许多资料，几番折腾之后最终也算解决了问题，现在来把今天使用dbgen的流程和遇到的问题以及解决方案总结一下，以便以后需要的时候不用再到处找资料。 使用visual studio打开dbgen文件夹下的tpch.sln并生成，生成之后会有一个Debug文件夹下，把该文件夹下的dbgen.exe复制到dbgen文件夹下，运行dbgen.exe生成后缀名为.tbl的文件。 在postgre创建数据库tpch，连接到数据库tpch之后创建表，表的定义可以查看dbgen目录下的dss.ddl。 使用copy操作来从文件导入数据，这里以生成的.tbl文件里面的lineitem.tbl为例进行说明。 具体操作为，COPY LINEITEM FROM &#39;&lt;path&gt;&#39;，&lt;path&gt;为lineitem.tbl所在的位置，具体参考下图。我一开始是放在桌面下，直接运行指令之后报错了，提示permission denied，原来是postgre对桌面目录没有访问权限，于是试着用管理员身份运行SQL shell，还是不行。最后直接把lineitem.tbl复制到postgre的安装目录下了，一举搞定，导入完数据记得再删除这些文件即可。再次运行copy操作，还是报错，这次提示的错误是‘无效的整型输入语法’，一脸懵逼，网上几番查找之后才发现原来是引文分隔符的问题，postgre在copy时默认字段的分隔符是&#39;\\t&#39;，而dbgen生成的数据里面是用&#39;|&#39;字符来分开字段，于是造成字段没能正确区分开。解决方案就是在copy的时候加上参数delimiter指定分隔符号为&#39;|&#39;，具体写法为：COPY LINEITEM FROM &#39;&lt;path&gt;&#39; WITH DELIMITER AS &#39;|&#39;; 再次尝试了一下，这个错误解决了，但却出现了另一个错误，提示‘最后期望字段后有额外数据’，真是贼坑，怎么还有额外数据呢？ 最后打开lineitem.tbl文件一观文件内容，发现每一行记录的结尾都带有&#39;|&#39;字符，心想会不会是因为这个的影响导致copy按照字段分隔理解为&#39;|&#39;后面还有其他字段。网上查了查也没有查到什么解决方法，倒是看到一篇博客让我恍然大悟。博客链接如下http://www.xuebuyuan.com/845077.html，里面也是讲到导入数据出错的问题，他用的是ms sql server，解决方案是导入数据时加参数rowterminator=‘|\\n’，看到他的解决方案，我就大概明白是怎么一回事了。 查阅postgre的文档，却没有发现copy操作有什么指定每一行结束的字符的参数，于是通过加参数的方式看来是行不通了。只能修改tbl文件了。简单写了个c++程序(c++11)，把生成的lineitem.tbl文件里面文本每一行的结尾的&#39;|&#39;字符去掉。最后运行完之后，再次尝试copy，这次终于顺利copy了，把文件中的数据导入到数据库，这也恰好证实了之前的猜测是对的，果然是因为结尾的&#39;|&#39;字符的影响。 123456789101112131415161718#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; freopen(\"lineitem.tbl\", \"r\", stdin); freopen(\"tbl/lineitem.tbl\", \"w\", stdout); string line; while (getline(cin, line)) &#123; line.pop_back(); cout &lt;&lt; line &lt;&lt; endl; &#125; return 0;&#125; 虽然都只是小问题，不过还是折腾了许久，还好最后解决了还算有所收获。今晚跟同学交流时发现他在linux下也遇到这些问题，把今天的解决方法跟他交流之后也顺利解决了。现在，基本流程和解决方法描述完毕，以上描述应该是可以适用windows和linux系统，其他系统应该也类似。第一次写博客，写得比较粗糙。若有错误或者可以改进的地方还请大神指点。","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]}]}