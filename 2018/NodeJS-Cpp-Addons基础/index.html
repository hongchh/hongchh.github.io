<!DOCTYPE html><html><head><meta charset="utf-8"><title>NodeJS C++ Addons基础 | 洪创煌的博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="NodeJS"><meta name="description" content="NodeJS C++插件是一种动态链接库，采用C/C++语言编写，可以通过require()将插件加载进NodeJS中进行使用。利用V8提供的API，可以实现JavaScript和C++的互相调用，打通JavaScript和C++之间的接口。在做一些高性能或者底层模块的时候，需要用到一些C++库，NodeJS C++插件可以帮助我们封装这些C++库的接口，使得JavaScript具备调用C++库的"><meta name="keywords" content="NodeJS"><meta property="og:type" content="article"><meta property="og:title" content="NodeJS C++ Addons基础"><meta property="og:url" content="https://hongchh.github.io/2018/NodeJS-Cpp-Addons基础/index.html"><meta property="og:site_name" content="洪创煌的博客"><meta property="og:description" content="NodeJS C++插件是一种动态链接库，采用C/C++语言编写，可以通过require()将插件加载进NodeJS中进行使用。利用V8提供的API，可以实现JavaScript和C++的互相调用，打通JavaScript和C++之间的接口。在做一些高性能或者底层模块的时候，需要用到一些C++库，NodeJS C++插件可以帮助我们封装这些C++库的接口，使得JavaScript具备调用C++库的"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://hongchh.github.io/images/2018-04-16/1.png"><meta property="og:updated_time" content="2018-04-19T09:20:51.310Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="NodeJS C++ Addons基础"><meta name="twitter:description" content="NodeJS C++插件是一种动态链接库，采用C/C++语言编写，可以通过require()将插件加载进NodeJS中进行使用。利用V8提供的API，可以实现JavaScript和C++的互相调用，打通JavaScript和C++之间的接口。在做一些高性能或者底层模块的时候，需要用到一些C++库，NodeJS C++插件可以帮助我们封装这些C++库的接口，使得JavaScript具备调用C++库的"><meta name="twitter:image" content="https://hongchh.github.io/images/2018-04-16/1.png"><link rel="icon" href="/css/images/favicon.png"><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/libs/titillium-web/styles.css"><link rel="stylesheet" href="/libs/source-code-pro/styles.css"><link rel="stylesheet" href="/css/style.css"><script src="/libs/jquery/2.0.3/jquery.min.js"></script><link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css"><link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css"><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script></head></html><body><div id="wrap"><header id="header"><div id="header-outer" class="outer"><div class="container"><div class="container-inner"><div id="header-title"><h1 class="logo-wrap"><a href="/" class="logo"></a></h1><h2 class="subtitle-wrap"><p class="subtitle">生命是一场练习！</p></h2></div><div id="header-inner" class="nav-container"><a id="main-nav-toggle" class="nav-icon fa fa-bars"></a><div class="nav-container-inner"><ul id="main-nav"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/">主页</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/about/index.html">关于</a></li></ul><nav id="sub-nav"><div id="search-form-wrap"><form class="search-form"><input type="text" class="ins-search-input search-form-input" placeholder="搜索"> <button type="submit" class="search-form-submit"></button></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="想要查找什么..."> <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(未命名)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script></div></nav></div></div></div></div></div></header><div class="container"><div class="main-body container-inner"><div class="main-body-inner"><section id="main"><div class="main-body-header"><h1 class="header">未分类</h1></div><div class="main-body-content"><article id="post-NodeJS-Cpp-Addons基础" class="article article-single article-type-post" itemscope itemprop="blogPost"><div class="article-inner"><header class="article-header"><h1 class="article-title" itemprop="name">NodeJS C++ Addons基础</h1></header><div class="article-meta"><div class="article-date"><a href="/2018/NodeJS-Cpp-Addons基础/" class="article-date"><time datetime="2018-04-16T07:45:57.000Z" itemprop="datePublished">2018-04-16</time></a></div><div class="article-tag"><i class="fa fa-tag"></i> <a class="tag-link" href="/tags/NodeJS/">NodeJS</a></div></div><div class="article-entry" itemprop="articleBody"><p>NodeJS C++插件是一种动态链接库，采用C/C++语言编写，可以通过<code>require()</code>将插件加载进NodeJS中进行使用。利用V8提供的API，可以实现JavaScript和C++的互相调用，打通JavaScript和C++之间的接口。在做一些高性能或者底层模块的时候，需要用到一些C++库，NodeJS C++插件可以帮助我们封装这些C++库的接口，使得JavaScript具备调用C++库的能力。本文将记录利用基础的V8 API编写NodeJS C++插件的过程，实现C++和JavaScript之间的参数传递、函数调用以及回调、异常处理以及对象函数传递等功能。记录过程中也会对部分概念和API进行阐述。</p><p>本文所使用的代码示例可以从该仓库中找到–<a href="https://github.com/hongchh/nodejs-demo/tree/master/cpp-addons" target="_blank" rel="external">【cpp-addons】</a></p><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="1-1、hello-world示例"><a href="#1-1、hello-world示例" class="headerlink" title="1.1、hello world示例"></a>1.1、hello world示例</h2><p>首先通过一个简单的HelloWorld示例来了解编写C++插件的基本写法和一些API的基本概念。在示例中，C++模块向JavaScript暴露了一个<code>hello</code>接口，在JavaScript中调用该接口后会得到返回值<code>hello world</code>。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> HelloWorldDemo &#123;</span><br><span class="line">  <span class="keyword">using</span> v8::FunctionCallbackInfo;</span><br><span class="line">  <span class="keyword">using</span> v8::Isolate;</span><br><span class="line">  <span class="keyword">using</span> v8::Local;</span><br><span class="line">  <span class="keyword">using</span> v8::Object;</span><br><span class="line">  <span class="keyword">using</span> v8::String;</span><br><span class="line">  <span class="keyword">using</span> v8::Value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">hello</span> <span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    Isolate* isolate = args.GetIsolate();</span><br><span class="line">    <span class="comment">/* 通过 FunctionCallbackInfo&lt;Value&gt;&amp; args 可以设置返回值 */</span></span><br><span class="line">    args.GetReturnValue().Set(String::NewFromUtf8(isolate, <span class="string">"hello world."</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">(Local&lt;Object&gt; exports)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 设置模块的导出方法 hello */</span></span><br><span class="line">    <span class="comment">/* 等价于 js 模块中的 module.exports.hello = hello */</span></span><br><span class="line">    NODE_SET_METHOD(exports, <span class="string">"hello"</span>, hello);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  NODE_MODULE(NODE_GYP_MODULE_NAME, init)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>JavaScript调用C++模块的方法时，会传递一个V8对象，类型为<code>FunctionCallbackInfo&lt;Value&gt;</code>。通过这个V8对象，JavaScript可以向C++接口传递参数，C++函数也可以通过这个对象来向JavaScript回传信息，即设置返回值。在C++接口中，通过参数<code>const FunctionCallbackInfo&lt;Value&gt;&amp; args</code>可以拿到一个<code>Isolate</code>对象，<code>Isolate</code>代表一个V8虚拟机实例。通过<code>args.GetIsolate()</code>可以获取到运行JavaScript调用者的V8虚拟机实例。这个V8实例包含了内存堆，在C++接口中创建V8提供的JavaScript对象类型实例的时候会使用到。例如前面的hello world例子中，在创建一个JS字符串的时候需要传递<code>isolate</code>对象，表示在该V8虚拟机上创建了一个JS字符串对象，之后该字符串便可以被V8虚拟机上运行的JS调用者所使用。</p><p><code>Local</code>是一个模板句柄类，<code>Local&lt;SomeType&gt;</code>代表指向某种类型的句柄。例如模块的<code>exports</code>属性是一个JavaScript对象，句柄类型为<code>Local&lt;Object&gt;</code>。传递给<code>init</code>函数的参数其实是指向相应对象的句柄。</p><p><code>NODE_MODULE</code>是一个宏，设置模块初始化函数为<code>init</code>。<code>init</code>函数中执行模块的初始化，当模块第一次被加载进NodeJS应用中的时候就会执行<code>init</code>函数，<code>init</code>函数中可以设置<code>exports</code>属性将C++接口暴露出去给JavaScript使用。<code>NODE_SET_METHOD</code>用于设置属性或方法，第二个参数为属性名，第三个参数为方法对应的属性值。如果需要给<code>exports</code>对象设置多个属性或方法，可以调用多次<code>NODE_SET_METHOD</code>。<code>exports</code>对象上设置的属性方法将会作为接口暴露给外部使用。</p><p>编写NodeJS C++插件必须遵循以下这种模式：必须有一个初始化函数对模块进行初始化（设置方法属性等），然后加上<code>NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)</code>设置模块名和初始化函数。初始化函数可以有两种写法，第一种写法常用于设置模块的<code>exports</code>对象上的某个属性或方法，第二种写法可用于直接重写整个<code>exports</code>对象。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initialize_1</span><span class="params">(Local&lt;Object&gt; exports)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 进行初始化...</span></span><br><span class="line">  <span class="comment">// example</span></span><br><span class="line">  <span class="comment">// 等价于js模块中的 module.exports.hello = hello</span></span><br><span class="line">  NODE_SET_METHOD(exports, <span class="string">"hello"</span>, hello);</span><br><span class="line">&#125;</span><br><span class="line">NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize_1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initialize_2</span><span class="params">(Local&lt;Object&gt; exports, Local&lt;Object&gt; <span class="keyword">module</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 进行初始化...</span></span><br><span class="line">  <span class="comment">// example</span></span><br><span class="line">  <span class="comment">// 等价于js模块中的 module.exports = hello</span></span><br><span class="line">  NODE_SET_METHOD(<span class="keyword">module</span>, <span class="string">"exports"</span>, hello);</span><br><span class="line">&#125;</span><br><span class="line">NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize_2)</span><br></pre></td></tr></table></figure><p></p><h2 id="1-2、构建方法"><a href="#1-2、构建方法" class="headerlink" title="1.2、构建方法"></a>1.2、构建方法</h2><p>编写完C++代码后需要将其编译构建成node文件才能够被NodeJS使用。利用<code>node-gyp</code>可以很方便地进行构建。首先在C++代码文件的根目录下创建一个<code>binding.gyp</code>文件，在文件中写入类似下面的JSON格式的内容。如果有多个插件，可以在<code>targets</code>数组上继续添加。数组的元素为一个对象，对象的<code>target_name</code>属性指明构建后的插件名称，<code>sources</code>属性则是C++源码路径。<code>sources</code>属性是一个数组，如果插件对应的源码文件有多个，只需在数组中列举出对应的多个路径即可。例如下面的示例，C++源码<code>hello.cc</code>经过构建之后，会生成名为<code>addon.node</code>的插件。<br></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"targets"</span>: [&#123;</span><br><span class="line">    <span class="attr">"target_name"</span>: <span class="string">"addon"</span>,</span><br><span class="line">    <span class="attr">"sources"</span>: [<span class="string">"hello.cc"</span>]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>写好<code>binding.gyp</code>以后，只需要执行以下2个命令即可完成构建，两句命令可以分开执行，也可以合并成一句。<code>configure</code>指令执行后会在当前目录下生成<code>build</code>文件夹，并在<code>build</code>文件夹中生成相应平台的构建文件（例如Linux下的Makefile）。<code>build</code>执行后则是编译源码生成拓展名为<code>node</code>的NodeJS插件，插件会输出到<code>./build/Release/</code>或<code>./build/Debug/</code>文件夹下。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node-gyp configure</span><br><span class="line">node-gyp build</span><br><span class="line"><span class="comment"># 合并成一句</span></span><br><span class="line">node-gyp configure build</span><br></pre></td></tr></table></figure><p></p><p>构建完成后，在JS中直接通过<code>require</code>便可引用到该插件，然后便可在JS中直接调用插件上设置的接口。<code>.node</code>文件实际上是一个动态链接库，使用<code>require</code>时可以省略掉拓展名<code>.node</code>，NodeJS会自动去加载这个动态链接库。不过这里有个要点需要注意，使用<code>require</code>引用模块的时候，会优先寻找拓展名为<code>.js</code>的模块，所以，如果相同路径下同时存在<code>.node</code>和<code>.js</code>文件，<code>require</code>引用到的其实是<code>.js</code>文件。例如：如果<code>./build/Release/</code>文件夹下同时存在<code>addon.js</code>和<code>addon.node</code>，这时下面这行代码执行后将加载到<code>addon.js</code>。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addon = <span class="built_in">require</span>(<span class="string">'./build/Release/addon'</span>)</span><br></pre></td></tr></table></figure><p></p><h2 id="1-3、运行结果"><a href="#1-3、运行结果" class="headerlink" title="1.3、运行结果"></a>1.3、运行结果</h2><p>通过下面的<code>binding.gyp</code>将前面的hello world示例代码进行编译构建，生成<code>hello_world.node</code>文件。<br></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"targets"</span>: [&#123;</span><br><span class="line">    <span class="attr">"target_name"</span>: <span class="string">"hello_world"</span>,</span><br><span class="line">    <span class="attr">"sources"</span>: [<span class="string">"hello_world.cc"</span>]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接下来用以下代码对C++插件进行使用。可以看到成功实现了在JavaScript中调用C++接口，接口执行后返回字符串<code>hello world</code>。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello-world demo</span></span><br><span class="line"><span class="keyword">const</span> HelloWorld = <span class="built_in">require</span>(<span class="string">'./build/Release/hello_world'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'[HelloWorldDemo] '</span> + HelloWorld.hello())</span><br></pre></td></tr></table></figure><p></p><p><img src="/images/2018-04-16/1.png" alt="hello world示例"></p><h1 id="二、函数传参与回调"><a href="#二、函数传参与回调" class="headerlink" title="二、函数传参与回调"></a>二、函数传参与回调</h1><p>在调用C++接口的时候，经常需要向接口传递参数。前面提到，JavaScript调用C++接口的时候会向其传递一个类型为<code>FunctionCallbackInfo&lt;Value&gt;</code>对象，通过这个对象可以实现向C++接口传递参数，参数可以是普通的JS对象，也可以是函数。传递函数参数时，还可以实现回调，即JavaScript在调用C++接口时向其传递回调函数，C++接口执行后回调JavaScript。</p><p>接下来通过实现一个累加函数探索函数传参和回调的实现。累加函数<code>accumulate</code>的作用是对参数进行累加求和，然后返回求和结果。例如调用<code>accumulate(1, 2, 3)</code>将得到<code>1+2+3</code>的结果，即<code>6</code>。为了同时展示传参和回调，<code>accumulate</code>函数的求和结果不能像前面hello world例子中一样直接通过设置返回值进行返回，而是要通过回调函数进行返回。假设调用<code>accumulate</code>函数时通过最后一个参数传递回调函数，则调用时的写法将变为<code>accumulate(1, 2, 3, callback)</code>。下面是C++模块的代码。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FunctionArgumentsAndCallbackDemo &#123;</span><br><span class="line">  <span class="keyword">using</span> v8::Function;</span><br><span class="line">  <span class="keyword">using</span> v8::FunctionCallbackInfo;</span><br><span class="line">  <span class="keyword">using</span> v8::Isolate;</span><br><span class="line">  <span class="keyword">using</span> v8::Local;</span><br><span class="line">  <span class="keyword">using</span> v8::Number;</span><br><span class="line">  <span class="keyword">using</span> v8::Object;</span><br><span class="line">  <span class="keyword">using</span> v8::Value;</span><br><span class="line">  <span class="keyword">using</span> v8::Null;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">accumulate</span> <span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    Isolate* isolate = args.GetIsolate();</span><br><span class="line">    <span class="comment">/* 提取通过参数传递的回调函数 */</span></span><br><span class="line">    Local&lt;Function&gt; callback = Local&lt;Function&gt;::Cast(args[args.Length() - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历参数进行求和 */</span></span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.Length() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">      sum += args[i]-&gt;NumberValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将求和结果转成一个js Number, 通过回调函数进行返回 */</span></span><br><span class="line">    Local&lt;Number&gt; num = Number::New(isolate, sum);</span><br><span class="line">    Local&lt;Value&gt; argv[<span class="number">1</span>] = &#123; num &#125;;</span><br><span class="line">    callback-&gt;Call(Null(isolate), <span class="number">1</span>, argv);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">(Local&lt;Object&gt; exports)</span> </span>&#123;</span><br><span class="line">    NODE_SET_METHOD(exports, <span class="string">"accumulate"</span>, accumulate);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  NODE_MODULE(NODE_GYP_MODULE_NAME, init)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上述代码中通过<code>args</code>可以获得从JavaScript传递过来的参数，这些参数都是JavaScript对象实例，使用时需要根据情况调用相关方法，例如求和的参数是多个数字，在JavaScript中数字都是<code>Number</code>对象实例，需要调用<code>NumberValue()</code>方法后才能获取到对应的<code>double</code>类型数值。通过<code>Local&lt;Function&gt;::Cast()</code>获取到回调函数的句柄，获取句柄后可以通过<code>Call()</code>方法对回调函数进行调用，调用时需要传递参数个数和参数实例（参数实例需要以数组形式进行传递）。<code>通过这种方式实现的函数回调为同步回调，不是异步回调</code>，异步回调的实现需要用到其他技巧，不在本文的讨论范围之内。</p><p>给<code>binding.gyp</code>中的<code>targets</code>数组添加以下元素，然后继续使用<code>node-gyp configure build</code>进行编译构建生成<code>.node</code>文件。<br></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"target_name"</span>: <span class="string">"accumulate"</span>,</span><br><span class="line">  <span class="attr">"sources"</span>: [<span class="string">"accumulate.cc"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>通过以下JavaScript代码即可使用C++插件，并验证接口是否调用成功。代码输出如果所示，<code>accumulate</code>接口成功对参数进行求和并通过回调函数返回了求和结果。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function-arguments-and-callbacks demo</span></span><br><span class="line"><span class="keyword">const</span> Accumulate = <span class="built_in">require</span>(<span class="string">'./build/Release/accumulate'</span>)</span><br><span class="line">Accumulate.accumulate(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, (sum) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[FunctionArgumentsAndCallbacksDemo] 1 + 3 + 4 + 7 = '</span> + sum)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p><img src="/images/2018-04-16/2.png" alt="函数传参与回调示例"></p><h1 id="三、异常处理"><a href="#三、异常处理" class="headerlink" title="三、异常处理"></a>三、异常处理</h1><p>C++插件提供的接口函数如果在运行后遇到异常，JavaScript调用者是否可以知道异常并进行处理呢？答案是可以的，V8提供的API使得C++可以直接向JavaScript抛出异常。前面提到，<code>Isolate</code>对象代表一个V8虚拟机实例。我们可以通过这个实例直接向该V8虚拟机抛出异常，该虚拟机实例上运行的JavaScript代码只要对异常进行捕获就可以知道异常的发生并进行相应的处理了。</p><p>上面的累加求和例子中，没有考虑传递的参数类型就直接进行求和，在某些情况下可能发生异常。接下来，对上面的例子进行改进，增加异常处理机制，探索C++插件如何向JavaScript报告异常。代码如下所示。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FunctionArgumentsAndCallbackDemo &#123;</span><br><span class="line">  <span class="keyword">using</span> v8::Function;</span><br><span class="line">  <span class="keyword">using</span> v8::FunctionCallbackInfo;</span><br><span class="line">  <span class="keyword">using</span> v8::Isolate;</span><br><span class="line">  <span class="keyword">using</span> v8::Local;</span><br><span class="line">  <span class="keyword">using</span> v8::Number;</span><br><span class="line">  <span class="keyword">using</span> v8::Object;</span><br><span class="line">  <span class="keyword">using</span> v8::Value;</span><br><span class="line">  <span class="keyword">using</span> v8::Null;</span><br><span class="line">  <span class="keyword">using</span> v8::Exception;</span><br><span class="line">  <span class="keyword">using</span> v8::String;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">accumulate</span> <span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    Isolate* isolate = args.GetIsolate();</span><br><span class="line">    <span class="comment">/* 参数不合理异常 */</span></span><br><span class="line">    <span class="keyword">if</span> (args.Length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      isolate-&gt;ThrowException(Exception::TypeError(</span><br><span class="line">        String::NewFromUtf8(isolate, <span class="string">"Arguments Number Error."</span>)</span><br><span class="line">      ));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 没有回调函数 */</span></span><br><span class="line">    <span class="keyword">if</span> (!args[args.Length() - <span class="number">1</span>]-&gt;IsFunction()) &#123;</span><br><span class="line">      isolate-&gt;ThrowException(Exception::TypeError(</span><br><span class="line">        String::NewFromUtf8(isolate, <span class="string">"No Callback Error."</span>)</span><br><span class="line">      ));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 提取通过参数传递的回调函数 */</span></span><br><span class="line">    Local&lt;Function&gt; callback = Local&lt;Function&gt;::Cast(args[args.Length() - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历参数进行求和 */</span></span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.Length() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">      <span class="comment">/* 如果参数不是数字，向js抛出异常 */</span></span><br><span class="line">      <span class="keyword">if</span> (!args[i]-&gt;IsNumber()) &#123;</span><br><span class="line">        isolate-&gt;ThrowException(Exception::TypeError(</span><br><span class="line">          String::NewFromUtf8(isolate, <span class="string">"Arguments Type Error."</span>)</span><br><span class="line">        ));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sum += args[i]-&gt;NumberValue();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将求和结果转成一个js Number, 通过回调函数进行返回 */</span></span><br><span class="line">    Local&lt;Number&gt; num = Number::New(isolate, sum);</span><br><span class="line">    Local&lt;Value&gt; argv[<span class="number">1</span>] = &#123; num &#125;;</span><br><span class="line">    callback-&gt;Call(Null(isolate), <span class="number">1</span>, argv);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">(Local&lt;Object&gt; exports)</span> </span>&#123;</span><br><span class="line">    NODE_SET_METHOD(exports, <span class="string">"accumulate"</span>, accumulate);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  NODE_MODULE(NODE_GYP_MODULE_NAME, init)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>通过<code>Isolate</code>对象的<code>ThrowException</code>方法，可以直接向JavaScript抛出异常。在JavaScript中，通过<code>try/catch</code>机制便可以捕获和处理异常。下面是代码示例，调用C++接口的时候故意引发异常，捕获到异常后将异常信息进行输出。如果图所示，可以成功实现C++模块向JavaScript抛出异常以及JavaScript捕获处理异常。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exception demo</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Accumulate.accumulate()</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[ExceptionDemo] '</span> + err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Accumulate.accumulate(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[ExceptionDemo] '</span> + err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Accumulate.accumulate(<span class="number">1</span>, <span class="number">2</span>, <span class="string">'a'</span>, (sum) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(sum)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[ExceptionDemo] '</span> + err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><img src="/images/2018-04-16/3.png" alt="异常处理示例"></p><h1 id="四、返回对象和函数"><a href="#四、返回对象和函数" class="headerlink" title="四、返回对象和函数"></a>四、返回对象和函数</h1><p>前面的例子中，JavaScript可以通过<code>args</code>向C++传递JS对象和函数给C++模块使用，如果反过来让C++传递对象和函数给JavaScript使用，是否可以实现呢？答案是可以的。前面的例子展示了C++模块可以通过<code>args.GetReturnValue().Set(xxx)</code>来向JavaScript返回内容，这里返回的内容除了向前面例子中的普通<code>String、Number</code>等对象之外，也可以返回<code>Object</code>或者<code>Function</code>。C++模块中，可以将需要的信息封装成<code>Object</code>然后返回给JavaScript使用，可以将部分C++函数包装成<code>Function</code>给JavaScript调用。</p><p>接下来通过一个简单例子来探索传递对象和函数的做法。在这个例子中，C++模块向JavaScript提供了<code>getPerson()</code>和<code>getFunction()</code>两个方法，<code>getPerson()</code>方法会返回一个<code>Object</code>给JavaScript，在JavaScript中调用此方法获得对象后可以直接使用该对象，访问对象属性获取信息（信息包括firstname和lastname）。<code>getFunction()</code>方法会将一个C++函数<code>sayHiTo()</code>包装成一个JS函数，返回一个<code>Function</code>给JavaScript，在JavaScript中调用此方法获取函数对象后，可以直接对返回的函数进行调用。<code>sayHiTo()</code>是一个C++函数，接收参数为一个<code>Object</code>，返回一句打招呼的信息（”Hi, xxxx”）。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ReturnObjectAndFuntionDemo &#123;</span><br><span class="line">  <span class="keyword">using</span> v8::Function;</span><br><span class="line">  <span class="keyword">using</span> v8::FunctionTemplate;</span><br><span class="line">  <span class="keyword">using</span> v8::FunctionCallbackInfo;</span><br><span class="line">  <span class="keyword">using</span> v8::Isolate;</span><br><span class="line">  <span class="keyword">using</span> v8::Object;</span><br><span class="line">  <span class="keyword">using</span> v8::String;</span><br><span class="line">  <span class="keyword">using</span> v8::Value;</span><br><span class="line">  <span class="keyword">using</span> v8::Local;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">getPerson</span> <span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    Isolate* isolate = args.GetIsolate();</span><br><span class="line">    <span class="comment">/* 创建对象 */</span></span><br><span class="line">    Local&lt;Object&gt; obj = Object::New(isolate);</span><br><span class="line">    <span class="comment">/* 设置对象属性，Set(key, value) */</span></span><br><span class="line">    obj-&gt;Set(</span><br><span class="line">      String::NewFromUtf8(isolate, <span class="string">"firstname"</span>),</span><br><span class="line">      String::NewFromUtf8(isolate, <span class="string">"Java"</span>)</span><br><span class="line">    );</span><br><span class="line">    obj-&gt;Set(</span><br><span class="line">      String::NewFromUtf8(isolate, <span class="string">"lastname"</span>),</span><br><span class="line">      String::NewFromUtf8(isolate, <span class="string">"Script"</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">/* 将对象返回给JavaScript */</span></span><br><span class="line">    args.GetReturnValue().Set(obj);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sayHiTo</span> <span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    Isolate* isolate = args.GetIsolate();</span><br><span class="line">    <span class="comment">/* 提取通过参数传递的JS对象 */</span></span><br><span class="line">    Local&lt;Object&gt; person = Local&lt;Object&gt;::Cast(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">/* 提取对象属性值并拼接字符串 */</span></span><br><span class="line">    Local&lt;String&gt; fullname = String::Concat(</span><br><span class="line">      person-&gt;Get(String::NewFromUtf8(isolate, <span class="string">"firstname"</span>))-&gt;ToString(),</span><br><span class="line">      person-&gt;Get(String::NewFromUtf8(isolate, <span class="string">"lastname"</span>))-&gt;ToString()</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">/* 将结果返回给JavaScript */</span></span><br><span class="line">    args.GetReturnValue().Set(String::Concat(</span><br><span class="line">      String::NewFromUtf8(isolate, <span class="string">"Hi, "</span>),</span><br><span class="line">      fullname</span><br><span class="line">    ));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">getFunction</span> <span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    Isolate* isolate = args.GetIsolate();</span><br><span class="line">    <span class="comment">/* 利用函数模板构造一个JavaScript函数 */</span></span><br><span class="line">    Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(isolate, sayHiTo);</span><br><span class="line">    Local&lt;Function&gt; fn = tpl-&gt;GetFunction();</span><br><span class="line">    fn-&gt;SetName(String::NewFromUtf8(isolate, <span class="string">"sayHiTo"</span>));</span><br><span class="line">    <span class="comment">/* 将函数返回给JavaScript */</span></span><br><span class="line">    args.GetReturnValue().Set(fn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">(Local&lt;Object&gt; exports)</span> </span>&#123;</span><br><span class="line">    NODE_SET_METHOD(exports, <span class="string">"getPerson"</span>, getPerson);</span><br><span class="line">    NODE_SET_METHOD(exports, <span class="string">"getFunction"</span>, getFunction);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  NODE_MODULE(NODE_GYP_MODULE_NAME, init)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>返回对象的做法比较简单，直接创建一个<code>Object</code>，然后通过<code>Set()</code>方法设置属性和属性值，把需要返回的信息进行包装，最后通过<code>args.GetReturnValue().Set()</code>方法便可以直接将包装好的对象返回给JavaScript。</p><p>返回函数的做法也是类似，创建一个<code>Function</code>，然后通过<code>args.GetReturnValue().Set()</code>方法将函数返回给JavaScript。创建函数的时候，需要用到<code>FunctionTemplate</code>，首先根据要包装的C++函数（<code>sayHiTo</code>）创建函数模板，然后调用模板的<code>GetFunction()</code>方法便可获得一个函数句柄，设置完函数名后便可将其返回给JavaScript使用。这里需要注意，<code>sayHiTo</code>是一个C++函数，而且没有通过<code>module.exports</code>属性来提供给外部使用，而是通过返回函数的方式来给外部使用。</p><p><code>sayHiTo()</code>是一个C++函数，通过函数返回给JavaScript之后将被JavaScript调用，所以它在调用时也会收到参数<code>const FunctionCallbackInfo&lt;Value&gt;&amp; args</code>，跟之前通过<code>module.exports</code>暴露给JavaScript调用的方法一样，可以通过参数<code>args</code>来完成跟JavaScript的交互（参数传递、返回等）。</p><p>完成以上代码后，给<code>binding.gyp</code>的<code>targets</code>数组增加以下元素，然后进行编译构建生成<code>.node</code>文件。<br></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"target_name"</span>: <span class="string">"person"</span>,</span><br><span class="line">  <span class="attr">"sources"</span>: [<span class="string">"person.cc"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>完成编译构建之后就可以使用以下JavaScript代码进行实验，输出结果如图所示。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return-object demo</span></span><br><span class="line"><span class="keyword">const</span> Person = <span class="built_in">require</span>(<span class="string">'./build/Release/person'</span>)</span><br><span class="line"><span class="keyword">let</span> someone = Person.getPerson()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'[ReturnObjectDemo] '</span> + someone.firstname + someone.lastname)</span><br><span class="line"></span><br><span class="line"><span class="comment">// return-function demo</span></span><br><span class="line"><span class="keyword">let</span> sayHiTo = Person.getFunction()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'[ReturnFunctionDemo] '</span> + sayHiTo(someone))</span><br></pre></td></tr></table></figure><p></p><p><img src="/images/2018-04-16/4.png" alt="返回对象和函数示例"></p><h1 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h1><p>通过几个例子，大概了解如何编写NodeJS C++插件，也学会了如何处理一些常用场景，例如函数传参、回调、异常处理等。总体感觉编写C++插件实现C++和JavaScript的互相调用并不困难。主要的难点还是对V8的一些概念以及它所提供的API不熟悉，V8提供的很多API可以让我们方便地实现C++和JavaScript的互相调用，但由于对V8 API不够熟悉，编写过程中还是需要不断地查阅NodeJS和V8的官方文档。</p></div><footer class="article-footer"><a data-url="https://hongchh.github.io/2018/NodeJS-Cpp-Addons基础/" data-id="cjg6bhtba00243gti2m8ezo4p" class="article-share-link"><i class="fa fa-share"></i>分享到</a><script>!function(n){n("body").on("click",function(){n(".article-share-box.on").removeClass("on")}).on("click",".article-share-link",function(t){t.stopPropagation();var e,a=n(this),o=a.attr("data-url"),r=encodeURIComponent(o),i="article-share-box-"+a.attr("data-id"),s=a.offset();if(n("#"+i).length){if((e=n("#"+i)).hasClass("on"))return void e.removeClass("on")}else{var l=['<div id="'+i+'" class="article-share-box">','<input class="article-share-input" value="'+o+'">','<div class="article-share-links">','<a href="https://twitter.com/intent/tweet?url='+r+'" class="article-share-twitter" target="_blank" title="Twitter"></a>','<a href="https://www.facebook.com/sharer.php?u='+r+'" class="article-share-facebook" target="_blank" title="Facebook"></a>','<a href="http://pinterest.com/pin/create/button/?url='+r+'" class="article-share-pinterest" target="_blank" title="Pinterest"></a>','<a href="https://plus.google.com/share?url='+r+'" class="article-share-google" target="_blank" title="Google+"></a>',"</div>","</div>"].join("");e=n(l),n("body").append(e)}n(".article-share-box.on").hide(),e.css({top:s.top+25,left:s.left}).addClass("on")}).on("click",".article-share-box",function(t){t.stopPropagation()}).on("click",".article-share-box-input",function(){n(this).select()}).on("click",".article-share-box-link",function(t){t.preventDefault(),t.stopPropagation(),window.open(this.href,"article-share-box-window-"+Date.now(),"width=500,height=450")})}(jQuery)</script></footer></div></article><section id="comments"></section></div></section><aside id="sidebar"><a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a><div class="sidebar-top"><p>关注我 :</p><ul class="social-links"><li><a class="social-tooltip" title="github" href="https://github.com/hongchh" target="_blank"><i class="icon fa fa-github"></i></a></li></ul></div><nav id="article-nav"><a href="/2018/NodeJS-Cpp-Addons之C-类实例包装与异步操作/" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption">下一篇</strong><p class="article-nav-title">NodeJS C++ Addons之C++类实例包装与异步操作</p><i class="icon fa fa-chevron-right" id="icon-chevron-right"></i> </a><a href="/2018/试玩NodeJS多进程/" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">上一篇</strong><p class="article-nav-title">试玩NodeJS多进程</p><i class="icon fa fa-chevron-left" id="icon-chevron-left"></i></a></nav><div class="widgets-container"><div class="widget-wrap"><h3 class="widget-title">最新文章</h3><div class="widget"><ul id="recent-post"><li><div class="item-thumbnail"><a href="/2018/NodeJS-Cpp-Addons之C-类实例包装与异步操作/" class="thumbnail"><span style="background-image:url(/images/2018-04-19/1.png)" alt="NodeJS C++ Addons之C++类实例包装与异步操作" class="thumbnail-image"></span></a></div><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2018/NodeJS-Cpp-Addons之C-类实例包装与异步操作/" class="title">NodeJS C++ Addons之C++类实例包装与异步操作</a></p><p class="item-date"><time datetime="2018-04-19T09:20:27.000Z" itemprop="datePublished">2018-04-19</time></p></div></li><li><div class="item-thumbnail"><a href="/2018/NodeJS-Cpp-Addons基础/" class="thumbnail"><span style="background-image:url(/images/2018-04-16/1.png)" alt="NodeJS C++ Addons基础" class="thumbnail-image"></span></a></div><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2018/NodeJS-Cpp-Addons基础/" class="title">NodeJS C++ Addons基础</a></p><p class="item-date"><time datetime="2018-04-16T07:45:57.000Z" itemprop="datePublished">2018-04-16</time></p></div></li><li><div class="item-thumbnail"><a href="/2018/试玩NodeJS多进程/" class="thumbnail"><span style="background-image:url(/images/2018-04-11/master-worker.png)" alt="试玩NodeJS多进程" class="thumbnail-image"></span></a></div><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2018/试玩NodeJS多进程/" class="title">试玩NodeJS多进程</a></p><p class="item-date"><time datetime="2018-04-11T07:47:22.000Z" itemprop="datePublished">2018-04-11</time></p></div></li><li><div class="item-thumbnail"><a href="/2017/MonkeyEye电影售票系统-性能优化总结/" class="thumbnail"><span style="background-image:url(/images/2017-06-09-23.jpg)" alt="MonkeyEye电影售票系统-性能优化总结" class="thumbnail-image"></span></a></div><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2017/MonkeyEye电影售票系统-性能优化总结/" class="title">MonkeyEye电影售票系统-性能优化总结</a></p><p class="item-date"><time datetime="2017-06-09T07:43:09.000Z" itemprop="datePublished">2017-06-09</time></p></div></li><li><div class="item-thumbnail"><a href="/2017/MonkeyEye电影售票系统-前端技术要点总结/" class="thumbnail"><span style="background-image:url(/images/2017-06-09-5.jpg)" alt="MonkeyEye电影售票系统-前端技术要点总结" class="thumbnail-image"></span></a></div><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2017/MonkeyEye电影售票系统-前端技术要点总结/" class="title">MonkeyEye电影售票系统-前端技术要点总结</a></p><p class="item-date"><time datetime="2017-06-09T05:30:02.000Z" itemprop="datePublished">2017-06-09</time></p></div></li></ul></div></div><div class="widget-wrap widget-list"><h3 class="widget-title">归档</h3><div class="widget"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">1</span></li></ul></div></div><div class="widget-wrap widget-list"><h3 class="widget-title">标签</h3><div class="widget"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NodeJS/">NodeJS</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/其他/">其他</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机网络/">计算机网络</a><span class="tag-list-count">3</span></li></ul></div></div><div class="widget-wrap widget-float"><h3 class="widget-title">标签云</h3><div class="widget tagcloud"><a href="/tags/JavaScript/" style="font-size:20px">JavaScript</a> <a href="/tags/NodeJS/" style="font-size:16px">NodeJS</a> <a href="/tags/Web/" style="font-size:18px">Web</a> <a href="/tags/其他/" style="font-size:12px">其他</a> <a href="/tags/数据库/" style="font-size:10px">数据库</a> <a href="/tags/数据结构与算法/" style="font-size:18px">数据结构与算法</a> <a href="/tags/计算机网络/" style="font-size:14px">计算机网络</a></div></div><div class="widget-wrap widget-list"><h3 class="widget-title">链接</h3><div class="widget"><ul><li><a href="http://blog.csdn.net/hongchh">CSDN</a></li></ul></div></div></div></aside></div></div></div><footer id="footer"><div class="container"><div class="container-inner"><a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a><div class="credit"><h1 class="logo-wrap"><a href="/" class="logo"></a></h1><p>&copy; 2018 洪创煌(hongchh_sysu@qq.com)</p><p>Powered by <a href="//hexo.io/" target="_blank">Hexo</a>. Theme by <a href="//github.com/ppoffice" target="_blank">PPOffice</a></p></div></div></div></footer><script src="/libs/lightgallery/js/lightgallery.min.js"></script><script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script><script src="/libs/lightgallery/js/lg-pager.min.js"></script><script src="/libs/lightgallery/js/lg-autoplay.min.js"></script><script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script><script src="/libs/lightgallery/js/lg-zoom.min.js"></script><script src="/libs/lightgallery/js/lg-hash.min.js"></script><script src="/libs/lightgallery/js/lg-share.min.js"></script><script src="/libs/lightgallery/js/lg-video.min.js"></script><script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="/js/main.js"></script></div></body>