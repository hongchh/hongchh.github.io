<!DOCTYPE html><html><head><meta charset="utf-8"><title>NodeJS C++ Addons之C++类实例包装与异步操作 | 洪创煌的博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="NodeJS"><meta name="description" content="本文是对NodeJS C++ Addons原生写法的进一步探索，介绍了利用原生的Node和V8提供的API实现类包装和异步调用的具体做法。在阅读本文之前，如果对NodeJS C++ Addons的基础不熟悉的话，建议先阅读上一篇博客【NodeJS C++ Addons基础】进行了解之后再回来阅读本文。本文所使用的代码示例可以从该仓库中找到–【cpp-addons】备注： 本文旨在探究NodeJS"><meta name="keywords" content="NodeJS"><meta property="og:type" content="article"><meta property="og:title" content="NodeJS C++ Addons之C++类实例包装与异步操作"><meta property="og:url" content="https://hongchh.github.io/2018/NodeJS-Cpp-Addons之C-类实例包装与异步操作/index.html"><meta property="og:site_name" content="洪创煌的博客"><meta property="og:description" content="本文是对NodeJS C++ Addons原生写法的进一步探索，介绍了利用原生的Node和V8提供的API实现类包装和异步调用的具体做法。在阅读本文之前，如果对NodeJS C++ Addons的基础不熟悉的话，建议先阅读上一篇博客【NodeJS C++ Addons基础】进行了解之后再回来阅读本文。本文所使用的代码示例可以从该仓库中找到–【cpp-addons】备注： 本文旨在探究NodeJS"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://hongchh.github.io/images/2018-04-19/1.png"><meta property="og:updated_time" content="2018-04-19T09:25:03.030Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="NodeJS C++ Addons之C++类实例包装与异步操作"><meta name="twitter:description" content="本文是对NodeJS C++ Addons原生写法的进一步探索，介绍了利用原生的Node和V8提供的API实现类包装和异步调用的具体做法。在阅读本文之前，如果对NodeJS C++ Addons的基础不熟悉的话，建议先阅读上一篇博客【NodeJS C++ Addons基础】进行了解之后再回来阅读本文。本文所使用的代码示例可以从该仓库中找到–【cpp-addons】备注： 本文旨在探究NodeJS"><meta name="twitter:image" content="https://hongchh.github.io/images/2018-04-19/1.png"><link rel="icon" href="/css/images/favicon.png"><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/libs/titillium-web/styles.css"><link rel="stylesheet" href="/libs/source-code-pro/styles.css"><link rel="stylesheet" href="/css/style.css"><script src="/libs/jquery/2.0.3/jquery.min.js"></script><link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css"><link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css"><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script></head></html><body><div id="wrap"><header id="header"><div id="header-outer" class="outer"><div class="container"><div class="container-inner"><div id="header-title"><h1 class="logo-wrap"><a href="/" class="logo"></a></h1><h2 class="subtitle-wrap"><p class="subtitle">生命是一场练习！</p></h2></div><div id="header-inner" class="nav-container"><a id="main-nav-toggle" class="nav-icon fa fa-bars"></a><div class="nav-container-inner"><ul id="main-nav"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/">主页</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/about/index.html">关于</a></li></ul><nav id="sub-nav"><div id="search-form-wrap"><form class="search-form"><input type="text" class="ins-search-input search-form-input" placeholder="搜索"> <button type="submit" class="search-form-submit"></button></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="想要查找什么..."> <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(未命名)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script></div></nav></div></div></div></div></div></header><div class="container"><div class="main-body container-inner"><div class="main-body-inner"><section id="main"><div class="main-body-header"><h1 class="header">未分类</h1></div><div class="main-body-content"><article id="post-NodeJS-Cpp-Addons之C-类实例包装与异步操作" class="article article-single article-type-post" itemscope itemprop="blogPost"><div class="article-inner"><header class="article-header"><h1 class="article-title" itemprop="name">NodeJS C++ Addons之C++类实例包装与异步操作</h1></header><div class="article-meta"><div class="article-date"><a href="/2018/NodeJS-Cpp-Addons之C-类实例包装与异步操作/" class="article-date"><time datetime="2018-04-19T09:20:27.000Z" itemprop="datePublished">2018-04-19</time></a></div><div class="article-tag"><i class="fa fa-tag"></i> <a class="tag-link" href="/tags/NodeJS/">NodeJS</a></div></div><div class="article-entry" itemprop="articleBody"><p>本文是对NodeJS C++ Addons原生写法的进一步探索，介绍了利用原生的Node和V8提供的API实现类包装和异步调用的具体做法。在阅读本文之前，如果对NodeJS C++ Addons的基础不熟悉的话，建议先阅读上一篇博客<a href="https://hongchh.github.io/2018/NodeJS-Cpp-Addons%E5%9F%BA%E7%A1%80/">【NodeJS C++ Addons基础】</a>进行了解之后再回来阅读本文。</p><p>本文所使用的代码示例可以从该仓库中找到–<a href="https://github.com/hongchh/nodejs-demo/tree/master/cpp-addons" target="_blank" rel="external">【cpp-addons】</a></p><p><strong>备注：</strong> 本文旨在探究NodeJS C++ Addons的原生写法，了解部分底层知识，所使用的NodeJS版本为8.11.1，由于V8原生的API会发生变动，不同版本的NodeJS的支持情况可能不同。因此不保证代码能兼容所有版本的NodeJS。</p><h1 id="一、C-类和对象实例的包装"><a href="#一、C-类和对象实例的包装" class="headerlink" title="一、C++类和对象实例的包装"></a>一、C++类和对象实例的包装</h1><p>NodeJS C++插件除了可以向JavaScript提供函数接口之外，还可以将一些C++类或者C++对象实例包装后直接提供给JavaScript使用。举个例子，假设有个用C++实现的类，类名为<code>SomeClass</code>，现在想要在JavaScript中直接使用该类，通过<code>new SomeClass(...)</code>直接创建该类的实例并进行使用。</p><p>接下来将使用一个简单的例子来说明如何进行C++类和对象的包装。在这个例子中，将实现一个C++类<code>Accumulator</code>，该类是一个累加器，提供<code>add()</code>和<code>getAddTimes()</code>两个方法，<code>add()</code>方法用于将参数累加并返回当前的累加值，<code>getAddTimes()</code>则是返回当前的累加次数。在创建<code>Accumulator</code>实例的时候，可以指定累加开始的初始值。最后，我们期望实现的效果如下，可以在JavaScript中使用这个C++类并创建该类的实例，并且可以调用该类上定义的方法。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpp-object-wrap demo</span></span><br><span class="line"><span class="keyword">const</span> AccumulatorModule = <span class="built_in">require</span>(<span class="string">'./build/Release/Accumulator'</span>)</span><br><span class="line"><span class="keyword">let</span> acc = <span class="keyword">new</span> AccumulatorModule.Accumulator(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'[ObjectWrapDemo] 2 + 12 = '</span> + acc.add(<span class="number">12</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'[ObjectWrapDemo] 2 + 12 + 5 = '</span> + acc.add(<span class="number">5</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'[ObjectWrapDemo] add times: '</span> + acc.getAddTimes())</span><br></pre></td></tr></table></figure><p></p><p>在C++中，<code>Accumulator</code>是一个通过<code>class</code>关键字定义的普通类，而在JavaScript中，一个类即为一个JS函数。在C++中，<code>Accumulator</code>的实例是一个普通的C++类实例，在JavaScript中，一个实例即为一个JS对象。JS函数在V8中对应的是一个<code>v8::Function</code>实例，JS对象在V8中对应的是一个<code>v8::Object</code>实例，因此，包装要做的事情，便是将一个<code>C++类</code>包装成一个<code>v8::Function</code>实例，将一个<code>C++实例对象</code>包装成一个<code>v8::Object</code>实例，然后提供给JavaScript使用。下面是该C++插件的实现源码，注释包含了对包装过程的介绍。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node_object_wrap.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> CppObjectWrapDemo &#123;</span><br><span class="line">  <span class="keyword">using</span> v8::Context;</span><br><span class="line">  <span class="keyword">using</span> v8::Function;</span><br><span class="line">  <span class="keyword">using</span> v8::FunctionCallbackInfo;</span><br><span class="line">  <span class="keyword">using</span> v8::FunctionTemplate;</span><br><span class="line">  <span class="keyword">using</span> v8::Isolate;</span><br><span class="line">  <span class="keyword">using</span> v8::Local;</span><br><span class="line">  <span class="keyword">using</span> v8::Number;</span><br><span class="line">  <span class="keyword">using</span> v8::Object;</span><br><span class="line">  <span class="keyword">using</span> v8::Persistent;</span><br><span class="line">  <span class="keyword">using</span> v8::String;</span><br><span class="line">  <span class="keyword">using</span> v8::Value;</span><br><span class="line">  <span class="keyword">using</span> v8::Exception;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将C++类封装给JS使用，需要继承node::ObjectWrap */</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Accumulator</span> :</span> <span class="keyword">public</span> node::ObjectWrap &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">/* 初始化该类的JS构造函数，并返回JS构造函数 */</span></span><br><span class="line">      <span class="keyword">static</span> Local&lt;Function&gt; init (Isolate* isolate) &#123;</span><br><span class="line">        <span class="comment">/* 利用函数模板，将一个C++函数包装成JS函数 */</span></span><br><span class="line">        Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(isolate, AccumulatorJS);</span><br><span class="line">        tpl-&gt;SetClassName(String::NewFromUtf8(isolate, <span class="string">"Accumulator"</span>));</span><br><span class="line">        tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* 类方法定义在构造函数的prototype上 */</span></span><br><span class="line">        NODE_SET_PROTOTYPE_METHOD(tpl, <span class="string">"add"</span>, add);</span><br><span class="line">        NODE_SET_PROTOTYPE_METHOD(tpl, <span class="string">"getAddTimes"</span>, getAddTimes);</span><br><span class="line">        <span class="comment">/* 获取Accumulator类的JS构造函数 */</span></span><br><span class="line">        Local&lt;Function&gt; fn = tpl-&gt;GetFunction();</span><br><span class="line">        <span class="comment">/* JS构造函数句柄存储于constructor上，后续还会使用到 */</span></span><br><span class="line">        constructor.Reset(isolate, fn);</span><br><span class="line">        <span class="keyword">return</span> fn;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="comment">/* 成员变量 */</span></span><br><span class="line">      <span class="keyword">static</span> Persistent&lt;Function&gt; constructor;</span><br><span class="line">      <span class="keyword">double</span> value;</span><br><span class="line">      <span class="keyword">int</span> addTimes;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 该类的C++构造函数，设置成员变量初始值 */</span></span><br><span class="line">      <span class="function"><span class="keyword">explicit</span> <span class="title">Accumulator</span> <span class="params">(<span class="keyword">double</span> initValue = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = initValue;</span><br><span class="line">        <span class="keyword">this</span>-&gt;addTimes = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 该类的JS构造函数，创建该类的对象，并包装成JS对象然后进行返回 */</span></span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AccumulatorJS</span> <span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">        Isolate* isolate = args.GetIsolate();</span><br><span class="line">        <span class="keyword">if</span> (args.IsConstructCall()) &#123;<span class="comment">/* 通过 new Accumulator() 创建对象 */</span></span><br><span class="line">          <span class="comment">/* 提取参数数值 */</span></span><br><span class="line">          <span class="keyword">double</span> val = args[<span class="number">0</span>]-&gt;IsUndefined() ? <span class="number">0</span> : args[<span class="number">0</span>]-&gt;NumberValue();</span><br><span class="line">          <span class="comment">/* 创建该类的实例对象 */</span></span><br><span class="line">          Accumulator* obj = <span class="keyword">new</span> Accumulator(val);</span><br><span class="line">          <span class="comment">/* 包装该对象 */</span></span><br><span class="line">          obj-&gt;Wrap(args.This());</span><br><span class="line">          <span class="comment">/* 返回该对象 */</span></span><br><span class="line">          args.GetReturnValue().Set(args.This());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">/* 通过直接调用函数 Accumulator() 创建对象，抛出异常 */</span></span><br><span class="line">          isolate-&gt;ThrowException(Exception::TypeError(</span><br><span class="line">            String::NewFromUtf8(isolate, <span class="string">"Should use the new operator to create an instance."</span>)</span><br><span class="line">          ));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 该类的成员方法，增加value的值 */</span></span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">        Isolate* isolate = args.GetIsolate();</span><br><span class="line">        <span class="comment">/* 将被包装的JS对象还原为C++对象 */</span></span><br><span class="line">        Accumulator* obj = node::ObjectWrap::Unwrap&lt;Accumulator&gt;(args.Holder());</span><br><span class="line">        <span class="comment">/* 访问C++对象上的成员变量进行操作 */</span></span><br><span class="line">        obj-&gt;value += args[<span class="number">0</span>]-&gt;NumberValue();</span><br><span class="line">        obj-&gt;addTimes += <span class="number">1</span>;</span><br><span class="line">        args.GetReturnValue().Set(Number::New(isolate, obj-&gt;value));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 该类的成员方法，获取累加次数 */</span></span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAddTimes</span> <span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">        Isolate* isolate = args.GetIsolate();</span><br><span class="line">        <span class="comment">/* 将被包装的JS对象还原为C++对象 */</span></span><br><span class="line">        Accumulator* obj = node::ObjectWrap::Unwrap&lt;Accumulator&gt;(args.Holder());</span><br><span class="line">        args.GetReturnValue().Set(Number::New(isolate, obj-&gt;addTimes));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Persistent&lt;Function&gt; Accumulator::constructor;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">(Local&lt;Object&gt; exports)</span> </span>&#123;</span><br><span class="line">    Isolate* isolate = exports-&gt;GetIsolate();</span><br><span class="line">    <span class="comment">/* 初始化Accumulator类的JS构造函数 */</span></span><br><span class="line">    Local&lt;Function&gt; _Accumulator = Accumulator::init(isolate);</span><br><span class="line">    <span class="comment">/* 将Accumulator类的JS构造函数暴露给JS使用 */</span></span><br><span class="line">    <span class="comment">/* 这里不能使用NODE_SET_METHOD，因为NODE_SET_METHOD是暴露一个C++函数给JS使用 */</span></span><br><span class="line">    <span class="comment">/* NODE_SET_METHOD(exports, "Accumulator", _Accumulator); */</span></span><br><span class="line">    <span class="comment">/* 此处是暴露一个JS函数，它在C++里面表示为一个Function对象，不是一个C++函数 */</span></span><br><span class="line">    <span class="comment">/* 要通过设置属性的方法将其挂到exports上 */</span></span><br><span class="line">    exports-&gt;Set(String::NewFromUtf8(isolate, <span class="string">"Accumulator"</span>), _Accumulator);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  NODE_MODULE(NODE_GYP_MODULE_NAME, init)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>进行C++类包装，需要引入头文件<code>&lt;node_object_wrap.h&gt;</code>，被包装的类需要继承<code>node::ObjectWrap</code>类。被包装的C++类除了拥有自己的C++构造函数之外，还需要有一个JS构造函数，C++构造函数在创建该类的C++实例的时候会被调用，而JS构造函数则是在JavaScript中创建该类的对象的时候会被调用。在JS构造函数中写好当JS创建C++类实例的时候要进行的操作，然后将该JS构造函数包装成一个<code>v8::Function</code>提供给JavaScript使用。以上面代码为例，<code>AccumulatorJS</code>是该类的JS构造函数，在<code>AccumulatorJS</code>执行的时候，会创建一个C++类实例，然后将该实例包装变成一个<code>v8::Object</code>之后返回。<code>AccumulatorJS</code>本身是一个C++函数，为了能在JS中调用到它，需要先在<code>Accumulator::init</code>方法利用<code>FunctionTemplate</code>根据<code>AccumulatorJS</code>定制出一个JS函数。</p><p>在JS中，使用函数来实现类，类的成员方法一般定义在构造函数的原型（<code>prototype</code>）上。在<code>Accumulator::init</code>方法中，使用<code>NODE_SET_PROTOTYPE_METHOD</code>来将C++类的成员方法挂到JS构造函数的原型上。这样做以后，在JS中创建出该类的实例后，便可以调用到这些成员方法了。</p><p>该类的成员方法<code>add()</code>和<code>getAddTimes()</code>会在JS中被调用，所以在调用时也会得到<code>const FunctionCallbackInfo&lt;Value&gt;&amp; args</code>参数。可以通过<code>args</code>参数来进行获取JS传递过来的参数信息以及设置返回值等操作。由于在这两个成员方法中，需要访问到类实例上成员变量，因此需要先将发起调用的JS对象解包装，还原成C++实例。解包装时候会用到<code>node::ObjectWrap::Unwrap&lt;Accumulator&gt;(args.Holder())</code>，<code>args.Holder()</code>可以获取到发起调用的JS对象实例。</p><p>实现了类和对象实例的包装以后，便可以将相关接口暴露给JS使用了。跟其他C++插件模块一样，也是通过<code>module.exports</code>属性来暴露相关接口。这里需要注意的点在代码注释中也有说明，由于我们暴露给JS使用的东西是一个JS构造函数，而不是普通的C++函数，所以不能使用<code>NODE_SET_METHOD</code>来设置暴露的内容，而是直接通过<code>exports</code>对象的<code>Set()</code>方法来进行设置。</p><p>完成之后将下面内容写入<code>binding.gyp</code>，进行编译构建，得到<code>.node</code>文件后便可以利用前面展示的JS代码去进行测试了。JS代码运行后的输出结果如图所示，可以验证通过类和对象实例的包装，JS能够直接使用C++的类和实例。<br></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"targets"</span>: [&#123;</span><br><span class="line">    <span class="attr">"target_name"</span>: <span class="string">"accumulator"</span>,</span><br><span class="line">    <span class="attr">"sources"</span>: [<span class="string">"accumulator.cc"</span>]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><img src="/images/2018-04-19/1.png" alt="C++类和对象包装实例"></p><h1 id="二、C-类实例工厂"><a href="#二、C-类实例工厂" class="headerlink" title="二、C++类实例工厂"></a>二、C++类实例工厂</h1><p>前面展示了如何将一个C++类进行包装然后暴露给JavaScript使用。在使用过程中，JavaScript能够直接通过<code>new</code>操作符来创建该类的实例。现在，我们希望C++模块能够提供一个工厂函数，JavaScript调用该工厂函数之后也可以获取到该C++类的实例，而不需要通过<code>new</code>操作符来创建实例。继续在前面的<code>Accumulator</code>例子上进行改进，以探索实现C++向JavaScript提供类实例工厂函数的方法。</p><p>给<code>Accumulator</code>增加<code>getInstance()</code>方法，通过<code>Accumulator::getInstance()</code>方法，可以在C++代码里面主动调用<code>Accumulator</code>类的JS构造函数，从而创建一个类实例并将类实例包装成JS对象，达到与在JS中使用<code>new</code>操作符时同样的目的。下面是代码展示，部分操作在注释中有进行说明。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node_object_wrap.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> CppObjectWrapDemo &#123;</span><br><span class="line">  <span class="keyword">using</span> v8::Context;</span><br><span class="line">  <span class="keyword">using</span> v8::Function;</span><br><span class="line">  <span class="keyword">using</span> v8::FunctionCallbackInfo;</span><br><span class="line">  <span class="keyword">using</span> v8::FunctionTemplate;</span><br><span class="line">  <span class="keyword">using</span> v8::Isolate;</span><br><span class="line">  <span class="keyword">using</span> v8::Local;</span><br><span class="line">  <span class="keyword">using</span> v8::Number;</span><br><span class="line">  <span class="keyword">using</span> v8::Object;</span><br><span class="line">  <span class="keyword">using</span> v8::Persistent;</span><br><span class="line">  <span class="keyword">using</span> v8::String;</span><br><span class="line">  <span class="keyword">using</span> v8::Value;</span><br><span class="line">  <span class="keyword">using</span> v8::Exception;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将C++类封装给JS使用，需要继承node::ObjectWrap */</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Accumulator</span> :</span> <span class="keyword">public</span> node::ObjectWrap &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">/* 初始化该类的JS构造函数，并返回JS构造函数 */</span></span><br><span class="line">      <span class="keyword">static</span> Local&lt;Function&gt; init (Isolate* isolate) &#123;</span><br><span class="line">        <span class="comment">/* 利用函数模板，将一个C++函数包装成JS函数 */</span></span><br><span class="line">        Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(isolate, AccumulatorJS);</span><br><span class="line">        tpl-&gt;SetClassName(String::NewFromUtf8(isolate, <span class="string">"Accumulator"</span>));</span><br><span class="line">        tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* 类方法定义在构造函数的prototype上 */</span></span><br><span class="line">        NODE_SET_PROTOTYPE_METHOD(tpl, <span class="string">"add"</span>, add);</span><br><span class="line">        NODE_SET_PROTOTYPE_METHOD(tpl, <span class="string">"getAddTimes"</span>, getAddTimes);</span><br><span class="line">        <span class="comment">/* 获取Accumulator类的JS构造函数 */</span></span><br><span class="line">        Local&lt;Function&gt; fn = tpl-&gt;GetFunction();</span><br><span class="line">        <span class="comment">/* JS构造函数句柄存储于constructor上，后续还会使用到 */</span></span><br><span class="line">        constructor.Reset(isolate, fn);</span><br><span class="line">        <span class="keyword">return</span> fn;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 获取该类实例的工厂函数 */</span></span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getInstance</span> <span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">        Isolate* isolate = args.GetIsolate();</span><br><span class="line">        Local&lt;Value&gt; argv[<span class="number">1</span>] = &#123; args[<span class="number">0</span>] &#125;;</span><br><span class="line">        <span class="comment">/* 获取当前上下文 */</span></span><br><span class="line">        Local&lt;Context&gt; context = isolate-&gt;GetCurrentContext();</span><br><span class="line">        <span class="comment">/* 生成JS构造函数 */</span></span><br><span class="line">        Local&lt;Function&gt; _constructor = Local&lt;Function&gt;::New(isolate, constructor);</span><br><span class="line">        <span class="comment">/* 创建实例 */</span></span><br><span class="line">        Local&lt;Object&gt; obj = _constructor-&gt;NewInstance(context, <span class="number">1</span>, argv).ToLocalChecked();</span><br><span class="line">        <span class="comment">/* 返回实例 */</span></span><br><span class="line">        args.GetReturnValue().Set(obj);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="comment">/* 成员变量 */</span></span><br><span class="line">      <span class="keyword">static</span> Persistent&lt;Function&gt; constructor;</span><br><span class="line">      <span class="keyword">double</span> value;</span><br><span class="line">      <span class="keyword">int</span> addTimes;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 该类的C++构造函数，设置成员变量初始值 */</span></span><br><span class="line">      <span class="function"><span class="keyword">explicit</span> <span class="title">Accumulator</span> <span class="params">(<span class="keyword">double</span> initValue = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = initValue;</span><br><span class="line">        <span class="keyword">this</span>-&gt;addTimes = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 该类的JS构造函数，创建该类的对象，并包装成JS对象然后进行返回 */</span></span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AccumulatorJS</span> <span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">        Isolate* isolate = args.GetIsolate();</span><br><span class="line">        <span class="keyword">if</span> (args.IsConstructCall()) &#123;<span class="comment">/* 通过 new Accumulator() 创建对象 */</span></span><br><span class="line">          <span class="comment">/* 提取参数数值 */</span></span><br><span class="line">          <span class="keyword">double</span> val = args[<span class="number">0</span>]-&gt;IsUndefined() ? <span class="number">0</span> : args[<span class="number">0</span>]-&gt;NumberValue();</span><br><span class="line">          <span class="comment">/* 创建该类的实例对象 */</span></span><br><span class="line">          Accumulator* obj = <span class="keyword">new</span> Accumulator(val);</span><br><span class="line">          <span class="comment">/* 包装该对象 */</span></span><br><span class="line">          obj-&gt;Wrap(args.This());</span><br><span class="line">          <span class="comment">/* 返回该对象 */</span></span><br><span class="line">          args.GetReturnValue().Set(args.This());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">/* 通过直接调用函数 Accumulator() 创建对象，抛出异常 */</span></span><br><span class="line">          isolate-&gt;ThrowException(Exception::TypeError(</span><br><span class="line">            String::NewFromUtf8(isolate, <span class="string">"Should use the new operator to create an instance."</span>)</span><br><span class="line">          ));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 该类的成员方法，增加value的值 */</span></span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">        Isolate* isolate = args.GetIsolate();</span><br><span class="line">        <span class="comment">/* 将被包装的JS对象还原为C++对象 */</span></span><br><span class="line">        Accumulator* obj = node::ObjectWrap::Unwrap&lt;Accumulator&gt;(args.Holder());</span><br><span class="line">        <span class="comment">/* 访问C++对象上的成员变量进行操作 */</span></span><br><span class="line">        obj-&gt;value += args[<span class="number">0</span>]-&gt;NumberValue();</span><br><span class="line">        obj-&gt;addTimes += <span class="number">1</span>;</span><br><span class="line">        args.GetReturnValue().Set(Number::New(isolate, obj-&gt;value));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 该类的成员方法，获取累加次数 */</span></span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAddTimes</span> <span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">        Isolate* isolate = args.GetIsolate();</span><br><span class="line">        <span class="comment">/* 将被包装的JS对象还原为C++对象 */</span></span><br><span class="line">        Accumulator* obj = node::ObjectWrap::Unwrap&lt;Accumulator&gt;(args.Holder());</span><br><span class="line">        args.GetReturnValue().Set(Number::New(isolate, obj-&gt;addTimes));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Persistent&lt;Function&gt; Accumulator::constructor;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">getAccumulatorInstance</span><span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    Accumulator::getInstance(args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">(Local&lt;Object&gt; exports)</span> </span>&#123;</span><br><span class="line">    Isolate* isolate = exports-&gt;GetIsolate();</span><br><span class="line">    <span class="comment">/* 初始化Accumulator类的JS构造函数 */</span></span><br><span class="line">    Local&lt;Function&gt; _Accumulator = Accumulator::init(isolate);</span><br><span class="line">    <span class="comment">/* 将Accumulator类的JS构造函数暴露给JS使用 */</span></span><br><span class="line">    <span class="comment">/* 这里不能使用NODE_SET_METHOD，因为NODE_SET_METHOD是暴露一个C++函数给JS使用 */</span></span><br><span class="line">    <span class="comment">/* NODE_SET_METHOD(exports, "Accumulator", _Accumulator); */</span></span><br><span class="line">    <span class="comment">/* 此处是暴露一个JS函数，它在C++里面表示为一个Function对象，不是一个C++函数 */</span></span><br><span class="line">    <span class="comment">/* 要通过设置属性的方法将其挂到exports上 */</span></span><br><span class="line">    exports-&gt;Set(String::NewFromUtf8(isolate, <span class="string">"Accumulator"</span>), _Accumulator);</span><br><span class="line">    <span class="comment">/* 将获取实例的工厂方法暴露给JS */</span></span><br><span class="line">    NODE_SET_METHOD(exports, <span class="string">"getAccumulatorInstance"</span>, getAccumulatorInstance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  NODE_MODULE(NODE_GYP_MODULE_NAME, init)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>Accumulator::getInstance()</code>方法中，利用<code>_constructor</code>的<code>NewInstance()</code>方法可以创建一个实例，执行该方法的作用相当于JS中使用<code>new</code>操作符时候的作用，也会调用对应的JS构造函数，从而创建出该类的实例并包装成一个JS对象进行返回。</p><p><code>Accumulator::getInstance()</code>方法在C++中调用，为了将其暴露给JavaScript使用，在最后还需要创建一个<code>getAccumulatorInstance()</code>函数，在这个函数里面完成对<code>Accumulator::getInstance()</code>的调用。将<code>getAccumulatorInstance()</code>挂到<code>exports</code>属性上后便可提供给JavaScript使用了。</p><p>可使用下面的JS代码对C++模块进行检验，代码输出如图所示。JavaScript能够调用C++模块提供的工厂函数，从而获得一个C++类的实例并且可以对该实例进行使用，调用该类所定义的成员方法。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpp-object-wrap-factory demo</span></span><br><span class="line"><span class="keyword">const</span> AccumulatorModule = <span class="built_in">require</span>(<span class="string">'./build/Release/Accumulator'</span>)</span><br><span class="line"><span class="keyword">let</span> acc2 = AccumulatorModule.getAccumulatorInstance(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'[ObjectWrapFactoryDemo] 3 + 16 = '</span> + acc2.add(<span class="number">16</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'[ObjectWrapFactoryDemo] 3 + 16 + 7 = '</span> + acc2.add(<span class="number">7</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'[ObjectWrapFactoryDemo] 3 + 16 + 7 + 4 = '</span> + acc2.add(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'[ObjectWrapFactoryDemo] add times: '</span> + acc2.getAddTimes())</span><br></pre></td></tr></table></figure><p></p><p><img src="/images/2018-04-19/2.png" alt="C++类实例工厂实例"></p><h1 id="三、异步操作"><a href="#三、异步操作" class="headerlink" title="三、异步操作"></a>三、异步操作</h1><p>NodeJS C++插件可以提供接口给JavaScript使用，在上一篇博客<a href="https://hongchh.github.io/2018/NodeJS-Cpp-Addons%E5%9F%BA%E7%A1%80/">【NodeJS C++ Addons基础】</a>也已经给出不少示例。不过，在之前的示例中，实现的都是同步调用。按照之前的做法，JavaScript调用C++插件模块提供的接口后，会阻塞JavaScript代码的执行。同步调用带来的阻塞不符合JavaScript异步的特点，在遇到复杂耗时的任务时，这种阻塞更是严重影响应用的性能。为了解决这个问题，就需要实现异步调用，使得C++插件模块的接口在被调用后不会阻塞JavaScript的执行。</p><p>实现异步操作需要用到<code>libuv</code>这个库，<code>libuv</code>是一个跨平台的抽象库，它实现了Node.js的事件循环、工作线程、以及平台所有的的异步操作。利用<code>libuv</code>可以很方便地让C++插件模块的接口异步化。接下来将对上一篇博客<a href="https://hongchh.github.io/2018/NodeJS-Cpp-Addons%E5%9F%BA%E7%A1%80/">【NodeJS C++ Addons基础】</a>中的使用的累加求和的例子进行改进，实现异步调用。下面是改进后的代码，在注释中会对部分操作进行阐述。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;uv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> AsyncDemo &#123;</span><br><span class="line">  <span class="keyword">using</span> v8::Function;</span><br><span class="line">  <span class="keyword">using</span> v8::FunctionCallbackInfo;</span><br><span class="line">  <span class="keyword">using</span> v8::Isolate;</span><br><span class="line">  <span class="keyword">using</span> v8::Local;</span><br><span class="line">  <span class="keyword">using</span> v8::Number;</span><br><span class="line">  <span class="keyword">using</span> v8::Object;</span><br><span class="line">  <span class="keyword">using</span> v8::Value;</span><br><span class="line">  <span class="keyword">using</span> v8::Null;</span><br><span class="line">  <span class="keyword">using</span> v8::Exception;</span><br><span class="line">  <span class="keyword">using</span> v8::String;</span><br><span class="line">  <span class="keyword">using</span> v8::Undefined;</span><br><span class="line">  <span class="keyword">using</span> v8::Persistent;</span><br><span class="line">  <span class="keyword">using</span> v8::HandleScope;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 存放数据供子线程使用的结构体 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 回调函数 */</span></span><br><span class="line">    Persistent&lt;Function&gt; callback;</span><br><span class="line">    <span class="comment">/* 求和参数 */</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; args;</span><br><span class="line">    <span class="comment">/* 求和结果 */</span></span><br><span class="line">    <span class="keyword">double</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 子线程执行的代码 */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">calculate</span> <span class="params">(<span class="keyword">uv_work_t</span>* req)</span> </span>&#123;</span><br><span class="line">    Data* data = <span class="keyword">static_cast</span>&lt;Data*&gt;(req-&gt;data);</span><br><span class="line">    <span class="comment">/* 遍历参数进行求和 */</span></span><br><span class="line">    data-&gt;result = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data-&gt;args.size(); ++i) &#123;</span><br><span class="line">      data-&gt;result += data-&gt;args[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 子线程结束后执行的代码 */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">calculateComplete</span> <span class="params">(<span class="keyword">uv_work_t</span>* req)</span> </span>&#123;</span><br><span class="line">    Data* data = <span class="keyword">static_cast</span>&lt;Data*&gt;(req-&gt;data);</span><br><span class="line">    Isolate* isolate = Isolate::GetCurrent();</span><br><span class="line">    <span class="comment">/* 必须创建一个HandleScope，否则后面无法创建句柄 */</span></span><br><span class="line">    <span class="function">HandleScope <span class="title">handleScope</span><span class="params">(isolate)</span></span>;</span><br><span class="line">    <span class="comment">/* 将求和结果转换为一个JS Number */</span></span><br><span class="line">    Local&lt;Value&gt; argv[<span class="number">1</span>] = &#123; Number::New(isolate, data-&gt;result) &#125;;</span><br><span class="line">    <span class="comment">/* 通过回调函数返回求和结果 */</span></span><br><span class="line">    Local&lt;Function&gt; cb = Local&lt;Function&gt;::New(isolate, data-&gt;callback);</span><br><span class="line">    cb-&gt;Call(Null(isolate), <span class="number">1</span>, argv);</span><br><span class="line">    <span class="comment">/* 回调完成后清除资源 */</span></span><br><span class="line">    data-&gt;callback.Reset();</span><br><span class="line">    <span class="keyword">delete</span> data;</span><br><span class="line">    <span class="keyword">delete</span> req;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">accumulateAsync</span> <span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    Isolate* isolate = args.GetIsolate();</span><br><span class="line">    <span class="comment">/* 参数不合理异常 */</span></span><br><span class="line">    <span class="keyword">if</span> (args.Length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      isolate-&gt;ThrowException(Exception::TypeError(</span><br><span class="line">        String::NewFromUtf8(isolate, <span class="string">"Arguments Number Error."</span>)</span><br><span class="line">      ));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 没有回调函数 */</span></span><br><span class="line">    <span class="keyword">if</span> (!args[args.Length() - <span class="number">1</span>]-&gt;IsFunction()) &#123;</span><br><span class="line">      isolate-&gt;ThrowException(Exception::TypeError(</span><br><span class="line">        String::NewFromUtf8(isolate, <span class="string">"No Callback Error."</span>)</span><br><span class="line">      ));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 提取通过参数传递的回调函数 */</span></span><br><span class="line">    Local&lt;Function&gt; callback = Local&lt;Function&gt;::Cast(args[args.Length() - <span class="number">1</span>]);</span><br><span class="line">    <span class="comment">/* 创建Data结构体存储数据 */</span></span><br><span class="line">    Data* data = <span class="keyword">new</span> Data();</span><br><span class="line">    <span class="comment">/* 存储回调函数 */</span></span><br><span class="line">    data-&gt;callback.Reset(isolate, callback);</span><br><span class="line">    <span class="comment">/* 提取参数并存储到data */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.Length() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">      <span class="comment">/* 如果参数不是数字，向js抛出异常 */</span></span><br><span class="line">      <span class="keyword">if</span> (!args[i]-&gt;IsNumber()) &#123;</span><br><span class="line">        isolate-&gt;ThrowException(Exception::TypeError(</span><br><span class="line">          String::NewFromUtf8(isolate, <span class="string">"Arguments Type Error."</span>)</span><br><span class="line">        ));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        data-&gt;args.push_back(args[i]-&gt;NumberValue());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 启动工作线程进行求和计算 */</span></span><br><span class="line">    <span class="keyword">uv_work_t</span> *req = <span class="keyword">new</span> <span class="keyword">uv_work_t</span>();</span><br><span class="line">    req-&gt;data = data;</span><br><span class="line">    uv_queue_work(</span><br><span class="line">      uv_default_loop(),</span><br><span class="line">      req,</span><br><span class="line">      (uv_work_cb)calculate,</span><br><span class="line">      (uv_after_work_cb)calculateComplete</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 本函数直接返回，无需等待线程计算完成 */</span></span><br><span class="line">    args.GetReturnValue().Set(Undefined(isolate));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">(Local&lt;Object&gt; exports)</span> </span>&#123;</span><br><span class="line">    NODE_SET_METHOD(exports, <span class="string">"accumulateAsync"</span>, accumulateAsync);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  NODE_MODULE(NODE_GYP_MODULE_NAME, init)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>使用<code>libuv</code>这个库，需要包含头文件<code>&lt;uv.h&gt;</code>。利用<code>uv_queue_work(uv_loop_t* loop, uv_work_t* req, uv_work_cb work_cb, uv_after_work_cb after_work_cb)</code>这个方法将任务发送到线程池，指明子线程的执行函数<code>work_cb</code>和回调函数<code>after_work_cb</code>后，子线程会执行<code>work_cb</code>，并且在线程执行完毕后回调<code>after_work_cb</code>。<code>uv_work_t* req</code>用来存放发起线程调用的请求信息，在执行函数<code>work_cb</code>和回调函数<code>after_work_cb</code>中可以通过<code>req</code>来获取主线程想要子线程处理的数据。在内存上，线程不共享栈，但是共享堆，因此，主线程可以通过一个结构体来包装数据然后在堆上创建该结构体的实例，子线程通过指针去堆上获取该结构体实例便可以获取到主线程想要传递的数据，也可以通过这个实例将数据返回给主线程。</p><p>以上面代码为例，在<code>accumulateAsync()</code>方法中，完成参数检查和提取以后，便可以开启一个子线程去对数据进行操作计算，不必等待子线程结束直接返回。JavaScript调用<code>accumulateAsync()</code>方法之后，实际上是开启了一个子线程去完成求和过程，<code>accumulateAsync()</code>方法调用后马上返回，因此不会阻塞到后续的JavaScript代码的执行。子线程的执行函数<code>calculate</code>会完成求和计算过程，并将求和结果存放到<code>Data</code>结构体的一个实例中，子线程执行完毕后会唤醒主线程，运行回调函数<code>calculateComplete</code>，在<code>calculateComplete</code>中完成对JavaScript回调函数的调用，将求和结果通过回调函数回传给JavaScript。</p><p>结构体<code>Data</code>中，存储JS回调函数的句柄时需要使用<code>Persistent</code>句柄，<code>Persistent</code>句柄需要主动执行代码进行释放，与之相对的<code>Local</code>句柄会在函数调用结束后句柄作用域消失时被释放，失去句柄引用的变量会被V8的垃圾清理机制自动清除。由于子线程执行时主线程的<code>accumulateAsync()</code>方法已经结束返回了，为了让回调函数不会清理，在子线程结束后能够顺利完成回调JavaScript，这里必须使用<code>Persistent</code>句柄。</p><p>将以下内容写入文件<code>binding.gyp</code>，完成编译构建得到<code>.node</code>文件。<br></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"targets"</span>: [&#123;</span><br><span class="line">    <span class="attr">"target_name"</span>: <span class="string">"accumulate_async"</span>,</span><br><span class="line">    <span class="attr">"sources"</span>: [<span class="string">"accumulate_async.cc"</span>]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>使用以下JS代码进行测试，输出结果如图所示，可以看到先输出的语句是<code>Hi~</code>，由于实现了异步调用，求和过程不会阻塞JavaScript代码的执行，因此在调用<code>accumulateAsync()</code>之后，跟在后面的<code>console.log(&#39;[AsyncDemo] Hi~&#39;)</code>不会被阻塞，正常执行。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async-demo</span></span><br><span class="line"><span class="keyword">const</span> AccumulateAsync = <span class="built_in">require</span>(<span class="string">'./build/Release/accumulate_async'</span>)</span><br><span class="line">AccumulateAsync.accumulateAsync(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, (sum) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[AsyncDemo] 1 + 3 + 4 + 7 = '</span> + sum)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'[AsyncDemo] Hi~'</span>)</span><br></pre></td></tr></table></figure><p></p><p><img src="/images/2018-04-19/3.png" alt="异步调用实例"></p><h1 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h1><p>实现C++类和实例的包装，让JavaScript能够直接使用到C++类和实例，这个过程的操作虽然繁琐了一点，但也不是太难，<code>&lt;node_object_wrap.h&gt;</code>中提供的API已经可以很方便地实现这个功能。实现C++插件接口的异步化，让JavaScript能够进行异步调用而不被阻塞，需要用到多线程的知识。在NodeJS官方文档中对如何使用<code>libuv</code>进行异步操作并没有相关例子展示，所以在写前面的例子的时候也比较折腾。<code>libuv</code>的API文档比较晦涩，幸好网上还有另一份介绍文档<a href="https://nikhilm.github.io/uvbook/" target="_blank" rel="external">【An Introduction to libuv】</a>，这份文档中除了对一些概念和API进行介绍之外，也会有给出代码示例，对初学者来说比较友好。</p></div><footer class="article-footer"><a data-url="https://hongchh.github.io/2018/NodeJS-Cpp-Addons之C-类实例包装与异步操作/" data-id="cjjcl3ciz002atktieq5jmhni" class="article-share-link"><i class="fa fa-share"></i>分享到</a><script>!function(n){n("body").on("click",function(){n(".article-share-box.on").removeClass("on")}).on("click",".article-share-link",function(t){t.stopPropagation();var e,a=n(this),o=a.attr("data-url"),r=encodeURIComponent(o),i="article-share-box-"+a.attr("data-id"),s=a.offset();if(n("#"+i).length){if((e=n("#"+i)).hasClass("on"))return void e.removeClass("on")}else{var l=['<div id="'+i+'" class="article-share-box">','<input class="article-share-input" value="'+o+'">','<div class="article-share-links">','<a href="https://twitter.com/intent/tweet?url='+r+'" class="article-share-twitter" target="_blank" title="Twitter"></a>','<a href="https://www.facebook.com/sharer.php?u='+r+'" class="article-share-facebook" target="_blank" title="Facebook"></a>','<a href="http://pinterest.com/pin/create/button/?url='+r+'" class="article-share-pinterest" target="_blank" title="Pinterest"></a>','<a href="https://plus.google.com/share?url='+r+'" class="article-share-google" target="_blank" title="Google+"></a>',"</div>","</div>"].join("");e=n(l),n("body").append(e)}n(".article-share-box.on").hide(),e.css({top:s.top+25,left:s.left}).addClass("on")}).on("click",".article-share-box",function(t){t.stopPropagation()}).on("click",".article-share-box-input",function(){n(this).select()}).on("click",".article-share-box-link",function(t){t.preventDefault(),t.stopPropagation(),window.open(this.href,"article-share-box-window-"+Date.now(),"width=500,height=450")})}(jQuery)</script></footer></div></article><section id="comments"></section></div></section><aside id="sidebar"><a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a><div class="sidebar-top"><p>关注我 :</p><ul class="social-links"><li><a class="social-tooltip" title="github" href="https://github.com/hongchh" target="_blank"><i class="icon fa fa-github"></i></a></li></ul></div><nav id="article-nav"><a href="/2018/微信小程序入坑-写一个简化版知乎日报/" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption">下一篇</strong><p class="article-nav-title">微信小程序入坑: 写一个简化版知乎日报</p><i class="icon fa fa-chevron-right" id="icon-chevron-right"></i> </a><a href="/2018/NodeJS-Cpp-Addons基础/" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">上一篇</strong><p class="article-nav-title">NodeJS C++ Addons基础</p><i class="icon fa fa-chevron-left" id="icon-chevron-left"></i></a></nav><div class="widgets-container"><div class="widget-wrap"><h3 class="widget-title">最新文章</h3><div class="widget"><ul id="recent-post"><li><div class="item-thumbnail"><a href="/2018/微信小程序入坑-写一个简化版知乎日报/" class="thumbnail"><span style="background-image:url(/images/2018-07-06/pages.png)" alt="微信小程序入坑: 写一个简化版知乎日报" class="thumbnail-image"></span></a></div><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2018/微信小程序入坑-写一个简化版知乎日报/" class="title">微信小程序入坑: 写一个简化版知乎日报</a></p><p class="item-date"><time datetime="2018-07-06T02:25:52.000Z" itemprop="datePublished">2018-07-06</time></p></div></li><li><div class="item-thumbnail"><a href="/2018/NodeJS-Cpp-Addons之C-类实例包装与异步操作/" class="thumbnail"><span style="background-image:url(/images/2018-04-19/1.png)" alt="NodeJS C++ Addons之C++类实例包装与异步操作" class="thumbnail-image"></span></a></div><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2018/NodeJS-Cpp-Addons之C-类实例包装与异步操作/" class="title">NodeJS C++ Addons之C++类实例包装与异步操作</a></p><p class="item-date"><time datetime="2018-04-19T09:20:27.000Z" itemprop="datePublished">2018-04-19</time></p></div></li><li><div class="item-thumbnail"><a href="/2018/NodeJS-Cpp-Addons基础/" class="thumbnail"><span style="background-image:url(/images/2018-04-16/1.png)" alt="NodeJS C++ Addons基础" class="thumbnail-image"></span></a></div><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2018/NodeJS-Cpp-Addons基础/" class="title">NodeJS C++ Addons基础</a></p><p class="item-date"><time datetime="2018-04-16T07:45:57.000Z" itemprop="datePublished">2018-04-16</time></p></div></li><li><div class="item-thumbnail"><a href="/2018/试玩NodeJS多进程/" class="thumbnail"><span style="background-image:url(/images/2018-04-11/master-worker.png)" alt="试玩NodeJS多进程" class="thumbnail-image"></span></a></div><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2018/试玩NodeJS多进程/" class="title">试玩NodeJS多进程</a></p><p class="item-date"><time datetime="2018-04-11T07:47:22.000Z" itemprop="datePublished">2018-04-11</time></p></div></li><li><div class="item-thumbnail"><a href="/2017/MonkeyEye电影售票系统-性能优化总结/" class="thumbnail"><span style="background-image:url(/images/2017-06-09-23.jpg)" alt="MonkeyEye电影售票系统-性能优化总结" class="thumbnail-image"></span></a></div><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2017/MonkeyEye电影售票系统-性能优化总结/" class="title">MonkeyEye电影售票系统-性能优化总结</a></p><p class="item-date"><time datetime="2017-06-09T07:43:09.000Z" itemprop="datePublished">2017-06-09</time></p></div></li></ul></div></div><div class="widget-wrap widget-list"><h3 class="widget-title">归档</h3><div class="widget"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">1</span></li></ul></div></div><div class="widget-wrap widget-list"><h3 class="widget-title">标签</h3><div class="widget"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NodeJS/">NodeJS</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/其他/">其他</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机网络/">计算机网络</a><span class="tag-list-count">3</span></li></ul></div></div><div class="widget-wrap widget-float"><h3 class="widget-title">标签云</h3><div class="widget tagcloud"><a href="/tags/JavaScript/" style="font-size:20px">JavaScript</a> <a href="/tags/NodeJS/" style="font-size:16px">NodeJS</a> <a href="/tags/Web/" style="font-size:18px">Web</a> <a href="/tags/其他/" style="font-size:12px">其他</a> <a href="/tags/前端/" style="font-size:10px">前端</a> <a href="/tags/数据库/" style="font-size:10px">数据库</a> <a href="/tags/数据结构与算法/" style="font-size:18px">数据结构与算法</a> <a href="/tags/计算机网络/" style="font-size:14px">计算机网络</a></div></div><div class="widget-wrap widget-list"><h3 class="widget-title">链接</h3><div class="widget"><ul><li><a href="http://blog.csdn.net/hongchh">CSDN</a></li></ul></div></div></div></aside></div></div></div><footer id="footer"><div class="container"><div class="container-inner"><a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a><div class="credit"><h1 class="logo-wrap"><a href="/" class="logo"></a></h1><p>&copy; 2018 洪创煌(hongchh_sysu@qq.com)</p><p>Powered by <a href="//hexo.io/" target="_blank">Hexo</a>. Theme by <a href="//github.com/ppoffice" target="_blank">PPOffice</a></p></div></div></div></footer><script src="/libs/lightgallery/js/lightgallery.min.js"></script><script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script><script src="/libs/lightgallery/js/lg-pager.min.js"></script><script src="/libs/lightgallery/js/lg-autoplay.min.js"></script><script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script><script src="/libs/lightgallery/js/lg-zoom.min.js"></script><script src="/libs/lightgallery/js/lg-hash.min.js"></script><script src="/libs/lightgallery/js/lg-share.min.js"></script><script src="/libs/lightgallery/js/lg-video.min.js"></script><script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="/js/main.js"></script></div></body>